import{mat4}from"../3rdparty/wgpu-matrix.module.min.js";function createCubeVertices(){const e=new Float32Array([-1,1,1,0,0,1,-1,-1,1,0,0,1,1,1,1,0,0,1,1,-1,1,0,0,1,1,1,-1,1,0,0,1,1,1,1,0,0,1,-1,-1,1,0,0,1,-1,1,1,0,0,1,1,-1,0,0,-1,1,-1,-1,0,0,-1,-1,1,-1,0,0,-1,-1,-1,-1,0,0,-1,-1,1,1,-1,0,0,-1,1,-1,-1,0,0,-1,-1,1,-1,0,0,-1,-1,-1,-1,0,0,1,-1,1,0,-1,0,-1,-1,1,0,-1,0,1,-1,-1,0,-1,0,-1,-1,-1,0,-1,0,-1,1,1,0,1,0,1,1,1,0,1,0,-1,1,-1,0,1,0,1,1,-1,0,1,0]);const t=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);return{vertexData:e,indexData:t,numVertices:t.length}}async function main(){const e=await(navigator.gpu?.requestAdapter());const t=await(e?.requestDevice());if(!t){fail("need a browser that supports WebGPU");return}const r=document.querySelector("canvas");const n=r.getContext("webgpu");const o=navigator.gpu.getPreferredCanvasFormat();n.configure({device:t,format:o,alphaMode:"premultiplied"});const i=t.createShaderModule({code:`\n      struct Uniforms {\n        viewDirectionProjectionInverse: mat4x4f,\n      };\n\n      struct VSOutput {\n        @builtin(position) position: vec4f,\n        @location(0) pos: vec4f,\n      };\n\n      @group(0) @binding(0) var<uniform> uni: Uniforms;\n      @group(0) @binding(1) var ourSampler: sampler;\n      @group(0) @binding(2) var ourTexture: texture_cube<f32>;\n\n      @vertex fn vs(@builtin(vertex_index) vNdx: u32) -> VSOutput {\n        let pos = array(\n          vec2f(-1, 3),\n          vec2f(-1,-1),\n          vec2f( 3,-1),\n        );\n        var vsOut: VSOutput;\n        vsOut.position = vec4f(pos[vNdx], 1, 1);\n        vsOut.pos = vsOut.position;\n        return vsOut;\n      }\n\n      @fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n        let t = uni.viewDirectionProjectionInverse * vsOut.pos;\n        return textureSample(ourTexture, ourSampler, normalize(t.xyz / t.w) * vec3f(1, 1, -1));\n      }\n    `});const a=t.createRenderPipeline({label:"no attributes",layout:"auto",vertex:{module:i},fragment:{module:i,targets:[{format:o}]},depthStencil:{depthWriteEnabled:true,depthCompare:"less-equal",format:"depth24plus"}});const s=t.createShaderModule({code:`\n      struct Uniforms {\n        projection: mat4x4f,\n        view: mat4x4f,\n        world: mat4x4f,\n        cameraPosition: vec3f,\n      };\n\n      struct Vertex {\n        @location(0) position: vec4f,\n        @location(1) normal: vec3f,\n      };\n\n      struct VSOutput {\n        @builtin(position) position: vec4f,\n        @location(0) worldPosition: vec3f,\n        @location(1) worldNormal: vec3f,\n      };\n\n      @group(0) @binding(0) var<uniform> uni: Uniforms;\n      @group(0) @binding(1) var ourSampler: sampler;\n      @group(0) @binding(2) var ourTexture: texture_cube<f32>;\n\n      @vertex fn vs(vert: Vertex) -> VSOutput {\n        var vsOut: VSOutput;\n        vsOut.position = uni.projection * uni.view * uni.world * vert.position;\n        vsOut.worldPosition = (uni.world * vert.position).xyz;\n        vsOut.worldNormal = (uni.world * vec4f(vert.normal, 0)).xyz;\n        return vsOut;\n      }\n\n      @fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n        let worldNormal = normalize(vsOut.worldNormal);\n        let eyeToSurfaceDir = normalize(vsOut.worldPosition - uni.cameraPosition);\n        let direction = reflect(eyeToSurfaceDir, worldNormal);\n\n        return textureSample(ourTexture, ourSampler, direction * vec3f(1, 1, -1));\n      }\n    `});const u=t.createRenderPipeline({label:"2 attributes",layout:"auto",vertex:{module:s,buffers:[{arrayStride:(3+3)*4,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"}]}]},fragment:{module:s,targets:[{format:o}]},primitive:{cullMode:"back"},depthStencil:{depthWriteEnabled:true,depthCompare:"less",format:"depth24plus"}});const c=(...e)=>{const t=Math.max(...e);return 1+Math.log2(t)|0};function l(e,t,r,{flipY:n}={}){r.forEach(((r,o)=>{e.queue.copyExternalImageToTexture({source:r,flipY:n},{texture:t,origin:[0,0,o]},{width:r.width,height:r.height})}));if(t.mipLevelCount>1){p(e,t)}}function f(e,t,r={}){const n=t[0];const o=e.createTexture({format:"rgba8unorm",mipLevelCount:r.mips?c(n.width,n.height):1,size:[n.width,n.height,t.length],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});l(e,o,t,r);return o}const p=(()=>{let e;let t;const r={};return function n(o,i){if(!t){t=o.createShaderModule({label:"textured quad shaders for mip level generation",code:`\n            struct VSOutput {\n              @builtin(position) position: vec4f,\n              @location(0) texcoord: vec2f,\n            };\n\n            @vertex fn vs(\n              @builtin(vertex_index) vertexIndex : u32\n            ) -> VSOutput {\n              let pos = array(\n\n                vec2f( 0.0,  0.0),  // center\n                vec2f( 1.0,  0.0),  // right, center\n                vec2f( 0.0,  1.0),  // center, top\n\n                // 2st triangle\n                vec2f( 0.0,  1.0),  // center, top\n                vec2f( 1.0,  0.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n\n              var vsOutput: VSOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);\n              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);\n              return vsOutput;\n            }\n\n            @group(0) @binding(0) var ourSampler: sampler;\n            @group(0) @binding(1) var ourTexture: texture_2d<f32>;\n\n            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n              return textureSample(ourTexture, ourSampler, fsInput.texcoord);\n            }\n          `});e=o.createSampler({minFilter:"linear",magFilter:"linear"})}if(!r[i.format]){r[i.format]=o.createRenderPipeline({label:"mip level generator pipeline",layout:"auto",vertex:{module:t},fragment:{module:t,targets:[{format:i.format}]}})}const a=r[i.format];const s=o.createCommandEncoder({label:"mip gen encoder"});let u=i.width;let c=i.height;let l=0;while(u>1||c>1){u=Math.max(1,u/2|0);c=Math.max(1,c/2|0);for(let t=0;t<i.depthOrArrayLayers;++t){const r=o.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:e},{binding:1,resource:i.createView({dimension:"2d",baseMipLevel:l,mipLevelCount:1,baseArrayLayer:t,arrayLayerCount:1})}]});const n={label:"our basic canvas renderPass",colorAttachments:[{view:i.createView({dimension:"2d",baseMipLevel:l+1,mipLevelCount:1,baseArrayLayer:t,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]};const u=s.beginRenderPass(n);u.setPipeline(a);u.setBindGroup(0,r);u.draw(6);u.end()}++l}const f=s.finish();o.queue.submit([f])}})();async function d(e){const t=await fetch(e);const r=await t.blob();return await createImageBitmap(r,{colorSpaceConversion:"none"})}async function m(e,t,r){const n=await Promise.all(t.map(d));return f(e,n,r)}const g=await m(t,["../resources/images/skybox/christmas_photo_studio_01/360degree/px.jpg","../resources/images/skybox/christmas_photo_studio_01/360degree/nx.jpg","../resources/images/skybox/christmas_photo_studio_01/360degree/py.jpg","../resources/images/skybox/christmas_photo_studio_01/360degree/ny.jpg","../resources/images/skybox/christmas_photo_studio_01/360degree/pz.jpg","../resources/images/skybox/christmas_photo_studio_01/360degree/nz.jpg"],{mips:true,flipY:false});const v=t.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"});const h=16*4;const x=t.createBuffer({label:"uniforms",size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const b=new Float32Array(h/4);const y=0;const w=b.subarray(y,y+16);const O=t.createBindGroup({label:"bind group for object",layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:v},{binding:2,resource:g.createView({dimension:"cube"})}]});const S=(16+16+16+3+1)*4;const P=t.createBuffer({label:"uniforms",size:S,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const T=new Float32Array(S/4);const U=0;const B=16;const _=32;const V=48;const C=T.subarray(U,U+16);const G=T.subarray(B,B+16);const D=T.subarray(_,_+16);const M=T.subarray(V,V+3);const{vertexData:A,indexData:z,numVertices:L}=createCubeVertices();const E=t.createBuffer({label:"vertex buffer vertices",size:A.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(E,0,A);const I=t.createBuffer({label:"index buffer",size:A.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(I,0,z);const N=t.createBindGroup({label:"bind group for object",layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:P}},{binding:1,resource:v},{binding:2,resource:g.createView({dimension:"cube"})}]});const q={label:"our basic canvas renderPass",colorAttachments:[{loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};let R;function j(e){e*=.001;const o=n.getCurrentTexture();q.colorAttachments[0].view=o.createView();if(!R||R.width!==o.width||R.height!==o.height){if(R){R.destroy()}R=t.createTexture({size:[o.width,o.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT})}q.depthStencilAttachment.view=R.createView();const i=t.createCommandEncoder();const s=i.beginRenderPass(q);const c=r.clientWidth/r.clientHeight;mat4.perspective(60*Math.PI/180,c,.1,1e3,C);M.set([Math.cos(e*.3)*10,0,.3*Math.sin(e*.3)*10]);const l=mat4.lookAt(M,[0,0,0],[0,1,0]);G.set(l);l[12]=0;l[13]=0;l[14]=0;const f=mat4.multiply(C,l);mat4.inverse(f,w);mat4.identity(D);mat4.rotateX(D,e*-.1,D);mat4.rotateY(D,e*-.2,D);t.queue.writeBuffer(P,0,T);t.queue.writeBuffer(x,0,b);s.setPipeline(u);s.setVertexBuffer(0,E);s.setIndexBuffer(I,"uint16");s.setBindGroup(0,N);s.drawIndexed(L);s.setPipeline(a);s.setBindGroup(0,O);s.draw(3);s.end();const p=i.finish();t.queue.submit([p]);requestAnimationFrame(j)}requestAnimationFrame(j);const F=new ResizeObserver((e=>{for(const r of e){const e=r.target;const n=r.contentBoxSize[0].inlineSize;const o=r.contentBoxSize[0].blockSize;e.width=Math.max(1,Math.min(n,t.limits.maxTextureDimension2D));e.height=Math.max(1,Math.min(o,t.limits.maxTextureDimension2D))}}));F.observe(r)}function fail(e){alert(e)}main();