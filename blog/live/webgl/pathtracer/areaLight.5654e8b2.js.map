{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,sB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SCMA,SAAU,IAET,GAAM,CAAA,UACL,CAAS,CAAA,QACT,CAAO,CAAA,WACP,CAAU,CAAA,eACV,CAAc,CAAA,cACd,CAAa,CAAA,aACb,CAAY,CAAA,UACZ,CAAS,CAAA,MACT,CAAK,CAAA,SACL,CAAQ,CACR,CAAG,IAAI,CACF,EAAa,IAAI,EAAA,OAAM,CACvB,EAAc,IAAI,EAAA,OAAM,CAExB,EAAgB,EAAW,QAAQ,CACrC,CAAE,EAAc,EAAc,CAAG,EAErC,OAAe,CAET,GAEJ,EAAc,OAAO,CAAG,IAAI,CAAC,cAAc,CAAK,CAAA,IAAI,CAAC,OAAO,CAAG,CAAA,EAC/D,EAAS,QAAQ,CAAG,EAAA,UAAS,CAC7B,EAAS,OAAO,CAAG,IAInB,EAAS,OAAO,CAAG,IAAI,CAAC,cAAc,CAAK,CAAA,IAAI,CAAC,OAAO,CAAG,CAAA,EAC1D,EAAS,QAAQ,CAAG,EAAA,cAAa,EAIlC,GAAM,CAAE,EAAM,EAAM,EAAM,EAAM,CAAG,EAE7B,EAAI,EAAe,KAAK,CACxB,EAAI,EAAe,MAAM,CAC/B,EAAS,UAAU,CAAC,GAAG,CAAE,EAAI,EAAM,EAAI,GACvC,EAAS,YAAY,CAAG,EAAa,OAAO,CAC5C,EAAS,iBAAiB,CAAC,IAAI,CAAE,GAAI,EAAS,OAAO,CAAG,EAAS,mBAAmB,CAAG,GACvF,EAAS,iBAAiB,CAAC,IAAI,GAC/B,EAAS,IAAI,GAEb,IAAM,EAAS,IAAI,CAAC,KAAK,CAAC,CAAC,EAAI,EACzB,EAAS,IAAI,CAAC,KAAK,C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I,CAAC,QAAQ,CAAE,EAAO,KAAK,EAC3B,IAAI,CAAC,KAAK,CAAG,EAAO,KAAK,AAE1B,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,GCrNO,IAAM,EAA0B,CAAC;;;;;;;;;;;;AAYxC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,kB,I,GCZM,IAAM,EAA4B,CAAC;;;;;;;;;;;;AAY1C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,GCZM,IAAM,EAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFxC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,GCtFM,IAAM,EAAkC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DhD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,qB,I,GC9DM,IAAM,EAA+B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmE7C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,2B,I,GCnEM,IAAM,EAAqC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuNnD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,GCvNM,IAAM,EAA8B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuG5C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,+B,I,GCvGM,IAAM,EAAyC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DvD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,2B,I,GC5DM,IAAM,EAAoC,CAAC;;;;;;;;;;;;;;;;;;;;;;;AAuBlD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,uB,I,GCxBM,IAAM,EAAiC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiD/C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,GCtCM,IAAM,EAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsbzC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,GCjcM,IAAM,EAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;AAqBxC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,GCrBM,IAAM,EAAkC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsIhD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,kB,I,GCtIM,IAAM,EAA4B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiG1C,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,6B,I,GCjGM,IAAM,EAAuC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DrD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,yB,I,GC7DM,IAAM,EAAmC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkLjD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,wB,I,GClLM,IAAM,EAAkC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmFhD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,qC,I,GCnFM,IAAM,EAA6C,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgG3D,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,8B,I,GC/FM,IAAM,EAAwC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmUtD,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,GCpUM,IAAM,EAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDzC,CAAC,A,G,E,Q,S,C,C,C,E,E,E,O,C,uB,I,GCjDM,IAAM,EAAiC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+C/C,CAAC,A","sources":["<anon>","src/core/PathTracingRenderer.js","src/materials/fullscreen/BlendMaterial.js","src/utils/SobolNumberMapGenerator.js","src/shader/rand/sobol.glsl.js","src/materials/pathtracing/PhysicalPathTracingMaterial.js","src/uniforms/PhysicalCameraUniform.js","src/objects/PhysicalCamera.js","src/uniforms/EquirectHdrInfoUniform.js","src/utils/TextureUtils.js","src/uniforms/LightsInfoUniformStruct.js","src/uniforms/AttributesTextureArray.js","src/uniforms/FloatAttributeTextureArray.js","src/uniforms/MaterialsTexture.js","src/core/utils/sceneUpdateUtils.js","src/uniforms/RenderTarget2DArray.js","src/uniforms/StratifiedSamplesTexture.js","src/uniforms/stratified/StratifiedSamplerCombined.js","src/uniforms/stratified/StratifiedSampler.js","src/textures/BlueNoiseTexture.js","src/textures/blueNoise/BlueNoiseGenerator.js","src/textures/blueNoise/utils.js","src/textures/blueNoise/BlueNoiseSamples.js","src/shader/structs/camera_struct.glsl.js","src/shader/structs/equirect_struct.glsl.js","src/shader/structs/lights_struct.glsl.js","src/shader/structs/surface_record_struct.glsl.js","src/shader/sampling/equirect_sampling_functions.glsl.js","src/shader/sampling/light_sampling_functions.glsl.js","src/shader/common/fresnel_functions.glsl.js","src/shader/common/shape_intersection_functions.glsl.js","src/shader/common/texture_sample_functions.glsl.js","src/shader/rand/stratified.glsl.js","src/shader/bsdf/bsdf_functions.glsl.js","src/shader/bsdf/fog_functions.glsl.js","src/shader/bsdf/iridescence_functions.glsl.js","src/shader/bsdf/sheen_functions.glsl.js","src/shader/bvh/inside_fog_volume_function.glsl.js","src/materials/pathtracing/glsl/attenuate_hit_function.glsl.js","src/materials/pathtracing/glsl/camera_util_functions.glsl.js","src/materials/pathtracing/glsl/direct_light_contribution_function.glsl.js","src/materials/pathtracing/glsl/get_surface_record_function.glsl.js","src/materials/pathtracing/glsl/render_structs.glsl.js","src/materials/pathtracing/glsl/trace_scene_function.glsl.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"hWds8\", function(module, exports) {\n\n$parcel$export(module.exports, \"PathTracingRenderer\", () => $d0f249dd9f03ac59$export$196da6cc71a4331);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $4dqlL = parcelRequire(\"4dqlL\");\n\nvar $9kitj = parcelRequire(\"9kitj\");\n\nvar $ieQ3q = parcelRequire(\"ieQ3q\");\nfunction* $d0f249dd9f03ac59$var$renderTask() {\n    const { _renderer: _renderer, _fsQuad: _fsQuad, _blendQuad: _blendQuad, _primaryTarget: _primaryTarget, _blendTargets: _blendTargets, _sobolTarget: _sobolTarget, _subframe: _subframe, alpha: alpha, material: material } = this;\n    const _ogScissor = new (0, $ilwiq.Vector4)();\n    const _ogViewport = new (0, $ilwiq.Vector4)();\n    const blendMaterial = _blendQuad.material;\n    let [blendTarget1, blendTarget2] = _blendTargets;\n    while(true){\n        if (alpha) {\n            blendMaterial.opacity = this._opacityFactor / (this.samples + 1);\n            material.blending = (0, $ilwiq.NoBlending);\n            material.opacity = 1;\n        } else {\n            material.opacity = this._opacityFactor / (this.samples + 1);\n            material.blending = (0, $ilwiq.NormalBlending);\n        }\n        const [subX, subY, subW, subH] = _subframe;\n        const w = _primaryTarget.width;\n        const h = _primaryTarget.height;\n        material.resolution.set(w * subW, h * subH);\n        material.sobolTexture = _sobolTarget.texture;\n        material.stratifiedTexture.init(20, material.bounces + material.transmissiveBounces + 5);\n        material.stratifiedTexture.next();\n        material.seed++;\n        const tilesX = this.tiles.x || 1;\n        const tilesY = this.tiles.y || 1;\n        const totalTiles = tilesX * tilesY;\n        const pxSubW = Math.ceil(w * subW);\n        const pxSubH = Math.ceil(h * subH);\n        const pxSubX = Math.floor(subX * w);\n        const pxSubY = Math.floor(subY * h);\n        const pxTileW = Math.ceil(pxSubW / tilesX);\n        const pxTileH = Math.ceil(pxSubH / tilesY);\n        for(let y = 0; y < tilesY; y++)for(let x = 0; x < tilesX; x++){\n            // store og state\n            const ogRenderTarget = _renderer.getRenderTarget();\n            const ogAutoClear = _renderer.autoClear;\n            const ogScissorTest = _renderer.getScissorTest();\n            _renderer.getScissor(_ogScissor);\n            _renderer.getViewport(_ogViewport);\n            let tx = x;\n            let ty = y;\n            if (!this.stableTiles) {\n                const tileIndex = this._currentTile % (tilesX * tilesY);\n                tx = tileIndex % tilesX;\n                ty = ~~(tileIndex / tilesX);\n                this._currentTile = tileIndex + 1;\n            }\n            // set the scissor and the viewport on the render target\n            // note that when using the webgl renderer set viewport the device pixel ratio\n            // is multiplied into the field causing some pixels to not be rendered\n            const reverseTy = tilesY - ty - 1;\n            _primaryTarget.scissor.set(pxSubX + tx * pxTileW, pxSubY + reverseTy * pxTileH, Math.min(pxTileW, pxSubW - tx * pxTileW), Math.min(pxTileH, pxSubH - reverseTy * pxTileH));\n            _primaryTarget.viewport.set(pxSubX, pxSubY, pxSubW, pxSubH);\n            // three.js renderer takes values relative to the current pixel ratio\n            _renderer.setRenderTarget(_primaryTarget);\n            _renderer.setScissorTest(true);\n            _renderer.autoClear = false;\n            _fsQuad.render(_renderer);\n            // reset original renderer state\n            _renderer.setViewport(_ogViewport);\n            _renderer.setScissor(_ogScissor);\n            _renderer.setScissorTest(ogScissorTest);\n            _renderer.setRenderTarget(ogRenderTarget);\n            _renderer.autoClear = ogAutoClear;\n            // swap and blend alpha targets\n            if (alpha) {\n                blendMaterial.target1 = blendTarget1.texture;\n                blendMaterial.target2 = _primaryTarget.texture;\n                _renderer.setRenderTarget(blendTarget2);\n                _blendQuad.render(_renderer);\n                _renderer.setRenderTarget(ogRenderTarget);\n            }\n            this.samples += 1 / totalTiles;\n            // round the samples value if we've finished the tiles\n            if (x === tilesX - 1 && y === tilesY - 1) this.samples = Math.round(this.samples);\n            yield;\n        }\n        [blendTarget1, blendTarget2] = [\n            blendTarget2,\n            blendTarget1\n        ];\n    }\n}\nconst $d0f249dd9f03ac59$var$ogClearColor = new (0, $ilwiq.Color)();\nclass $d0f249dd9f03ac59$export$196da6cc71a4331 {\n    get material() {\n        return this._fsQuad.material;\n    }\n    set material(v) {\n        this._fsQuad.material.removeEventListener(\"recompilation\", this._compileFunction);\n        v.addEventListener(\"recompilation\", this._compileFunction);\n        this._fsQuad.material = v;\n    }\n    get target() {\n        return this._alpha ? this._blendTargets[1] : this._primaryTarget;\n    }\n    set alpha(v) {\n        if (this._alpha === v) return;\n        if (!v) {\n            this._blendTargets[0].dispose();\n            this._blendTargets[1].dispose();\n        }\n        this._alpha = v;\n        this.reset();\n    }\n    get alpha() {\n        return this._alpha;\n    }\n    get isCompiling() {\n        return Boolean(this._compilePromise);\n    }\n    constructor(renderer){\n        this.camera = null;\n        this.tiles = new (0, $ilwiq.Vector2)(3, 3);\n        this.stableNoise = false;\n        this.stableTiles = true;\n        this.samples = 0;\n        this._subframe = new (0, $ilwiq.Vector4)(0, 0, 1, 1);\n        this._opacityFactor = 1.0;\n        this._renderer = renderer;\n        this._alpha = false;\n        this._fsQuad = new (0, $RPVlj.FullScreenQuad)(new (0, $ieQ3q.PhysicalPathTracingMaterial)());\n        this._blendQuad = new (0, $RPVlj.FullScreenQuad)(new (0, $4dqlL.BlendMaterial)());\n        this._task = null;\n        this._currentTile = 0;\n        this._compilePromise = null;\n        this._sobolTarget = new (0, $9kitj.SobolNumberMapGenerator)().generate(renderer);\n        this._primaryTarget = new (0, $ilwiq.WebGLRenderTarget)(1, 1, {\n            format: (0, $ilwiq.RGBAFormat),\n            type: (0, $ilwiq.FloatType),\n            magFilter: (0, $ilwiq.NearestFilter),\n            minFilter: (0, $ilwiq.NearestFilter)\n        });\n        this._blendTargets = [\n            new (0, $ilwiq.WebGLRenderTarget)(1, 1, {\n                format: (0, $ilwiq.RGBAFormat),\n                type: (0, $ilwiq.FloatType),\n                magFilter: (0, $ilwiq.NearestFilter),\n                minFilter: (0, $ilwiq.NearestFilter)\n            }),\n            new (0, $ilwiq.WebGLRenderTarget)(1, 1, {\n                format: (0, $ilwiq.RGBAFormat),\n                type: (0, $ilwiq.FloatType),\n                magFilter: (0, $ilwiq.NearestFilter),\n                minFilter: (0, $ilwiq.NearestFilter)\n            })\n        ];\n        // function for listening to for triggered compilation so we can wait for compilation to finish\n        // before starting to render\n        this._compileFunction = ()=>{\n            const promise = this.compileMaterial(this._fsQuad._mesh);\n            promise.then(()=>{\n                if (this._compilePromise === promise) this._compilePromise = null;\n            });\n            this._compilePromise = promise;\n        };\n        this.material.addEventListener(\"recompilation\", this._compileFunction);\n    }\n    compileMaterial() {\n        return this._renderer.compileAsync(this._fsQuad._mesh);\n    }\n    setCamera(camera) {\n        const { material: material } = this;\n        material.cameraWorldMatrix.copy(camera.matrixWorld);\n        material.invProjectionMatrix.copy(camera.projectionMatrixInverse);\n        material.physicalCamera.updateFrom(camera);\n        // Perspective camera (default)\n        let cameraType = 0;\n        // An orthographic projection matrix will always have the bottom right element == 1\n        // And a perspective projection matrix will always have the bottom right element == 0\n        if (camera.projectionMatrix.elements[15] > 0) // Orthographic\n        cameraType = 1;\n        if (camera.isEquirectCamera) // Equirectangular\n        cameraType = 2;\n        material.setDefine(\"CAMERA_TYPE\", cameraType);\n        this.camera = camera;\n    }\n    setSize(w, h) {\n        w = Math.ceil(w);\n        h = Math.ceil(h);\n        if (this._primaryTarget.width === w && this._primaryTarget.height === h) return;\n        this._primaryTarget.setSize(w, h);\n        this._blendTargets[0].setSize(w, h);\n        this._blendTargets[1].setSize(w, h);\n        this.reset();\n    }\n    getSize(target) {\n        target.x = this._primaryTarget.width;\n        target.y = this._primaryTarget.height;\n    }\n    dispose() {\n        this._primaryTarget.dispose();\n        this._blendTargets[0].dispose();\n        this._blendTargets[1].dispose();\n        this._sobolTarget.dispose();\n        this._fsQuad.dispose();\n        this._blendQuad.dispose();\n        this._task = null;\n    }\n    reset() {\n        const { _renderer: _renderer, _primaryTarget: _primaryTarget, _blendTargets: _blendTargets } = this;\n        const ogRenderTarget = _renderer.getRenderTarget();\n        const ogClearAlpha = _renderer.getClearAlpha();\n        _renderer.getClearColor($d0f249dd9f03ac59$var$ogClearColor);\n        _renderer.setRenderTarget(_primaryTarget);\n        _renderer.setClearColor(0, 0);\n        _renderer.clearColor();\n        _renderer.setRenderTarget(_blendTargets[0]);\n        _renderer.setClearColor(0, 0);\n        _renderer.clearColor();\n        _renderer.setRenderTarget(_blendTargets[1]);\n        _renderer.setClearColor(0, 0);\n        _renderer.clearColor();\n        _renderer.setClearColor($d0f249dd9f03ac59$var$ogClearColor, ogClearAlpha);\n        _renderer.setRenderTarget(ogRenderTarget);\n        this.samples = 0;\n        this._task = null;\n        this.material.stratifiedTexture.stableNoise = this.stableNoise;\n        if (this.stableNoise) {\n            this.material.seed = 0;\n            this.material.stratifiedTexture.reset();\n        }\n    }\n    update() {\n        // ensure we've updated our defines before rendering so we can ensure we\n        // can wait for compilation to finish\n        this.material.onBeforeRender();\n        if (this.isCompiling) return;\n        if (!this._task) this._task = $d0f249dd9f03ac59$var$renderTask.call(this);\n        this._task.next();\n    }\n}\n\n});\nparcelRegister(\"4dqlL\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlendMaterial\", () => $311cd0e92e040f64$export$70ee8b3cbd6f21d8);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9fZ6X = parcelRequire(\"9fZ6X\");\nclass $311cd0e92e040f64$export$70ee8b3cbd6f21d8 extends (0, $9fZ6X.MaterialBase) {\n    constructor(parameters){\n        super({\n            blending: (0, $ilwiq.NoBlending),\n            uniforms: {\n                target1: {\n                    value: null\n                },\n                target2: {\n                    value: null\n                },\n                opacity: {\n                    value: 1.0\n                }\n            },\n            vertexShader: /* glsl */ `\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\n            fragmentShader: /* glsl */ `\r\n\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tuniform sampler2D target1;\r\n\t\t\t\tuniform sampler2D target2;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\r\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\r\n\r\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\r\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\r\n\r\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\r\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}`\n        });\n        this.setValues(parameters);\n    }\n}\n\n});\n\nparcelRegister(\"9kitj\", function(module, exports) {\n\n$parcel$export(module.exports, \"SobolNumberMapGenerator\", () => $6ca44f672d576995$export$4e8e5459f15b1dca);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\n\nvar $9fZ6X = parcelRequire(\"9fZ6X\");\n\nvar $ffLvN = parcelRequire(\"ffLvN\");\nclass $6ca44f672d576995$var$SobolNumbersMaterial extends (0, $9fZ6X.MaterialBase) {\n    constructor(){\n        super({\n            blending: (0, $ilwiq.NoBlending),\n            uniforms: {\n                resolution: {\n                    value: new (0, $ilwiq.Vector2)()\n                }\n            },\n            vertexShader: /* glsl */ `\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\n            fragmentShader: /* glsl */ `\r\n\r\n\t\t\t\t${(0, $ffLvN.sobol_common)}\r\n\t\t\t\t${(0, $ffLvN.sobol_point_generation)}\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\r\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\n        });\n    }\n}\nclass $6ca44f672d576995$export$4e8e5459f15b1dca {\n    generate(renderer, dimensions = 256) {\n        const target = new (0, $ilwiq.WebGLRenderTarget)(dimensions, dimensions, {\n            type: (0, $ilwiq.FloatType),\n            format: (0, $ilwiq.RGBAFormat),\n            minFilter: (0, $ilwiq.NearestFilter),\n            magFilter: (0, $ilwiq.NearestFilter),\n            generateMipmaps: false\n        });\n        const ogTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(target);\n        const quad = new (0, $RPVlj.FullScreenQuad)(new $6ca44f672d576995$var$SobolNumbersMaterial());\n        quad.material.resolution.set(dimensions, dimensions);\n        quad.render(renderer);\n        renderer.setRenderTarget(ogTarget);\n        quad.dispose();\n        return target;\n    }\n}\n\n});\nparcelRegister(\"ffLvN\", function(module, exports) {\n\n$parcel$export(module.exports, \"sobol_common\", () => $b1ad1c9578ecec04$export$603c58c7e29c9b0);\n$parcel$export(module.exports, \"sobol_point_generation\", () => $b1ad1c9578ecec04$export$96e4d35266bd337b);\n$parcel$export(module.exports, \"sobol_functions\", () => $b1ad1c9578ecec04$export$79b4ab6803c188d5);\n// References\n// - https://jcgt.org/published/0009/04/01/\n// - Code from https://www.shadertoy.com/view/WtGyDm\n// functions to generate multi-dimensions variables of the same functions\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\nfunction $b1ad1c9578ecec04$var$generateSobolFunctionVariants(dim = 1) {\n    let type = \"uint\";\n    if (dim > 1) type = \"uvec\" + dim;\n    return /* glsl */ `\r\n\t\t${type} sobolReverseBits( ${type} x ) {\r\n\r\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\r\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\r\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\r\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\r\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\r\n\r\n\t\t}\r\n\r\n\t\t${type} sobolHashCombine( uint seed, ${type} v ) {\r\n\r\n\t\t\treturn seed ^ ( v + ${type}( ( seed << 6 ) + ( seed >> 2 ) ) );\r\n\r\n\t\t}\r\n\r\n\t\t${type} sobolLaineKarrasPermutation( ${type} x, ${type} seed ) {\r\n\r\n\t\t\tx += seed;\r\n\t\t\tx ^= x * 0x6c50b47cu;\r\n\t\t\tx ^= x * 0xb82f1e52u;\r\n\t\t\tx ^= x * 0xc7afe638u;\r\n\t\t\tx ^= x * 0x8d22f6e6u;\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\r\n\t\t${type} nestedUniformScrambleBase2( ${type} x, ${type} seed ) {\r\n\r\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\r\n\t\t\tx = sobolReverseBits( x );\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\t`;\n}\nfunction $b1ad1c9578ecec04$var$generateSobolSampleFunctions(dim = 1) {\n    let utype = \"uint\";\n    let vtype = \"float\";\n    let num = \"\";\n    let components = \".r\";\n    let combineValues = \"1u\";\n    if (dim > 1) {\n        utype = \"uvec\" + dim;\n        vtype = \"vec\" + dim;\n        num = dim + \"\";\n        if (dim === 2) {\n            components = \".rg\";\n            combineValues = \"uvec2( 1u, 2u )\";\n        } else if (dim === 3) {\n            components = \".rgb\";\n            combineValues = \"uvec3( 1u, 2u, 3u )\";\n        } else {\n            components = \"\";\n            combineValues = \"uvec4( 1u, 2u, 3u, 4u )\";\n        }\n    }\n    return /* glsl */ `\r\n\r\n\t\t${vtype} sobol${num}( int effect ) {\r\n\r\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\r\n\t\t\tuint index = sobolPathIndex;\r\n\r\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\r\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\r\n\t\t\t${vtype} sobol_pt = sobolGetTexturePoint( shuffled_index )${components};\r\n\t\t\t${utype} result = ${utype}( sobol_pt * 16777216.0 );\r\n\r\n\t\t\t${utype} seed2 = sobolHashCombine( seed, ${combineValues} );\r\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\r\n\r\n\t\t\treturn SOBOL_FACTOR * ${vtype}( result >> 8 );\r\n\r\n\t\t}\r\n\t`;\n}\nconst $b1ad1c9578ecec04$export$603c58c7e29c9b0 = /* glsl */ `\r\n\r\n\t// Utils\r\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\r\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\r\n\r\n\t${$b1ad1c9578ecec04$var$generateSobolFunctionVariants(1)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolFunctionVariants(2)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolFunctionVariants(3)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolFunctionVariants(4)}\r\n\r\n\tuint sobolHash( uint x ) {\r\n\r\n\t\t// finalizer from murmurhash3\r\n\t\tx ^= x >> 16;\r\n\t\tx *= 0x85ebca6bu;\r\n\t\tx ^= x >> 13;\r\n\t\tx *= 0xc2b2ae35u;\r\n\t\tx ^= x >> 16;\r\n\t\treturn x;\r\n\r\n\t}\r\n\r\n`;\nconst $b1ad1c9578ecec04$export$96e4d35266bd337b = /* glsl */ `\r\n\r\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\r\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\r\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\r\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\r\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\r\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\r\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\r\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\r\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\r\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\r\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\r\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\r\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\r\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\r\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\r\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\r\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\r\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\r\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\r\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\r\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\r\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\r\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\r\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\r\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\r\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\r\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\r\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\r\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\r\n\t);\r\n\r\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\r\n\r\n\t\tuint X = 0u;\r\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\r\n\r\n\t\t\tuint mask = ( index >> bit ) & 1u;\r\n\t\t\tX ^= mask * directions[ bit ];\r\n\r\n\t\t}\r\n\t\treturn X;\r\n\r\n\t}\r\n\r\n\tvec4 generateSobolPoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\treturn vec4( 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\t// NOTE: this sobol \"direction\" is also available but we can't write out 5 components\r\n\t\t// uint x = index & 0x00ffffffu;\r\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\r\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\r\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\r\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\r\n\r\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\r\n\r\n\t}\r\n\r\n`;\nconst $b1ad1c9578ecec04$export$79b4ab6803c188d5 = /* glsl */ `\r\n\r\n\t// Seeds\r\n\tuniform sampler2D sobolTexture;\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\r\n\tuint sobolGetSeed( uint bounce, uint effect ) {\r\n\r\n\t\treturn sobolHash(\r\n\t\t\tsobolHashCombine(\r\n\t\t\t\tsobolHashCombine(\r\n\t\t\t\t\tsobolHash( bounce ),\r\n\t\t\t\t\tsobolPixelIndex\r\n\t\t\t\t),\r\n\t\t\t\teffect\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tvec4 sobolGetTexturePoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\tindex = index % SOBOL_MAX_POINTS;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\r\n\t\tuint y = index / dim.x;\r\n\t\tuint x = index - y * dim.x;\r\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\r\n\t\treturn texture( sobolTexture, uv );\r\n\r\n\t}\r\n\r\n\t${$b1ad1c9578ecec04$var$generateSobolSampleFunctions(1)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolSampleFunctions(2)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolSampleFunctions(3)}\r\n\t${$b1ad1c9578ecec04$var$generateSobolSampleFunctions(4)}\r\n\r\n`;\n\n});\n\n\nparcelRegister(\"ieQ3q\", function(module, exports) {\n\n$parcel$export(module.exports, \"PhysicalPathTracingMaterial\", () => $d471e9adcf389a5c$export$746cbc9e65f5bcb8);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9fZ6X = parcelRequire(\"9fZ6X\");\n\nvar $2vjHu = parcelRequire(\"2vjHu\");\nvar $3mzmA = parcelRequire(\"3mzmA\");\nvar $hN8zD = parcelRequire(\"hN8zD\");\n\nvar $iyhQ7 = parcelRequire(\"iyhQ7\");\n\nvar $kAJM1 = parcelRequire(\"kAJM1\");\n\nvar $TWVPU = parcelRequire(\"TWVPU\");\n\nvar $6Q19u = parcelRequire(\"6Q19u\");\n\nvar $laA5G = parcelRequire(\"laA5G\");\n\nvar $12pjC = parcelRequire(\"12pjC\");\n\nvar $k5Ikv = parcelRequire(\"k5Ikv\");\n\nvar $hLXJE = parcelRequire(\"hLXJE\");\n\nvar $sORjD = parcelRequire(\"sORjD\");\nvar $WBvYF = parcelRequire(\"WBvYF\");\nvar $1QwjS = parcelRequire(\"1QwjS\");\nvar $1r4sY = parcelRequire(\"1r4sY\");\nvar $asLEI = parcelRequire(\"asLEI\");\n\nvar $6VF8W = parcelRequire(\"6VF8W\");\nvar $232IN = parcelRequire(\"232IN\");\nvar $cp6U0 = parcelRequire(\"cp6U0\");\n\nvar $8KxWl = parcelRequire(\"8KxWl\");\nvar $fYvb1 = parcelRequire(\"fYvb1\");\nvar $d9skn = parcelRequire(\"d9skn\");\nvar $jpfro = parcelRequire(\"jpfro\");\nvar $dUUQZ = parcelRequire(\"dUUQZ\");\n\nvar $kmALz = parcelRequire(\"kmALz\");\nvar $ffLvN = parcelRequire(\"ffLvN\");\nvar $gCBx4 = parcelRequire(\"gCBx4\");\n\nvar $6voD8 = parcelRequire(\"6voD8\");\nvar $4GDCw = parcelRequire(\"4GDCw\");\nvar $8keuf = parcelRequire(\"8keuf\");\nvar $9kAYu = parcelRequire(\"9kAYu\");\nvar $5SszG = parcelRequire(\"5SszG\");\n\nvar $hB5SN = parcelRequire(\"hB5SN\");\n\nvar $1zk7M = parcelRequire(\"1zk7M\");\nvar $eJ3gD = parcelRequire(\"eJ3gD\");\nvar $eZnIg = parcelRequire(\"eZnIg\");\nvar $bwtQK = parcelRequire(\"bwtQK\");\nvar $ioRiK = parcelRequire(\"ioRiK\");\nvar $euI5d = parcelRequire(\"euI5d\");\nclass $d471e9adcf389a5c$export$746cbc9e65f5bcb8 extends (0, $9fZ6X.MaterialBase) {\n    onBeforeRender() {\n        this.setDefine(\"FEATURE_DOF\", this.physicalCamera.bokehSize === 0 ? 0 : 1);\n        this.setDefine(\"FEATURE_BACKGROUND_MAP\", this.backgroundMap ? 1 : 0);\n        this.setDefine(\"FEATURE_FOG\", this.materials.features.isUsed(\"FOG\") ? 1 : 0);\n    }\n    constructor(parameters){\n        super({\n            transparent: true,\n            depthWrite: false,\n            defines: {\n                FEATURE_MIS: 1,\n                FEATURE_RUSSIAN_ROULETTE: 1,\n                FEATURE_DOF: 1,\n                FEATURE_BACKGROUND_MAP: 0,\n                FEATURE_FOG: 1,\n                // 0 = PCG\n                // 1 = Sobol\n                // 2 = Stratified List\n                RANDOM_TYPE: 2,\n                // 0 = Perspective\n                // 1 = Orthographic\n                // 2 = Equirectangular\n                CAMERA_TYPE: 0,\n                DEBUG_MODE: 0,\n                ATTR_NORMAL: 0,\n                ATTR_TANGENT: 1,\n                ATTR_UV: 2,\n                ATTR_COLOR: 3,\n                MATERIAL_PIXELS: (0, $laA5G.MATERIAL_PIXELS)\n            },\n            uniforms: {\n                // path trace uniforms\n                resolution: {\n                    value: new (0, $ilwiq.Vector2)()\n                },\n                opacity: {\n                    value: 1\n                },\n                bounces: {\n                    value: 10\n                },\n                transmissiveBounces: {\n                    value: 10\n                },\n                filterGlossyFactor: {\n                    value: 0\n                },\n                // camera uniforms\n                physicalCamera: {\n                    value: new (0, $iyhQ7.PhysicalCameraUniform)()\n                },\n                cameraWorldMatrix: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                invProjectionMatrix: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                // scene uniforms\n                bvh: {\n                    value: new (0, $3mzmA.MeshBVHUniformStruct)()\n                },\n                attributesArray: {\n                    value: new (0, $6Q19u.AttributesTextureArray)()\n                },\n                materialIndexAttribute: {\n                    value: new (0, $hN8zD.UIntVertexAttributeTexture)()\n                },\n                materials: {\n                    value: new (0, $laA5G.MaterialsTexture)()\n                },\n                textures: {\n                    value: new (0, $12pjC.RenderTarget2DArray)().texture\n                },\n                // light uniforms\n                lights: {\n                    value: new (0, $TWVPU.LightsInfoUniformStruct)()\n                },\n                iesProfiles: {\n                    value: new (0, $12pjC.RenderTarget2DArray)(360, 180, {\n                        type: (0, $ilwiq.HalfFloatType),\n                        wrapS: (0, $ilwiq.ClampToEdgeWrapping),\n                        wrapT: (0, $ilwiq.ClampToEdgeWrapping)\n                    }).texture\n                },\n                environmentIntensity: {\n                    value: 1.0\n                },\n                environmentRotation: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                envMapInfo: {\n                    value: new (0, $kAJM1.EquirectHdrInfoUniform)()\n                },\n                // background uniforms\n                backgroundBlur: {\n                    value: 0.0\n                },\n                backgroundMap: {\n                    value: null\n                },\n                backgroundAlpha: {\n                    value: 1.0\n                },\n                backgroundIntensity: {\n                    value: 1.0\n                },\n                backgroundRotation: {\n                    value: new (0, $ilwiq.Matrix4)()\n                },\n                // randomness uniforms\n                seed: {\n                    value: 0\n                },\n                sobolTexture: {\n                    value: null\n                },\n                stratifiedTexture: {\n                    value: new (0, $k5Ikv.StratifiedSamplesTexture)()\n                },\n                stratifiedOffsetTexture: {\n                    value: new (0, $hLXJE.BlueNoiseTexture)(64, 1)\n                }\n            },\n            vertexShader: /* glsl */ `\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\r\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\n            fragmentShader: /* glsl */ `\r\n\t\t\t\t#define RAY_OFFSET 1e-4\r\n\t\t\t\t#define INFINITY 1e20\r\n\r\n\t\t\t\tprecision highp isampler2D;\r\n\t\t\t\tprecision highp usampler2D;\r\n\t\t\t\tprecision highp sampler2DArray;\r\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\t// bvh intersection\r\n\t\t\t\t${(0, $2vjHu).common_functions}\r\n\t\t\t\t${(0, $2vjHu).bvh_struct_definitions}\r\n\t\t\t\t${(0, $2vjHu).bvh_ray_functions}\r\n\r\n\t\t\t\t// uniform structs\r\n\t\t\t\t${$sORjD.camera_struct}\r\n\t\t\t\t${$1QwjS.lights_struct}\r\n\t\t\t\t${$WBvYF.equirect_struct}\r\n\t\t\t\t${$1r4sY.material_struct}\r\n\t\t\t\t${$asLEI.surface_record_struct}\r\n\r\n\t\t\t\t// random\r\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\r\n\r\n\t\t\t\t\t${$gCBx4.stratified_functions}\r\n\r\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\r\n\r\n\t\t\t\t\t${$kmALz.pcg_functions}\r\n\t\t\t\t\t${$ffLvN.sobol_common}\r\n\t\t\t\t\t${$ffLvN.sobol_functions}\r\n\r\n\t\t\t\t\t#define rand(v) sobol(v)\r\n\t\t\t\t\t#define rand2(v) sobol2(v)\r\n\t\t\t\t\t#define rand3(v) sobol3(v)\r\n\t\t\t\t\t#define rand4(v) sobol4(v)\r\n\r\n\t\t\t\t#else \t\t\t\t\t// PCG\r\n\r\n\t\t\t\t${$kmALz.pcg_functions}\r\n\r\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\r\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\r\n\t\t\t\t\tuint sobolPixelIndex = 0u;\r\n\t\t\t\t\tuint sobolPathIndex = 0u;\r\n\t\t\t\t\tuint sobolBounceIndex = 0u;\r\n\r\n\t\t\t\t\t#define rand(v) pcgRand()\r\n\t\t\t\t\t#define rand2(v) pcgRand2()\r\n\t\t\t\t\t#define rand3(v) pcgRand3()\r\n\t\t\t\t\t#define rand4(v) pcgRand4()\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// common\r\n\t\t\t\t${$jpfro.texture_sample_functions}\r\n\t\t\t\t${$8KxWl.fresnel_functions}\r\n\t\t\t\t${$dUUQZ.util_functions}\r\n\t\t\t\t${$fYvb1.math_functions}\r\n\t\t\t\t${$d9skn.shape_intersection_functions}\r\n\r\n\t\t\t\t// environment\r\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\r\n\t\t\t\tuniform mat4 environmentRotation;\r\n\t\t\t\tuniform float environmentIntensity;\r\n\r\n\t\t\t\t// lighting\r\n\t\t\t\tuniform sampler2DArray iesProfiles;\r\n\t\t\t\tuniform LightsInfo lights;\r\n\r\n\t\t\t\t// background\r\n\t\t\t\tuniform float backgroundBlur;\r\n\t\t\t\tuniform float backgroundAlpha;\r\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\tuniform sampler2D backgroundMap;\r\n\t\t\t\tuniform mat4 backgroundRotation;\r\n\t\t\t\tuniform float backgroundIntensity;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// camera\r\n\t\t\t\tuniform mat4 cameraWorldMatrix;\r\n\t\t\t\tuniform mat4 invProjectionMatrix;\r\n\t\t\t\t#if FEATURE_DOF\r\n\r\n\t\t\t\tuniform PhysicalCamera physicalCamera;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// geometry\r\n\t\t\t\tuniform sampler2DArray attributesArray;\r\n\t\t\t\tuniform usampler2D materialIndexAttribute;\r\n\t\t\t\tuniform sampler2D materials;\r\n\t\t\t\tuniform sampler2DArray textures;\r\n\t\t\t\tuniform BVH bvh;\r\n\r\n\t\t\t\t// path tracer\r\n\t\t\t\tuniform int bounces;\r\n\t\t\t\tuniform int transmissiveBounces;\r\n\t\t\t\tuniform float filterGlossyFactor;\r\n\t\t\t\tuniform int seed;\r\n\r\n\t\t\t\t// image\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t// globals\r\n\t\t\t\tmat3 envRotation3x3;\r\n\t\t\t\tmat3 invEnvRotation3x3;\r\n\t\t\t\tfloat lightsDenom;\r\n\r\n\t\t\t\t// sampling\r\n\t\t\t\t${$cp6U0.shape_sampling_functions}\r\n\t\t\t\t${$6VF8W.equirect_functions}\r\n\t\t\t\t${$232IN.light_sampling_functions}\r\n\r\n\t\t\t\t${$hB5SN.inside_fog_volume_function}\r\n\t\t\t\t${$8keuf.ggx_functions}\r\n\t\t\t\t${$5SszG.sheen_functions}\r\n\t\t\t\t${$9kAYu.iridescence_functions}\r\n\t\t\t\t${$4GDCw.fog_functions}\r\n\t\t\t\t${$6voD8.bsdf_functions}\r\n\r\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\r\n\r\n\t\t\t\t\treturn clamp(\r\n\t\t\t\t\t\tmax(\r\n\t\t\t\t\t\t\troughness,\r\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\r\n\t\t\t\t\t\t0.0,\r\n\t\t\t\t\t\t1.0\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\r\n\r\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\r\n\r\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\r\n\t\t\t\t\treturn backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\r\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t${$ioRiK.render_structs}\r\n\t\t\t\t${$eJ3gD.camera_util_functions}\r\n\t\t\t\t${$euI5d.trace_scene_function}\r\n\t\t\t\t${$1zk7M.attenuate_hit_function}\r\n\t\t\t\t${$eZnIg.direct_light_contribution_function}\r\n\t\t\t\t${$bwtQK.get_surface_record_function}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t// init\r\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\r\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\r\n\t\t\t\t\tsobolPathIndex = uint( seed );\r\n\r\n\t\t\t\t\t// get camera ray\r\n\t\t\t\t\tRay ray = getCameraRay();\r\n\r\n\t\t\t\t\t// inverse environment rotation\r\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\r\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\r\n\t\t\t\t\tlightsDenom =\r\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\r\n\t\t\t\t\t\t\tfloat( lights.count ) :\r\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\r\n\r\n\t\t\t\t\t// final color\r\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\r\n\r\n\t\t\t\t\t// surface results\r\n\t\t\t\t\tSurfaceHit surfaceHit;\r\n\t\t\t\t\tScatterRecord scatterRec;\r\n\r\n\t\t\t\t\t// path tracing state\r\n\t\t\t\t\tRenderState state = initRenderState();\r\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\r\n\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\r\n\t\t\t\t\t\tray.origin, - ray.direction,\r\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\r\n\t\t\t\t\t\tstate.fogMaterial\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\r\n\r\n\t\t\t\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\t\t\t\tstate.depth ++;\r\n\t\t\t\t\t\tstate.traversals = bounces - i;\r\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\r\n\r\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\r\n\r\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\r\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\r\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\r\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\tLightRecord lightRec;\r\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\r\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\r\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\r\n\t\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the contribution\r\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\r\n\r\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\r\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\r\n\t\t\t\t\t\t\t\tvec3 envColor;\r\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\r\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\r\n\r\n\t\t\t\t\t\t\t\t// and weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\r\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\r\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\r\n\r\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\r\n\r\n\t\t\t\t\t\t\tstate.fogMaterial = material;\r\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// early out if this is a matte material\r\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\r\n\r\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\r\n\t\t\t\t\t\t// then skip it\r\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tSurfaceRecord surf;\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgetSurfaceRecord(\r\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\r\n\t\t\t\t\t\t\t\tsurf\r\n\t\t\t\t\t\t\t) == SKIP_SURFACE\r\n\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\r\n\t\t\t\t\t\t\t// crash the context with too long a loop.\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\r\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\r\n\r\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\r\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t// next event estimation\r\n\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\r\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\r\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\r\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\r\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// accumulate emissive color\r\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\r\n\r\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\r\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\r\n\t\t\t\t\t\t// perform this separate from a bounce\r\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\r\n\t\t\t\t\t\t\ti --;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// handle throughput color transformation\r\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\r\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\r\n\r\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\r\n\r\n\t\t\t\t\t\t// russian roulette path termination\r\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\r\n\t\t\t\t\t\tuint minBounces = 3u;\r\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\r\n\r\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\r\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\r\n\t\t\t\t\t\trrProb = sqrt( rrProb );\r\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\r\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\r\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\r\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\r\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\r\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// prepare for next ray\r\n\t\t\t\t\t\tray.direction = scatterRec.direction;\r\n\t\t\t\t\t\tray.origin = hitPoint;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t\t#if DEBUG_MODE == 1\r\n\r\n\t\t\t\t\t// output the number of rays checked in the path and number of\r\n\t\t\t\t\t// transmissive rays encountered.\r\n\t\t\t\t\tgl_FragColor.rgb = vec3(\r\n\t\t\t\t\t\tfloat( state.depth ),\r\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\r\n\t\t\t\t\t\t0.0\r\n\t\t\t\t\t);\r\n\t\t\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\n        });\n        this.setValues(parameters);\n    }\n}\n\n});\nparcelRegister(\"iyhQ7\", function(module, exports) {\n\n$parcel$export(module.exports, \"PhysicalCameraUniform\", () => $d8193d8a8d6141d1$export$2e27c77dea3c9d73);\n\nvar $kLfIo = parcelRequire(\"kLfIo\");\nclass $d8193d8a8d6141d1$export$2e27c77dea3c9d73 {\n    constructor(){\n        this.bokehSize = 0;\n        this.apertureBlades = 0;\n        this.apertureRotation = 0;\n        this.focusDistance = 10;\n        this.anamorphicRatio = 1;\n    }\n    updateFrom(camera) {\n        if (camera instanceof (0, $kLfIo.PhysicalCamera)) {\n            this.bokehSize = camera.bokehSize;\n            this.apertureBlades = camera.apertureBlades;\n            this.apertureRotation = camera.apertureRotation;\n            this.focusDistance = camera.focusDistance;\n            this.anamorphicRatio = camera.anamorphicRatio;\n        } else {\n            this.bokehSize = 0;\n            this.apertureRotation = 0;\n            this.apertureBlades = 0;\n            this.focusDistance = 10;\n            this.anamorphicRatio = 1;\n        }\n    }\n}\n\n});\nparcelRegister(\"kLfIo\", function(module, exports) {\n\n$parcel$export(module.exports, \"PhysicalCamera\", () => $f1d46319b05d893e$export$baf85f88dacad6d5);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $f1d46319b05d893e$export$baf85f88dacad6d5 extends (0, $ilwiq.PerspectiveCamera) {\n    set bokehSize(size) {\n        this.fStop = this.getFocalLength() / size;\n    }\n    get bokehSize() {\n        return this.getFocalLength() / this.fStop;\n    }\n    constructor(...args){\n        super(...args);\n        this.fStop = 1.4;\n        this.apertureBlades = 0;\n        this.apertureRotation = 0;\n        this.focusDistance = 25;\n        this.anamorphicRatio = 1;\n    }\n    copy(source, recursive) {\n        super.copy(source, recursive);\n        this.fStop = source.fStop;\n        this.apertureBlades = source.apertureBlades;\n        this.apertureRotation = source.apertureRotation;\n        this.focusDistance = source.focusDistance;\n        this.anamorphicRatio = source.anamorphicRatio;\n        return this;\n    }\n}\n\n});\n\n\nparcelRegister(\"kAJM1\", function(module, exports) {\n\n$parcel$export(module.exports, \"EquirectHdrInfoUniform\", () => $efdaad16b8cd905b$export$e5a77e5d6a85a862);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $2vGrm = parcelRequire(\"2vGrm\");\nfunction $efdaad16b8cd905b$var$binarySearchFindClosestIndexOf(array, targetValue, offset = 0, count = array.length) {\n    let lower = offset;\n    let upper = offset + count - 1;\n    while(lower < upper){\n        // calculate the midpoint for this iteration using a bitwise shift right operator to save 1 floating point multiplication\n        // and 1 truncation from the double tilde operator to improve performance\n        // this results in much better performance over using standard \"~ ~ ( (lower + upper) ) / 2\" to calculate the midpoint\n        const mid = lower + upper >> 1;\n        // check if the middle array value is above or below the target and shift\n        // which half of the array we're looking at\n        if (array[mid] < targetValue) lower = mid + 1;\n        else upper = mid;\n    }\n    return lower - offset;\n}\nfunction $efdaad16b8cd905b$var$colorToLuminance(r, g, b) {\n    // https://en.wikipedia.org/wiki/Relative_luminance\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n// ensures the data is all floating point values and flipY is false\nfunction $efdaad16b8cd905b$var$preprocessEnvMap(envMap, targetType = (0, $ilwiq.HalfFloatType)) {\n    const map = envMap.clone();\n    map.source = new (0, $ilwiq.Source)({\n        ...map.image\n    });\n    const { width: width, height: height, data: data } = map.image;\n    // TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n    // convert the data from half float uint 16 arrays to float arrays for cdf computation\n    let newData = data;\n    if (map.type !== targetType) {\n        if (targetType === (0, $ilwiq.HalfFloatType)) newData = new Uint16Array(data.length);\n        else newData = new Float32Array(data.length);\n        let maxIntValue;\n        if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array) maxIntValue = 2 ** (8 * data.BYTES_PER_ELEMENT - 1) - 1;\n        else maxIntValue = 2 ** (8 * data.BYTES_PER_ELEMENT) - 1;\n        for(let i = 0, l = data.length; i < l; i++){\n            let v = data[i];\n            if (map.type === (0, $ilwiq.HalfFloatType)) v = (0, $ilwiq.DataUtils).fromHalfFloat(data[i]);\n            if (map.type !== (0, $ilwiq.FloatType) && map.type !== (0, $ilwiq.HalfFloatType)) v /= maxIntValue;\n            if (targetType === (0, $ilwiq.HalfFloatType)) newData[i] = (0, $ilwiq.DataUtils).toHalfFloat(v);\n        }\n        map.image.data = newData;\n        map.type = targetType;\n    }\n    // remove any y flipping for cdf computation\n    if (map.flipY) {\n        const ogData = newData;\n        newData = newData.slice();\n        for(let y = 0; y < height; y++)for(let x = 0; x < width; x++){\n            const newY = height - y - 1;\n            const ogIndex = 4 * (y * width + x);\n            const newIndex = 4 * (newY * width + x);\n            newData[newIndex + 0] = ogData[ogIndex + 0];\n            newData[newIndex + 1] = ogData[ogIndex + 1];\n            newData[newIndex + 2] = ogData[ogIndex + 2];\n            newData[newIndex + 3] = ogData[ogIndex + 3];\n        }\n        map.flipY = false;\n        map.image.data = newData;\n    }\n    return map;\n}\nclass $efdaad16b8cd905b$export$e5a77e5d6a85a862 {\n    constructor(){\n        // Default to a white texture and associated weights so we don't\n        // just render black initially.\n        const blackTex = new (0, $ilwiq.DataTexture)((0, $2vGrm.toHalfFloatArray)(new Float32Array([\n            0,\n            0,\n            0,\n            0\n        ])), 1, 1);\n        blackTex.type = (0, $ilwiq.HalfFloatType);\n        blackTex.format = (0, $ilwiq.RGBAFormat);\n        blackTex.minFilter = (0, $ilwiq.LinearFilter);\n        blackTex.magFilter = (0, $ilwiq.LinearFilter);\n        blackTex.wrapS = (0, $ilwiq.RepeatWrapping);\n        blackTex.wrapT = (0, $ilwiq.RepeatWrapping);\n        blackTex.generateMipmaps = false;\n        blackTex.needsUpdate = true;\n        // Stores a map of [0, 1] value -> cumulative importance row & pdf\n        // used to sampling a random value to a relevant row to sample from\n        const marginalWeights = new (0, $ilwiq.DataTexture)((0, $2vGrm.toHalfFloatArray)(new Float32Array([\n            0,\n            1\n        ])), 1, 2);\n        marginalWeights.type = (0, $ilwiq.HalfFloatType);\n        marginalWeights.format = (0, $ilwiq.RedFormat);\n        marginalWeights.minFilter = (0, $ilwiq.LinearFilter);\n        marginalWeights.magFilter = (0, $ilwiq.LinearFilter);\n        marginalWeights.generateMipmaps = false;\n        marginalWeights.needsUpdate = true;\n        // Stores a map of [0, 1] value -> cumulative importance column & pdf\n        // used to sampling a random value to a relevant pixel to sample from\n        const conditionalWeights = new (0, $ilwiq.DataTexture)((0, $2vGrm.toHalfFloatArray)(new Float32Array([\n            0,\n            0,\n            1,\n            1\n        ])), 2, 2);\n        conditionalWeights.type = (0, $ilwiq.HalfFloatType);\n        conditionalWeights.format = (0, $ilwiq.RedFormat);\n        conditionalWeights.minFilter = (0, $ilwiq.LinearFilter);\n        conditionalWeights.magFilter = (0, $ilwiq.LinearFilter);\n        conditionalWeights.generateMipmaps = false;\n        conditionalWeights.needsUpdate = true;\n        this.map = blackTex;\n        this.marginalWeights = marginalWeights;\n        this.conditionalWeights = conditionalWeights;\n        this.totalSum = 0;\n    // TODO: Add support for float or half float types here. We need to pass this into\n    // the preprocess function and ensure our CDF and MDF textures are appropriately sized\n    // Ideally we wouldn't upscale a bit depth if we didn't need to.\n    // this.type = HalfFloatType;\n    }\n    dispose() {\n        this.marginalWeights.dispose();\n        this.conditionalWeights.dispose();\n        this.map.dispose();\n    }\n    updateFrom(hdr) {\n        // https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n        // https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n        const map = $efdaad16b8cd905b$var$preprocessEnvMap(hdr);\n        map.wrapS = (0, $ilwiq.RepeatWrapping);\n        map.wrapT = (0, $ilwiq.ClampToEdgeWrapping);\n        const { width: width, height: height, data: data } = map.image;\n        // \"conditional\" = \"pixel relative to row pixels sum\"\n        // \"marginal\" = \"row relative to row sum\"\n        // track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n        const pdfConditional = new Float32Array(width * height);\n        const cdfConditional = new Float32Array(width * height);\n        const pdfMarginal = new Float32Array(height);\n        const cdfMarginal = new Float32Array(height);\n        let totalSumValue = 0.0;\n        let cumulativeWeightMarginal = 0.0;\n        for(let y = 0; y < height; y++){\n            let cumulativeRowWeight = 0.0;\n            for(let x = 0; x < width; x++){\n                const i = y * width + x;\n                const r = (0, $ilwiq.DataUtils).fromHalfFloat(data[4 * i + 0]);\n                const g = (0, $ilwiq.DataUtils).fromHalfFloat(data[4 * i + 1]);\n                const b = (0, $ilwiq.DataUtils).fromHalfFloat(data[4 * i + 2]);\n                // the probability of the pixel being selected in this row is the\n                // scale of the luminance relative to the rest of the pixels.\n                // TODO: this should also account for the solid angle of the pixel when sampling\n                const weight = $efdaad16b8cd905b$var$colorToLuminance(r, g, b);\n                cumulativeRowWeight += weight;\n                totalSumValue += weight;\n                pdfConditional[i] = weight;\n                cdfConditional[i] = cumulativeRowWeight;\n            }\n            // can happen if the row is all black\n            if (cumulativeRowWeight !== 0) // scale the pdf and cdf to [0.0, 1.0]\n            for(let i = y * width, l = y * width + width; i < l; i++){\n                pdfConditional[i] /= cumulativeRowWeight;\n                cdfConditional[i] /= cumulativeRowWeight;\n            }\n            cumulativeWeightMarginal += cumulativeRowWeight;\n            // compute the marginal pdf and cdf along the height of the map.\n            pdfMarginal[y] = cumulativeRowWeight;\n            cdfMarginal[y] = cumulativeWeightMarginal;\n        }\n        // can happen if the texture is all black\n        if (cumulativeWeightMarginal !== 0) // scale the marginal pdf and cdf to [0.0, 1.0]\n        for(let i = 0, l = pdfMarginal.length; i < l; i++){\n            pdfMarginal[i] /= cumulativeWeightMarginal;\n            cdfMarginal[i] /= cumulativeWeightMarginal;\n        }\n        // compute a sorted index of distributions and the probabilities along them for both\n        // the marginal and conditional data. These will be used to sample with a random number\n        // to retrieve a uv value to sample in the environment map.\n        // These values continually increase so it's okay to interpolate between them.\n        const marginalDataArray = new Uint16Array(height);\n        const conditionalDataArray = new Uint16Array(width * height);\n        // we add a half texel offset so we're sampling the center of the pixel\n        for(let i = 0; i < height; i++){\n            const dist = (i + 1) / height;\n            const row = $efdaad16b8cd905b$var$binarySearchFindClosestIndexOf(cdfMarginal, dist);\n            marginalDataArray[i] = (0, $ilwiq.DataUtils).toHalfFloat((row + 0.5) / height);\n        }\n        for(let y = 0; y < height; y++)for(let x = 0; x < width; x++){\n            const i = y * width + x;\n            const dist = (x + 1) / width;\n            const col = $efdaad16b8cd905b$var$binarySearchFindClosestIndexOf(cdfConditional, dist, y * width, width);\n            conditionalDataArray[i] = (0, $ilwiq.DataUtils).toHalfFloat((col + 0.5) / width);\n        }\n        this.dispose();\n        const { marginalWeights: marginalWeights, conditionalWeights: conditionalWeights } = this;\n        marginalWeights.image = {\n            width: height,\n            height: 1,\n            data: marginalDataArray\n        };\n        marginalWeights.needsUpdate = true;\n        conditionalWeights.image = {\n            width: width,\n            height: height,\n            data: conditionalDataArray\n        };\n        conditionalWeights.needsUpdate = true;\n        this.totalSum = totalSumValue;\n        this.map = map;\n    }\n}\n\n});\nparcelRegister(\"2vGrm\", function(module, exports) {\n\n$parcel$export(module.exports, \"toHalfFloatArray\", () => $1d3f65c6c5f4f52a$export$8090c803d9d233c2);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $1d3f65c6c5f4f52a$export$8090c803d9d233c2(f32Array) {\n    const f16Array = new Uint16Array(f32Array.length);\n    for(let i = 0, n = f32Array.length; i < n; ++i)f16Array[i] = (0, $ilwiq.DataUtils).toHalfFloat(f32Array[i]);\n    return f16Array;\n}\n\n});\n\n\nparcelRegister(\"TWVPU\", function(module, exports) {\n\n$parcel$export(module.exports, \"LightsInfoUniformStruct\", () => $0a82d9ce12cf98b8$export$bb02c0eb15767758);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6ply6 = parcelRequire(\"6ply6\");\nconst $0a82d9ce12cf98b8$var$LIGHT_PIXELS = 6;\nconst $0a82d9ce12cf98b8$var$RECT_AREA_LIGHT = 0;\nconst $0a82d9ce12cf98b8$var$CIRC_AREA_LIGHT = 1;\nconst $0a82d9ce12cf98b8$var$SPOT_LIGHT = 2;\nconst $0a82d9ce12cf98b8$var$DIR_LIGHT = 3;\nconst $0a82d9ce12cf98b8$var$POINT_LIGHT = 4;\nconst $0a82d9ce12cf98b8$var$u = new (0, $ilwiq.Vector3)();\nconst $0a82d9ce12cf98b8$var$v = new (0, $ilwiq.Vector3)();\nconst $0a82d9ce12cf98b8$var$m = new (0, $ilwiq.Matrix4)();\nconst $0a82d9ce12cf98b8$var$worldQuaternion = new (0, $ilwiq.Quaternion)();\nconst $0a82d9ce12cf98b8$var$eye = new (0, $ilwiq.Vector3)();\nconst $0a82d9ce12cf98b8$var$target = new (0, $ilwiq.Vector3)();\nconst $0a82d9ce12cf98b8$var$up = new (0, $ilwiq.Vector3)(0, 1, 0);\nclass $0a82d9ce12cf98b8$export$bb02c0eb15767758 {\n    constructor(){\n        const tex = new (0, $ilwiq.DataTexture)(new Float32Array(4), 1, 1);\n        tex.format = (0, $ilwiq.RGBAFormat);\n        tex.type = (0, $ilwiq.FloatType);\n        tex.wrapS = (0, $ilwiq.ClampToEdgeWrapping);\n        tex.wrapT = (0, $ilwiq.ClampToEdgeWrapping);\n        tex.generateMipmaps = false;\n        tex.minFilter = (0, $ilwiq.NearestFilter);\n        tex.magFilter = (0, $ilwiq.NearestFilter);\n        this.tex = tex;\n        this.count = 0;\n    }\n    updateFrom(lights, iesTextures = []) {\n        const tex = this.tex;\n        const pixelCount = Math.max(lights.length * $0a82d9ce12cf98b8$var$LIGHT_PIXELS, 1);\n        const dimension = Math.ceil(Math.sqrt(pixelCount));\n        if (tex.image.width !== dimension) {\n            tex.dispose();\n            tex.image.data = new Float32Array(dimension * dimension * 4);\n            tex.image.width = dimension;\n            tex.image.height = dimension;\n        }\n        const floatArray = tex.image.data;\n        for(let i = 0, l = lights.length; i < l; i++){\n            const l = lights[i];\n            const baseIndex = i * $0a82d9ce12cf98b8$var$LIGHT_PIXELS * 4;\n            let index = 0;\n            // initialize to 0\n            for(let p = 0; p < $0a82d9ce12cf98b8$var$LIGHT_PIXELS * 4; p++)floatArray[baseIndex + p] = 0;\n            // sample 1\n            // position\n            l.getWorldPosition($0a82d9ce12cf98b8$var$v);\n            floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.x;\n            floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.y;\n            floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.z;\n            // type\n            let type = $0a82d9ce12cf98b8$var$RECT_AREA_LIGHT;\n            if (l.isRectAreaLight && l.isCircular) type = $0a82d9ce12cf98b8$var$CIRC_AREA_LIGHT;\n            else if (l.isSpotLight) type = $0a82d9ce12cf98b8$var$SPOT_LIGHT;\n            else if (l.isDirectionalLight) type = $0a82d9ce12cf98b8$var$DIR_LIGHT;\n            else if (l.isPointLight) type = $0a82d9ce12cf98b8$var$POINT_LIGHT;\n            floatArray[baseIndex + index++] = type;\n            // sample 2\n            // color\n            floatArray[baseIndex + index++] = l.color.r;\n            floatArray[baseIndex + index++] = l.color.g;\n            floatArray[baseIndex + index++] = l.color.b;\n            // intensity\n            floatArray[baseIndex + index++] = l.intensity;\n            l.getWorldQuaternion($0a82d9ce12cf98b8$var$worldQuaternion);\n            if (l.isRectAreaLight) {\n                // sample 3\n                // u vector\n                $0a82d9ce12cf98b8$var$u.set(l.width, 0, 0).applyQuaternion($0a82d9ce12cf98b8$var$worldQuaternion);\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.x;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.y;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.z;\n                index++;\n                // sample 4\n                // v vector\n                $0a82d9ce12cf98b8$var$v.set(0, l.height, 0).applyQuaternion($0a82d9ce12cf98b8$var$worldQuaternion);\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.x;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.y;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.z;\n                // area\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.cross($0a82d9ce12cf98b8$var$v).length() * (l.isCircular ? Math.PI / 4.0 : 1.0);\n            } else if (l.isSpotLight) {\n                const radius = l.radius || 0;\n                $0a82d9ce12cf98b8$var$eye.setFromMatrixPosition(l.matrixWorld);\n                $0a82d9ce12cf98b8$var$target.setFromMatrixPosition(l.target.matrixWorld);\n                $0a82d9ce12cf98b8$var$m.lookAt($0a82d9ce12cf98b8$var$eye, $0a82d9ce12cf98b8$var$target, $0a82d9ce12cf98b8$var$up);\n                $0a82d9ce12cf98b8$var$worldQuaternion.setFromRotationMatrix($0a82d9ce12cf98b8$var$m);\n                // sample 3\n                // u vector\n                $0a82d9ce12cf98b8$var$u.set(1, 0, 0).applyQuaternion($0a82d9ce12cf98b8$var$worldQuaternion);\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.x;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.y;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$u.z;\n                index++;\n                // sample 4\n                // v vector\n                $0a82d9ce12cf98b8$var$v.set(0, 1, 0).applyQuaternion($0a82d9ce12cf98b8$var$worldQuaternion);\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.x;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.y;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$v.z;\n                // area\n                floatArray[baseIndex + index++] = Math.PI * radius * radius;\n                // sample 5\n                // radius\n                floatArray[baseIndex + index++] = radius;\n                // decay\n                floatArray[baseIndex + index++] = l.decay;\n                // distance\n                floatArray[baseIndex + index++] = l.distance;\n                // coneCos\n                floatArray[baseIndex + index++] = Math.cos(l.angle);\n                // sample 6\n                // penumbraCos\n                floatArray[baseIndex + index++] = Math.cos(l.angle * (1 - l.penumbra));\n                // iesProfile\n                floatArray[baseIndex + index++] = l.iesMap ? iesTextures.indexOf(l.iesMap) : -1;\n            } else if (l.isPointLight) {\n                const worldPosition = $0a82d9ce12cf98b8$var$u.setFromMatrixPosition(l.matrixWorld);\n                // sample 3\n                // u vector\n                floatArray[baseIndex + index++] = worldPosition.x;\n                floatArray[baseIndex + index++] = worldPosition.y;\n                floatArray[baseIndex + index++] = worldPosition.z;\n                index++;\n                // sample 4\n                index += 4;\n                // sample 5\n                index += 1;\n                floatArray[baseIndex + index++] = l.decay;\n                floatArray[baseIndex + index++] = l.distance;\n            } else if (l.isDirectionalLight) {\n                const worldPosition = $0a82d9ce12cf98b8$var$u.setFromMatrixPosition(l.matrixWorld);\n                const targetPosition = $0a82d9ce12cf98b8$var$v.setFromMatrixPosition(l.target.matrixWorld);\n                $0a82d9ce12cf98b8$var$target.subVectors(worldPosition, targetPosition).normalize();\n                // sample 3\n                // u vector\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$target.x;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$target.y;\n                floatArray[baseIndex + index++] = $0a82d9ce12cf98b8$var$target.z;\n            }\n        }\n        this.count = lights.length;\n        const hash = (0, $6ply6.bufferToHash)(floatArray.buffer);\n        if (this.hash !== hash) {\n            this.hash = hash;\n            tex.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"6Q19u\", function(module, exports) {\n\n$parcel$export(module.exports, \"AttributesTextureArray\", () => $4fa87e2831d7f36b$export$2e089d4ee1364df8);\n\nvar $7Ie7O = parcelRequire(\"7Ie7O\");\nclass $4fa87e2831d7f36b$export$2e089d4ee1364df8 extends (0, $7Ie7O.FloatAttributeTextureArray) {\n    updateNormalAttribute(attr) {\n        this.updateAttribute(0, attr);\n    }\n    updateTangentAttribute(attr) {\n        this.updateAttribute(1, attr);\n    }\n    updateUvAttribute(attr) {\n        this.updateAttribute(2, attr);\n    }\n    updateColorAttribute(attr) {\n        this.updateAttribute(3, attr);\n    }\n    updateFrom(normal, tangent, uv, color) {\n        this.setAttributes([\n            normal,\n            tangent,\n            uv,\n            color\n        ]);\n    }\n}\n\n});\nparcelRegister(\"7Ie7O\", function(module, exports) {\n\n$parcel$export(module.exports, \"FloatAttributeTextureArray\", () => $59d79964e8fc761c$export$74918e5550c6edfc);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $hN8zD = parcelRequire(\"hN8zD\");\nfunction $59d79964e8fc761c$var$copyArrayToArray(fromArray, fromStride, toArray, toStride, offset) {\n    if (fromStride > toStride) throw new Error();\n    // scale non-float values to their normalized range\n    const count = fromArray.length / fromStride;\n    const bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\n    let maxValue = 1.0;\n    switch(fromArray.constructor){\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n            maxValue = 2 ** bpe - 1;\n            break;\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n            maxValue = 2 ** (bpe - 1) - 1;\n            break;\n    }\n    for(let i = 0; i < count; i++){\n        const i4 = 4 * i;\n        const is = fromStride * i;\n        for(let j = 0; j < toStride; j++)toArray[offset + i4 + j] = fromStride >= j + 1 ? fromArray[is + j] / maxValue : 0;\n    }\n}\nclass $59d79964e8fc761c$export$74918e5550c6edfc extends (0, $ilwiq.DataArrayTexture) {\n    constructor(){\n        super();\n        this._textures = [];\n        this.type = (0, $ilwiq.FloatType);\n        this.format = (0, $ilwiq.RGBAFormat);\n        this.internalFormat = \"RGBA32F\";\n    }\n    updateAttribute(index, attr) {\n        // update the texture\n        const tex = this._textures[index];\n        tex.updateFrom(attr);\n        // ensure compatibility\n        const baseImage = tex.image;\n        const image = this.image;\n        if (baseImage.width !== image.width || baseImage.height !== image.height) throw new Error(\"FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.\");\n        // update the image\n        const { width: width, height: height, data: data } = image;\n        const length = width * height * 4;\n        const offset = length * index;\n        let itemSize = attr.itemSize;\n        if (itemSize === 3) itemSize = 4;\n        // copy the data\n        $59d79964e8fc761c$var$copyArrayToArray(tex.image.data, itemSize, data, 4, offset);\n        this.dispose();\n        this.needsUpdate = true;\n    }\n    setAttributes(attrs) {\n        // ensure the attribute count\n        const itemCount = attrs[0].count;\n        const attrsLength = attrs.length;\n        for(let i = 0, l = attrsLength; i < l; i++){\n            if (attrs[i].count !== itemCount) throw new Error(\"FloatAttributeTextureArray: All attributes must have the same item count.\");\n        }\n        // initialize all textures\n        const textures = this._textures;\n        while(textures.length < attrsLength){\n            const tex = new (0, $hN8zD.FloatVertexAttributeTexture)();\n            textures.push(tex);\n        }\n        while(textures.length > attrsLength)textures.pop();\n        // update all textures\n        for(let i = 0, l = attrsLength; i < l; i++)textures[i].updateFrom(attrs[i]);\n        // determine if we need to create a new array\n        const baseTexture = textures[0];\n        const baseImage = baseTexture.image;\n        const image = this.image;\n        if (baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength) {\n            image.width = baseImage.width;\n            image.height = baseImage.height;\n            image.depth = attrsLength;\n            image.data = new Float32Array(image.width * image.height * image.depth * 4);\n        }\n        // copy the other texture data into the data array texture\n        const { data: data, width: width, height: height } = image;\n        for(let i = 0, l = attrsLength; i < l; i++){\n            const tex = textures[i];\n            const length = width * height * 4;\n            const offset = length * i;\n            let itemSize = attrs[i].itemSize;\n            if (itemSize === 3) itemSize = 4;\n            $59d79964e8fc761c$var$copyArrayToArray(tex.image.data, itemSize, data, 4, offset);\n        }\n        // reset the texture\n        this.dispose();\n        this.needsUpdate = true;\n    }\n}\n\n});\n\n\nparcelRegister(\"laA5G\", function(module, exports) {\n\n$parcel$export(module.exports, \"MATERIAL_PIXELS\", () => $f69686fae5159582$export$c4a81a0bfb84e9fe);\n$parcel$export(module.exports, \"MaterialsTexture\", () => $f69686fae5159582$export$ae96f3619813ce17);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9wqOU = parcelRequire(\"9wqOU\");\n\nvar $6ply6 = parcelRequire(\"6ply6\");\nconst $f69686fae5159582$export$c4a81a0bfb84e9fe = 47;\nconst $f69686fae5159582$var$MATERIAL_STRIDE = $f69686fae5159582$export$c4a81a0bfb84e9fe * 4;\nclass $f69686fae5159582$var$MaterialFeatures {\n    constructor(){\n        this._features = {};\n    }\n    isUsed(feature) {\n        return feature in this._features;\n    }\n    setUsed(feature, used = true) {\n        if (used === false) delete this._features[feature];\n        else this._features[feature] = true;\n    }\n    reset() {\n        this._features = {};\n    }\n}\nclass $f69686fae5159582$export$ae96f3619813ce17 extends (0, $ilwiq.DataTexture) {\n    constructor(){\n        super(new Float32Array(4), 1, 1);\n        this.format = (0, $ilwiq.RGBAFormat);\n        this.type = (0, $ilwiq.FloatType);\n        this.wrapS = (0, $ilwiq.ClampToEdgeWrapping);\n        this.wrapT = (0, $ilwiq.ClampToEdgeWrapping);\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.generateMipmaps = false;\n        this.features = new $f69686fae5159582$var$MaterialFeatures();\n    }\n    updateFrom(materials, textures) {\n        function getTexture(material, key, def = -1) {\n            if (key in material && material[key]) {\n                const hash = (0, $9wqOU.getTextureHash)(material[key]);\n                return textureLookUp[hash];\n            } else return def;\n        }\n        function getField(material, key, def) {\n            return key in material ? material[key] : def;\n        }\n        function writeTextureMatrixToArray(material, textureKey, array, offset) {\n            const texture = material[textureKey] && material[textureKey].isTexture ? material[textureKey] : null;\n            // check if texture exists\n            if (texture) {\n                if (texture.matrixAutoUpdate) texture.updateMatrix();\n                const elements = texture.matrix.elements;\n                let i = 0;\n                // first row\n                array[offset + i++] = elements[0];\n                array[offset + i++] = elements[3];\n                array[offset + i++] = elements[6];\n                i++;\n                // second row\n                array[offset + i++] = elements[1];\n                array[offset + i++] = elements[4];\n                array[offset + i++] = elements[7];\n                i++;\n            }\n            return 8;\n        }\n        let index = 0;\n        const pixelCount = materials.length * $f69686fae5159582$export$c4a81a0bfb84e9fe;\n        const dimension = Math.ceil(Math.sqrt(pixelCount)) || 1;\n        const { image: image, features: features } = this;\n        // index the list of textures based on shareable source\n        const textureLookUp = {};\n        for(let i = 0, l = textures.length; i < l; i++)textureLookUp[(0, $9wqOU.getTextureHash)(textures[i])] = i;\n        if (image.width !== dimension) {\n            this.dispose();\n            image.data = new Float32Array(dimension * dimension * 4);\n            image.width = dimension;\n            image.height = dimension;\n        }\n        const floatArray = image.data;\n        // on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n        // can't encode texture ids that way.\n        // const intArray = new Int32Array( floatArray.buffer );\n        features.reset();\n        for(let i = 0, l = materials.length; i < l; i++){\n            const m = materials[i];\n            if (m.isFogVolumeMaterial) {\n                features.setUsed(\"FOG\");\n                for(let j = 0; j < $f69686fae5159582$var$MATERIAL_STRIDE; j++)floatArray[index + j] = 0;\n                // sample 0 .rgb\n                floatArray[index + 0 + 0] = m.color.r;\n                floatArray[index + 0 + 1] = m.color.g;\n                floatArray[index + 0 + 2] = m.color.b;\n                // sample 2 .a\n                floatArray[index + 8 + 3] = getField(m, \"emissiveIntensity\", 0.0);\n                // sample 3 .rgb\n                floatArray[index + 12 + 0] = m.emissive.r;\n                floatArray[index + 12 + 1] = m.emissive.g;\n                floatArray[index + 12 + 2] = m.emissive.b;\n                // sample 13 .g\n                // reusing opacity field\n                floatArray[index + 52 + 1] = m.density;\n                // side\n                floatArray[index + 52 + 3] = 0.0;\n                // sample 14 .b\n                floatArray[index + 56 + 2] = 4;\n                index += $f69686fae5159582$var$MATERIAL_STRIDE;\n                continue;\n            }\n            // sample 0\n            // color\n            floatArray[index++] = m.color.r;\n            floatArray[index++] = m.color.g;\n            floatArray[index++] = m.color.b;\n            floatArray[index++] = getTexture(m, \"map\");\n            // sample 1\n            // metalness & roughness\n            floatArray[index++] = getField(m, \"metalness\", 0.0);\n            floatArray[index++] = getTexture(m, \"metalnessMap\");\n            floatArray[index++] = getField(m, \"roughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"roughnessMap\");\n            // sample 2\n            // transmission & emissiveIntensity\n            // three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n            floatArray[index++] = getField(m, \"ior\", 1.5);\n            floatArray[index++] = getField(m, \"transmission\", 0.0);\n            floatArray[index++] = getTexture(m, \"transmissionMap\");\n            floatArray[index++] = getField(m, \"emissiveIntensity\", 0.0);\n            // sample 3\n            // emission\n            if (\"emissive\" in m) {\n                floatArray[index++] = m.emissive.r;\n                floatArray[index++] = m.emissive.g;\n                floatArray[index++] = m.emissive.b;\n            } else {\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n            }\n            floatArray[index++] = getTexture(m, \"emissiveMap\");\n            // sample 4\n            // normals\n            floatArray[index++] = getTexture(m, \"normalMap\");\n            if (\"normalScale\" in m) {\n                floatArray[index++] = m.normalScale.x;\n                floatArray[index++] = m.normalScale.y;\n            } else {\n                floatArray[index++] = 1;\n                floatArray[index++] = 1;\n            }\n            // clearcoat\n            floatArray[index++] = getField(m, \"clearcoat\", 0.0);\n            floatArray[index++] = getTexture(m, \"clearcoatMap\"); // sample 5\n            floatArray[index++] = getField(m, \"clearcoatRoughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"clearcoatRoughnessMap\");\n            floatArray[index++] = getTexture(m, \"clearcoatNormalMap\");\n            // sample 6\n            if (\"clearcoatNormalScale\" in m) {\n                floatArray[index++] = m.clearcoatNormalScale.x;\n                floatArray[index++] = m.clearcoatNormalScale.y;\n            } else {\n                floatArray[index++] = 1;\n                floatArray[index++] = 1;\n            }\n            index++;\n            floatArray[index++] = getField(m, \"sheen\", 0.0);\n            // sample 7\n            // sheen\n            if (\"sheenColor\" in m) {\n                floatArray[index++] = m.sheenColor.r;\n                floatArray[index++] = m.sheenColor.g;\n                floatArray[index++] = m.sheenColor.b;\n            } else {\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n                floatArray[index++] = 0.0;\n            }\n            floatArray[index++] = getTexture(m, \"sheenColorMap\");\n            // sample 8\n            floatArray[index++] = getField(m, \"sheenRoughness\", 0.0);\n            floatArray[index++] = getTexture(m, \"sheenRoughnessMap\");\n            // iridescence\n            floatArray[index++] = getTexture(m, \"iridescenceMap\");\n            floatArray[index++] = getTexture(m, \"iridescenceThicknessMap\");\n            // sample 9\n            floatArray[index++] = getField(m, \"iridescence\", 0.0);\n            floatArray[index++] = getField(m, \"iridescenceIOR\", 1.3);\n            const iridescenceThicknessRange = getField(m, \"iridescenceThicknessRange\", [\n                100,\n                400\n            ]);\n            floatArray[index++] = iridescenceThicknessRange[0];\n            floatArray[index++] = iridescenceThicknessRange[1];\n            // sample 10\n            // specular color\n            if (\"specularColor\" in m) {\n                floatArray[index++] = m.specularColor.r;\n                floatArray[index++] = m.specularColor.g;\n                floatArray[index++] = m.specularColor.b;\n            } else {\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n            }\n            floatArray[index++] = getTexture(m, \"specularColorMap\");\n            // sample 11\n            // specular intensity\n            floatArray[index++] = getField(m, \"specularIntensity\", 1.0);\n            floatArray[index++] = getTexture(m, \"specularIntensityMap\");\n            // isThinFilm\n            const isThinFilm = getField(m, \"thickness\", 0.0) === 0.0 && getField(m, \"attenuationDistance\", Infinity) === Infinity;\n            floatArray[index++] = Number(isThinFilm);\n            index++;\n            // sample 12\n            if (\"attenuationColor\" in m) {\n                floatArray[index++] = m.attenuationColor.r;\n                floatArray[index++] = m.attenuationColor.g;\n                floatArray[index++] = m.attenuationColor.b;\n            } else {\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n                floatArray[index++] = 1.0;\n            }\n            floatArray[index++] = getField(m, \"attenuationDistance\", Infinity);\n            // sample 13\n            // alphaMap\n            floatArray[index++] = getTexture(m, \"alphaMap\");\n            // side & matte\n            floatArray[index++] = m.opacity;\n            floatArray[index++] = m.alphaTest;\n            if (!isThinFilm && m.transmission > 0.0) floatArray[index++] = 0;\n            else switch(m.side){\n                case 0, $ilwiq.FrontSide:\n                    floatArray[index++] = 1;\n                    break;\n                case 0, $ilwiq.BackSide:\n                    floatArray[index++] = -1;\n                    break;\n                case 0, $ilwiq.DoubleSide:\n                    floatArray[index++] = 0;\n                    break;\n            }\n            // sample 14\n            floatArray[index++] = Number(getField(m, \"matte\", false)); // matte\n            floatArray[index++] = Number(getField(m, \"castShadow\", true)); // shadow\n            floatArray[index++] = Number(m.vertexColors) | Number(m.flatShading) << 1; // vertexColors & flatShading\n            floatArray[index++] = Number(m.transparent); // transparent\n            // map transform 15\n            index += writeTextureMatrixToArray(m, \"map\", floatArray, index);\n            // metalnessMap transform 17\n            index += writeTextureMatrixToArray(m, \"metalnessMap\", floatArray, index);\n            // roughnessMap transform 19\n            index += writeTextureMatrixToArray(m, \"roughnessMap\", floatArray, index);\n            // transmissionMap transform 21\n            index += writeTextureMatrixToArray(m, \"transmissionMap\", floatArray, index);\n            // emissiveMap transform 22\n            index += writeTextureMatrixToArray(m, \"emissiveMap\", floatArray, index);\n            // normalMap transform 25\n            index += writeTextureMatrixToArray(m, \"normalMap\", floatArray, index);\n            // clearcoatMap transform 27\n            index += writeTextureMatrixToArray(m, \"clearcoatMap\", floatArray, index);\n            // clearcoatNormalMap transform 29\n            index += writeTextureMatrixToArray(m, \"clearcoatNormalMap\", floatArray, index);\n            // clearcoatRoughnessMap transform 31\n            index += writeTextureMatrixToArray(m, \"clearcoatRoughnessMap\", floatArray, index);\n            // sheenColorMap transform 33\n            index += writeTextureMatrixToArray(m, \"sheenColorMap\", floatArray, index);\n            // sheenRoughnessMap transform 35\n            index += writeTextureMatrixToArray(m, \"sheenRoughnessMap\", floatArray, index);\n            // iridescenceMap transform 37\n            index += writeTextureMatrixToArray(m, \"iridescenceMap\", floatArray, index);\n            // iridescenceThicknessMap transform 39\n            index += writeTextureMatrixToArray(m, \"iridescenceThicknessMap\", floatArray, index);\n            // specularColorMap transform 41\n            index += writeTextureMatrixToArray(m, \"specularColorMap\", floatArray, index);\n            // specularIntensityMap transform 43\n            index += writeTextureMatrixToArray(m, \"specularIntensityMap\", floatArray, index);\n            // alphaMap transform 45\n            index += writeTextureMatrixToArray(m, \"alphaMap\", floatArray, index);\n        }\n        // check if the contents have changed\n        const hash = (0, $6ply6.bufferToHash)(floatArray.buffer);\n        if (this.hash !== hash) {\n            this.hash = hash;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\nparcelRegister(\"9wqOU\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTextureHash\", () => $6eebe81d767f0e44$export$62c3d260e4e2abca);\n$parcel$export(module.exports, \"getIesTextures\", () => $6eebe81d767f0e44$export$b22c535c66112848);\n$parcel$export(module.exports, \"getTextures\", () => $6eebe81d767f0e44$export$560c941db545ef55);\n$parcel$export(module.exports, \"getLights\", () => $6eebe81d767f0e44$export$3ae1ccb94aa877f9);\nfunction $6eebe81d767f0e44$var$uuidSort(a, b) {\n    if (a.uuid < b.uuid) return 1;\n    if (a.uuid > b.uuid) return -1;\n    return 0;\n}\nfunction $6eebe81d767f0e44$export$62c3d260e4e2abca(t) {\n    return `${t.source.uuid}:${t.colorSpace}`;\n}\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nfunction $6eebe81d767f0e44$var$reduceTexturesToUniqueSources(textures) {\n    const sourceSet = new Set();\n    const result = [];\n    for(let i = 0, l = textures.length; i < l; i++){\n        const tex = textures[i];\n        const hash = $6eebe81d767f0e44$export$62c3d260e4e2abca(tex);\n        if (!sourceSet.has(hash)) {\n            sourceSet.add(hash);\n            result.push(tex);\n        }\n    }\n    return result;\n}\nfunction $6eebe81d767f0e44$export$b22c535c66112848(lights) {\n    const textures = lights.map((l)=>l.iesMap || null).filter((t)=>t);\n    const textureSet = new Set(textures);\n    return Array.from(textureSet).sort($6eebe81d767f0e44$var$uuidSort);\n}\nfunction $6eebe81d767f0e44$export$560c941db545ef55(materials) {\n    const textureSet = new Set();\n    for(let i = 0, l = materials.length; i < l; i++){\n        const material = materials[i];\n        for(const key in material){\n            const value = material[key];\n            if (value && value.isTexture) textureSet.add(value);\n        }\n    }\n    const textureArray = Array.from(textureSet);\n    return $6eebe81d767f0e44$var$reduceTexturesToUniqueSources(textureArray).sort($6eebe81d767f0e44$var$uuidSort);\n}\nfunction $6eebe81d767f0e44$export$3ae1ccb94aa877f9(scene) {\n    const lights = [];\n    scene.traverse((c)=>{\n        if (c.visible) {\n            if (c.isRectAreaLight || c.isSpotLight || c.isPointLight || c.isDirectionalLight) lights.push(c);\n        }\n    });\n    return lights.sort($6eebe81d767f0e44$var$uuidSort);\n}\n\n});\n\n\nparcelRegister(\"12pjC\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderTarget2DArray\", () => $0c199d70d276a61d$export$dbbaa51cb2d0b2f7);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $RPVlj = parcelRequire(\"RPVlj\");\nconst $0c199d70d276a61d$var$prevColor = new (0, $ilwiq.Color)();\nfunction $0c199d70d276a61d$var$getTextureHash(texture) {\n    return texture ? `${texture.uuid}:${texture.version}` : null;\n}\nfunction $0c199d70d276a61d$var$assignOptions(target, options) {\n    for(const key in options)if (key in target) target[key] = options[key];\n}\nclass $0c199d70d276a61d$export$dbbaa51cb2d0b2f7 extends (0, $ilwiq.WebGLArrayRenderTarget) {\n    constructor(width, height, options){\n        const textureOptions = {\n            format: (0, $ilwiq.RGBAFormat),\n            type: (0, $ilwiq.UnsignedByteType),\n            minFilter: (0, $ilwiq.LinearFilter),\n            magFilter: (0, $ilwiq.LinearFilter),\n            wrapS: (0, $ilwiq.RepeatWrapping),\n            wrapT: (0, $ilwiq.RepeatWrapping),\n            generateMipmaps: false,\n            ...options\n        };\n        super(width, height, 1, textureOptions);\n        // manually assign the options because passing options into the\n        // constructor does not work\n        $0c199d70d276a61d$var$assignOptions(this.texture, textureOptions);\n        this.texture.setTextures = (...args)=>{\n            this.setTextures(...args);\n        };\n        this.hashes = [\n            null\n        ];\n        const fsQuad = new (0, $RPVlj.FullScreenQuad)(new $0c199d70d276a61d$var$CopyMaterial());\n        this.fsQuad = fsQuad;\n    }\n    setTextures(renderer, textures, width = this.width, height = this.height) {\n        // save previous renderer state\n        const prevRenderTarget = renderer.getRenderTarget();\n        const prevToneMapping = renderer.toneMapping;\n        const prevAlpha = renderer.getClearAlpha();\n        renderer.getClearColor($0c199d70d276a61d$var$prevColor);\n        // resize the render target and ensure we don't have an empty texture\n        // render target depth must be >= 1 to avoid unbound texture error on android devices\n        const depth = textures.length || 1;\n        if (width !== this.width || height !== this.height || this.depth !== depth) {\n            this.setSize(width, height, depth);\n            this.hashes = new Array(depth).fill(null);\n        }\n        renderer.setClearColor(0, 0);\n        renderer.toneMapping = (0, $ilwiq.NoToneMapping);\n        // render each texture into each layer of the target\n        const fsQuad = this.fsQuad;\n        const hashes = this.hashes;\n        let updated = false;\n        for(let i = 0, l = depth; i < l; i++){\n            const texture = textures[i];\n            const hash = $0c199d70d276a61d$var$getTextureHash(texture);\n            if (texture && (hashes[i] !== hash || texture.isWebGLRenderTarget)) {\n                // revert to default texture transform before rendering\n                texture.matrixAutoUpdate = false;\n                texture.matrix.identity();\n                fsQuad.material.map = texture;\n                renderer.setRenderTarget(this, i);\n                fsQuad.render(renderer);\n                // restore custom texture transform\n                texture.updateMatrix();\n                texture.matrixAutoUpdate = true;\n                // ensure textures are not updated unnecessarily\n                hashes[i] = hash;\n                updated = true;\n            }\n        }\n        // reset the renderer\n        fsQuad.material.map = null;\n        renderer.setClearColor($0c199d70d276a61d$var$prevColor, prevAlpha);\n        renderer.setRenderTarget(prevRenderTarget);\n        renderer.toneMapping = prevToneMapping;\n        return updated;\n    }\n    dispose() {\n        super.dispose();\n        this.fsQuad.dispose();\n    }\n}\nclass $0c199d70d276a61d$var$CopyMaterial extends (0, $ilwiq.ShaderMaterial) {\n    get map() {\n        return this.uniforms.map.value;\n    }\n    set map(v) {\n        this.uniforms.map.value = v;\n    }\n    constructor(){\n        super({\n            uniforms: {\n                map: {\n                    value: null\n                }\n            },\n            vertexShader: /* glsl */ `\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\n            fragmentShader: /* glsl */ `\r\n\t\t\t\tuniform sampler2D map;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\n        });\n    }\n}\n\n});\n\nparcelRegister(\"k5Ikv\", function(module, exports) {\n\n$parcel$export(module.exports, \"StratifiedSamplesTexture\", () => $ea06a939ea8d5f41$export$ed86923a2d1cdb9);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $50JN2 = parcelRequire(\"50JN2\");\n// https://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator\nclass $ea06a939ea8d5f41$var$RandomGenerator {\n    constructor(seed = 0){\n        // LCG using GCC's constants\n        this.m = 0x80000000; // 2**31;\n        this.a = 1103515245;\n        this.c = 12345;\n        this.seed = seed;\n    }\n    nextInt() {\n        this.seed = (this.a * this.seed + this.c) % this.m;\n        return this.seed;\n    }\n    nextFloat() {\n        // returns in range [0,1]\n        return this.nextInt() / (this.m - 1);\n    }\n}\nclass $ea06a939ea8d5f41$export$ed86923a2d1cdb9 extends (0, $ilwiq.DataTexture) {\n    constructor(count = 1, depth = 1, strata = 8){\n        super(new Float32Array(1), 1, 1, (0, $ilwiq.RGBAFormat), (0, $ilwiq.FloatType));\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.strata = strata;\n        this.sampler = null;\n        this.generator = new $ea06a939ea8d5f41$var$RandomGenerator();\n        this.stableNoise = false;\n        this.random = ()=>{\n            if (this.stableNoise) return this.generator.nextFloat();\n            else return Math.random();\n        };\n        this.init(count, depth, strata);\n    }\n    init(count = this.image.height, depth = this.image.width, strata = this.strata) {\n        const { image: image } = this;\n        if (image.width === depth && image.height === count && this.sampler !== null) return;\n        const dimensions = new Array(count * depth).fill(4);\n        const sampler = new (0, $50JN2.StratifiedSamplerCombined)(strata, dimensions, this.random);\n        image.width = depth;\n        image.height = count;\n        image.data = sampler.samples;\n        this.sampler = sampler;\n        this.dispose();\n        this.next();\n    }\n    next() {\n        this.sampler.next();\n        this.needsUpdate = true;\n    }\n    reset() {\n        this.sampler.reset();\n        this.generator.seed = 0;\n    }\n}\n\n});\nparcelRegister(\"50JN2\", function(module, exports) {\n\n$parcel$export(module.exports, \"StratifiedSamplerCombined\", () => $3a6078c8a44ac239$export$ec2d5f3091da4863);\n// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\n\nvar $1mKfc = parcelRequire(\"1mKfc\");\nclass $3a6078c8a44ac239$export$ec2d5f3091da4863 {\n    constructor(strataCount, listOfDimensions, random = Math.random){\n        let totalDim = 0;\n        for (const dim of listOfDimensions)totalDim += dim;\n        const combined = new Float32Array(totalDim);\n        const strataObjs = [];\n        let offset = 0;\n        for (const dim of listOfDimensions){\n            const sampler = new (0, $1mKfc.StratifiedSampler)(strataCount, dim, random);\n            sampler.samples = new Float32Array(combined.buffer, offset, sampler.samples.length);\n            offset += sampler.samples.length * 4;\n            strataObjs.push(sampler);\n        }\n        this.samples = combined;\n        this.strataCount = strataCount;\n        this.next = function() {\n            for (const strata of strataObjs)strata.next();\n            return combined;\n        };\n        this.reshuffle = function() {\n            for (const strata of strataObjs)strata.reshuffle();\n        };\n        this.reset = function() {\n            for (const strata of strataObjs)strata.reset();\n        };\n    }\n}\n\n});\nparcelRegister(\"1mKfc\", function(module, exports) {\n\n$parcel$export(module.exports, \"StratifiedSampler\", () => $0febb7a1dd1bc005$export$4811b65fd3eaefe6);\n// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\nfunction $0febb7a1dd1bc005$export$448332262467e042(arr, random = Math.random()) {\n    for(let i = arr.length - 1; i > 0; i--){\n        const j = Math.floor(random() * (i + 1));\n        const x = arr[i];\n        arr[i] = arr[j];\n        arr[j] = x;\n    }\n    return arr;\n}\nclass $0febb7a1dd1bc005$export$4811b65fd3eaefe6 {\n    constructor(strataCount, dimensions, random = Math.random){\n        const l = strataCount ** dimensions;\n        const strata = new Uint16Array(l);\n        let index = l;\n        // each integer represents a statum bin\n        for(let i = 0; i < l; i++)strata[i] = i;\n        this.samples = new Float32Array(dimensions);\n        this.strataCount = strataCount;\n        this.reset = function() {\n            for(let i = 0; i < l; i++)strata[i] = i;\n            index = 0;\n        };\n        this.reshuffle = function() {\n            index = 0;\n        };\n        this.next = function() {\n            const { samples: samples } = this;\n            if (index >= strata.length) {\n                $0febb7a1dd1bc005$export$448332262467e042(strata, random);\n                this.reshuffle();\n            }\n            let stratum = strata[index++];\n            for(let i = 0; i < dimensions; i++){\n                samples[i] = (stratum % strataCount + random()) / strataCount;\n                stratum = Math.floor(stratum / strataCount);\n            }\n            return samples;\n        };\n    }\n}\n\n});\n\n\n\nparcelRegister(\"hLXJE\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlueNoiseTexture\", () => $cf0529a3c8d7a87e$export$df8ca2ad0d82597a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7Afqk = parcelRequire(\"7Afqk\");\nfunction $cf0529a3c8d7a87e$var$getStride(channels) {\n    if (channels >= 3) return 4;\n    else return channels;\n}\nfunction $cf0529a3c8d7a87e$var$getFormat(channels) {\n    switch(channels){\n        case 1:\n            return 0, $ilwiq.RedFormat;\n        case 2:\n            return 0, $ilwiq.RGFormat;\n        default:\n            return 0, $ilwiq.RGBAFormat;\n    }\n}\nclass $cf0529a3c8d7a87e$export$df8ca2ad0d82597a extends (0, $ilwiq.DataTexture) {\n    constructor(size = 64, channels = 1){\n        super(new Float32Array(4), 1, 1, (0, $ilwiq.RGBAFormat), (0, $ilwiq.FloatType));\n        this.minFilter = (0, $ilwiq.NearestFilter);\n        this.magFilter = (0, $ilwiq.NearestFilter);\n        this.size = size;\n        this.channels = channels;\n        this.update();\n    }\n    update() {\n        const channels = this.channels;\n        const size = this.size;\n        const generator = new (0, $7Afqk.BlueNoiseGenerator)();\n        generator.channels = channels;\n        generator.size = size;\n        const stride = $cf0529a3c8d7a87e$var$getStride(channels);\n        const format = $cf0529a3c8d7a87e$var$getFormat(stride);\n        if (this.image.width !== size || format !== this.format) {\n            this.image.width = size;\n            this.image.height = size;\n            this.image.data = new Float32Array(size ** 2 * stride);\n            this.format = format;\n            this.dispose();\n        }\n        const data = this.image.data;\n        for(let i = 0, l = channels; i < l; i++){\n            const result = generator.generate();\n            const bin = result.data;\n            const maxValue = result.maxValue;\n            for(let j = 0, l2 = bin.length; j < l2; j++){\n                const value = bin[j] / maxValue;\n                data[j * stride + i] = value;\n            }\n        }\n        this.needsUpdate = true;\n    }\n}\n\n});\nparcelRegister(\"7Afqk\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlueNoiseGenerator\", () => $5857dc03ab71e5c3$export$395052bf180baf1f);\n\nvar $3voRb = parcelRequire(\"3voRb\");\n\nvar $dfd8t = parcelRequire(\"dfd8t\");\nclass $5857dc03ab71e5c3$export$395052bf180baf1f {\n    constructor(){\n        this.random = Math.random;\n        this.sigma = 1.5;\n        this.size = 64;\n        this.majorityPointsRatio = 0.1;\n        this.samples = new (0, $dfd8t.BlueNoiseSamples)(1);\n        this.savedSamples = new (0, $dfd8t.BlueNoiseSamples)(1);\n    }\n    generate() {\n        // http://cv.ulichney.com/papers/1993-void-cluster.pdf\n        const { samples: samples, savedSamples: savedSamples, sigma: sigma, majorityPointsRatio: majorityPointsRatio, size: size } = this;\n        samples.resize(size);\n        samples.setSigma(sigma);\n        // 1. Randomly place the minority points.\n        const pointCount = Math.floor(size * size * majorityPointsRatio);\n        const initialSamples = samples.binaryPattern;\n        (0, $3voRb.fillWithOnes)(initialSamples, pointCount);\n        (0, $3voRb.shuffleArray)(initialSamples, this.random);\n        for(let i = 0, l = initialSamples.length; i < l; i++)if (initialSamples[i] === 1) samples.addPointIndex(i);\n        // 2. Remove minority point that is in densest cluster and place it in the largest void.\n        while(true){\n            const clusterIndex = samples.findCluster();\n            samples.removePointIndex(clusterIndex);\n            const voidIndex = samples.findVoid();\n            if (clusterIndex === voidIndex) {\n                samples.addPointIndex(clusterIndex);\n                break;\n            }\n            samples.addPointIndex(voidIndex);\n        }\n        // 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\n        // in the dither array.\n        const ditherArray = new Uint32Array(size * size);\n        savedSamples.copy(samples);\n        let rank;\n        rank = samples.count - 1;\n        while(rank >= 0){\n            const clusterIndex = samples.findCluster();\n            samples.removePointIndex(clusterIndex);\n            ditherArray[clusterIndex] = rank;\n            rank--;\n        }\n        // 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\n        // the initial binary pattern.\n        const totalSize = size * size;\n        rank = savedSamples.count;\n        while(rank < totalSize / 2){\n            const voidIndex = savedSamples.findVoid();\n            savedSamples.addPointIndex(voidIndex);\n            ditherArray[voidIndex] = rank;\n            rank++;\n        }\n        // 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\n        // and iteratively removing them.\n        savedSamples.invert();\n        while(rank < totalSize){\n            const clusterIndex = savedSamples.findCluster();\n            savedSamples.removePointIndex(clusterIndex);\n            ditherArray[clusterIndex] = rank;\n            rank++;\n        }\n        return {\n            data: ditherArray,\n            maxValue: totalSize\n        };\n    }\n}\n\n});\nparcelRegister(\"3voRb\", function(module, exports) {\n\n$parcel$export(module.exports, \"shuffleArray\", () => $28d78c69b5764593$export$7ac3a88d34a76e7);\n$parcel$export(module.exports, \"fillWithOnes\", () => $28d78c69b5764593$export$50dc72eec73f3f5d);\nfunction $28d78c69b5764593$export$7ac3a88d34a76e7(array, random = Math.random) {\n    for(let i = array.length - 1; i > 0; i--){\n        const replaceIndex = ~~((random() - 1e-6) * i);\n        const tmp = array[i];\n        array[i] = array[replaceIndex];\n        array[replaceIndex] = tmp;\n    }\n}\nfunction $28d78c69b5764593$export$50dc72eec73f3f5d(array, count) {\n    array.fill(0);\n    for(let i = 0; i < count; i++)array[i] = 1;\n}\n\n});\n\nparcelRegister(\"dfd8t\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlueNoiseSamples\", () => $9a46dd8a24c94e3f$export$ce82934b5dfddd2e);\nclass $9a46dd8a24c94e3f$export$ce82934b5dfddd2e {\n    constructor(size){\n        this.count = 0;\n        this.size = -1;\n        this.sigma = -1;\n        this.radius = -1;\n        this.lookupTable = null;\n        this.score = null;\n        this.binaryPattern = null;\n        this.resize(size);\n        this.setSigma(1.5);\n    }\n    findVoid() {\n        const { score: score, binaryPattern: binaryPattern } = this;\n        let currValue = Infinity;\n        let currIndex = -1;\n        for(let i = 0, l = binaryPattern.length; i < l; i++){\n            if (binaryPattern[i] !== 0) continue;\n            const pScore = score[i];\n            if (pScore < currValue) {\n                currValue = pScore;\n                currIndex = i;\n            }\n        }\n        return currIndex;\n    }\n    findCluster() {\n        const { score: score, binaryPattern: binaryPattern } = this;\n        let currValue = -Infinity;\n        let currIndex = -1;\n        for(let i = 0, l = binaryPattern.length; i < l; i++){\n            if (binaryPattern[i] !== 1) continue;\n            const pScore = score[i];\n            if (pScore > currValue) {\n                currValue = pScore;\n                currIndex = i;\n            }\n        }\n        return currIndex;\n    }\n    setSigma(sigma) {\n        if (sigma === this.sigma) return;\n        // generate a radius in which the score will be updated under the\n        // assumption that e^-10 is insignificant enough to be the border at\n        // which we drop off.\n        const radius = ~~(Math.sqrt(20 * sigma ** 2) + 1);\n        const lookupWidth = 2 * radius + 1;\n        const lookupTable = new Float32Array(lookupWidth * lookupWidth);\n        const sigma2 = sigma * sigma;\n        for(let x = -radius; x <= radius; x++)for(let y = -radius; y <= radius; y++){\n            const index = (radius + y) * lookupWidth + x + radius;\n            const dist2 = x * x + y * y;\n            lookupTable[index] = Math.E ** (-dist2 / (2 * sigma2));\n        }\n        this.lookupTable = lookupTable;\n        this.sigma = sigma;\n        this.radius = radius;\n    }\n    resize(size) {\n        if (this.size !== size) {\n            this.size = size;\n            this.score = new Float32Array(size * size);\n            this.binaryPattern = new Uint8Array(size * size);\n        }\n    }\n    invert() {\n        const { binaryPattern: binaryPattern, score: score, size: size } = this;\n        score.fill(0);\n        for(let i = 0, l = binaryPattern.length; i < l; i++)if (binaryPattern[i] === 0) {\n            const y = ~~(i / size);\n            const x = i - y * size;\n            this.updateScore(x, y, 1);\n            binaryPattern[i] = 1;\n        } else binaryPattern[i] = 0;\n    }\n    updateScore(x, y, multiplier) {\n        // TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\n        // everything in the buffer?\n        const { size: size, score: score, lookupTable: lookupTable } = this;\n        // const sigma2 = sigma * sigma;\n        // const radius = Math.floor( size / 2 );\n        const radius = this.radius;\n        const lookupWidth = 2 * radius + 1;\n        for(let px = -radius; px <= radius; px++)for(let py = -radius; py <= radius; py++){\n            // const dist2 = px * px + py * py;\n            // const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\n            const lookupIndex = (radius + py) * lookupWidth + px + radius;\n            const value = lookupTable[lookupIndex];\n            let sx = x + px;\n            sx = sx < 0 ? size + sx : sx % size;\n            let sy = y + py;\n            sy = sy < 0 ? size + sy : sy % size;\n            const sindex = sy * size + sx;\n            score[sindex] += multiplier * value;\n        }\n    }\n    addPointIndex(index) {\n        this.binaryPattern[index] = 1;\n        const size = this.size;\n        const y = ~~(index / size);\n        const x = index - y * size;\n        this.updateScore(x, y, 1);\n        this.count++;\n    }\n    removePointIndex(index) {\n        this.binaryPattern[index] = 0;\n        const size = this.size;\n        const y = ~~(index / size);\n        const x = index - y * size;\n        this.updateScore(x, y, -1);\n        this.count--;\n    }\n    copy(source) {\n        this.resize(source.size);\n        this.score.set(source.score);\n        this.binaryPattern.set(source.binaryPattern);\n        this.setSigma(source.sigma);\n        this.count = source.count;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"sORjD\", function(module, exports) {\n\n$parcel$export(module.exports, \"camera_struct\", () => $056a1129e103f8a3$export$ff29bcb3325786f4);\nconst $056a1129e103f8a3$export$ff29bcb3325786f4 = /* glsl */ `\r\n\r\n\tstruct PhysicalCamera {\r\n\r\n\t\tfloat focusDistance;\r\n\t\tfloat anamorphicRatio;\r\n\t\tfloat bokehSize;\r\n\t\tint apertureBlades;\r\n\t\tfloat apertureRotation;\r\n\r\n\t};\r\n\r\n`;\n\n});\n\nparcelRegister(\"WBvYF\", function(module, exports) {\n\n$parcel$export(module.exports, \"equirect_struct\", () => $0b02848bbcd9659f$export$55a5ad677f09b429);\nconst $0b02848bbcd9659f$export$55a5ad677f09b429 = /* glsl */ `\r\n\r\n\tstruct EquirectHdrInfo {\r\n\r\n\t\tsampler2D marginalWeights;\r\n\t\tsampler2D conditionalWeights;\r\n\t\tsampler2D map;\r\n\r\n\t\tfloat totalSum;\r\n\r\n\t};\r\n\r\n`;\n\n});\n\nparcelRegister(\"1QwjS\", function(module, exports) {\n\n$parcel$export(module.exports, \"lights_struct\", () => $1583b7c3c4aba100$export$b8142914126932cc);\nconst $1583b7c3c4aba100$export$b8142914126932cc = /* glsl */ `\r\n\r\n\t#define RECT_AREA_LIGHT_TYPE 0\r\n\t#define CIRC_AREA_LIGHT_TYPE 1\r\n\t#define SPOT_LIGHT_TYPE 2\r\n\t#define DIR_LIGHT_TYPE 3\r\n\t#define POINT_LIGHT_TYPE 4\r\n\r\n\tstruct LightsInfo {\r\n\r\n\t\tsampler2D tex;\r\n\t\tuint count;\r\n\r\n\t};\r\n\r\n\tstruct Light {\r\n\r\n\t\tvec3 position;\r\n\t\tint type;\r\n\r\n\t\tvec3 color;\r\n\t\tfloat intensity;\r\n\r\n\t\tvec3 u;\r\n\t\tvec3 v;\r\n\t\tfloat area;\r\n\r\n\t\t// spot light fields\r\n\t\tfloat radius;\r\n\t\tfloat near;\r\n\t\tfloat decay;\r\n\t\tfloat distance;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\tint iesProfile;\r\n\r\n\t};\r\n\r\n\tLight readLightInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 6u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\r\n\t\tLight l;\r\n\t\tl.position = s0.rgb;\r\n\t\tl.type = int( round( s0.a ) );\r\n\r\n\t\tl.color = s1.rgb;\r\n\t\tl.intensity = s1.a;\r\n\r\n\t\tl.u = s2.rgb;\r\n\t\tl.v = s3.rgb;\r\n\t\tl.area = s3.a;\r\n\r\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\t\tl.radius = s4.r;\r\n\t\t\tl.decay = s4.g;\r\n\t\t\tl.distance = s4.b;\r\n\t\t\tl.coneCos = s4.a;\r\n\r\n\t\t\tl.penumbraCos = s5.r;\r\n\t\t\tl.iesProfile = int( round( s5.g ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl.radius = 0.0;\r\n\t\t\tl.decay = 0.0;\r\n\t\t\tl.distance = 0.0;\r\n\r\n\t\t\tl.coneCos = 0.0;\r\n\t\t\tl.penumbraCos = 0.0;\r\n\t\t\tl.iesProfile = - 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn l;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"asLEI\", function(module, exports) {\n\n$parcel$export(module.exports, \"surface_record_struct\", () => $79e17c5d028db7ed$export$d11a3e67165e5cc8);\nconst $79e17c5d028db7ed$export$d11a3e67165e5cc8 = /* glsl */ `\r\n\r\n\tstruct SurfaceRecord {\r\n\r\n\t\t// surface type\r\n\t\tbool volumeParticle;\r\n\r\n\t\t// geometry\r\n\t\tvec3 faceNormal;\r\n\t\tbool frontFace;\r\n\t\tvec3 normal;\r\n\t\tmat3 normalBasis;\r\n\t\tmat3 normalInvBasis;\r\n\r\n\t\t// cached properties\r\n\t\tfloat eta;\r\n\t\tfloat f0;\r\n\r\n\t\t// material\r\n\t\tfloat roughness;\r\n\t\tfloat filteredRoughness;\r\n\t\tfloat metalness;\r\n\t\tvec3 color;\r\n\t\tvec3 emission;\r\n\r\n\t\t// transmission\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tbool thinFilm;\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\t// clearcoat\r\n\t\tvec3 clearcoatNormal;\r\n\t\tmat3 clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis;\r\n\t\tfloat clearcoat;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tfloat filteredClearcoatRoughness;\r\n\r\n\t\t// sheen\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tfloat sheenRoughness;\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThickness;\r\n\r\n\t\t// specular\r\n\t\tvec3 specularColor;\r\n\t\tfloat specularIntensity;\r\n\t};\r\n\r\n\tstruct ScatterRecord {\r\n\t\tfloat specularPdf;\r\n\t\tfloat pdf;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t};\r\n\r\n`;\n\n});\n\nparcelRegister(\"6VF8W\", function(module, exports) {\n\n$parcel$export(module.exports, \"equirect_functions\", () => $50b7fb1d651b0127$export$8450b254896ea12);\nconst $50b7fb1d651b0127$export$8450b254896ea12 = /* glsl */ `\r\n\r\n\t// samples the the given environment map in the given direction\r\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\r\n\r\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\r\n\r\n\t}\r\n\r\n\t// gets the pdf of the given direction to sample\r\n\tfloat equirectDirectionPdf( vec3 direction ) {\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tfloat theta = uv.y * PI;\r\n\t\tfloat sinTheta = sin( theta );\r\n\t\tif ( sinTheta == 0.0 ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\r\n\r\n\t}\r\n\r\n\t// samples the color given env map with CDF and returns the pdf of the direction\r\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tif ( totalSum == 0.0 ) {\r\n\r\n\t\t\tcolor = vec3( 0.0 );\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n\r\n\t// samples a direction of the envmap with color and retrieves pdf\r\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\r\n\r\n\t\t// sample env map cdf\r\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\r\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\r\n\t\tvec2 uv = vec2( u, v );\r\n\r\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\r\n\t\tdirection = derivedDirection;\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n`;\n\n});\n\nparcelRegister(\"232IN\", function(module, exports) {\n\n$parcel$export(module.exports, \"light_sampling_functions\", () => $17ddf9091b3b4093$export$a22775c3497c2ab8);\nconst $17ddf9091b3b4093$export$a22775c3497c2ab8 = /* glsl */ `\r\n\r\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\r\n\r\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\r\n\r\n\t}\r\n\r\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t\t// page 32, equation 26: E[window1]\r\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\r\n\r\n\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn distanceFalloff;\r\n\r\n\t}\r\n\r\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\r\n\r\n\t\tfloat cosTheta = dot( posToLight, lightDir );\r\n\t\tfloat angle = acos( cosTheta ) / PI;\r\n\r\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\r\n\r\n\t}\r\n\r\n\tstruct LightRecord {\r\n\r\n\t\tfloat dist;\r\n\t\tvec3 direction;\r\n\t\tfloat pdf;\r\n\t\tvec3 emission;\r\n\t\tint type;\r\n\r\n\t};\r\n\r\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\r\n\r\n\t\tbool didHit = false;\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\r\n\t\t// check for backface\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\r\n\r\n\t\t\tu *= 1.0 / dot( u, u );\r\n\t\t\tv *= 1.0 / dot( v, v );\r\n\r\n\t\t\tfloat dist;\r\n\r\n\t\t\t// MIS / light intersection is not supported for punctual lights.\r\n\t\t\tif(\r\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\r\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\r\n\t\t\t\tdidHit = true;\r\n\t\t\t\tlightRec.dist = dist;\r\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\r\n\t\t\t\tlightRec.emission = light.color * light.intensity;\r\n\t\t\t\tlightRec.direction = rayDirection;\r\n\t\t\t\tlightRec.type = light.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn didHit;\r\n\r\n\t}\r\n\r\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tvec3 randomPos;\r\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// rectangular area light\r\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\r\n\r\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// circular area light\r\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\r\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\t\tfloat x = r * cos( theta );\r\n\t\t\tfloat y = r * sin( theta );\r\n\r\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\t\tvec3 direction = toLight / dist;\r\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\r\n\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.emission = light.color * light.intensity;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\r\n\t\t// TODO: the denominator is potentially zero\r\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tfloat radius = light.radius * sqrt( ruv.x );\r\n\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\tfloat x = radius * cos( theta );\r\n\t\tfloat y = radius * sin( theta );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\r\n\t\tfloat angle = acos( light.coneCos );\r\n\t\tfloat angleTan = tan( angle );\r\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\r\n\r\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\r\n\t\tvec3 direction = toLight / max( dist, EPSILON );\r\n\t\tfloat cosTheta = dot( direction, normal );\r\n\r\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\r\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\r\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\r\n\r\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\r\n\t\tlightRec.pdf = 1.0;\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\r\n\r\n\t\tLightRecord result;\r\n\r\n\t\t// pick a random light\r\n\t\tuint l = uint( ruv.x * float( lightCount ) );\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\r\n\r\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\r\n\r\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec3 lightRay = light.u - rayOrigin;\r\n\t\t\tfloat lightDist = length( lightRay );\r\n\t\t\tfloat cutoffDistance = light.distance;\r\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\r\n\t\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.direction = normalize( lightRay );\r\n\t\t\trec.dist = length( lightRay );\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\r\n\t\t\trec.type = light.type;\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.dist = 1e10;\r\n\t\t\trec.direction = light.u;\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity;\r\n\t\t\trec.type = light.type;\r\n\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// sample the light\r\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"8KxWl\", function(module, exports) {\n\n$parcel$export(module.exports, \"fresnel_functions\", () => $65ecf25fdf796e21$export$2f3e20d8a82fe5e3);\nconst $65ecf25fdf796e21$export$2f3e20d8a82fe5e3 = /* glsl */ `\r\n\r\n\tbool totalInternalReflection( float cosTheta, float eta ) {\r\n\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\treturn eta * sinTheta > 1.0;\r\n\r\n\t}\r\n\r\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\r\n\tfloat schlickFresnel( float cosine, float f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\r\n\r\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat ni = eta;\r\n\t\tfloat nt = 1.0;\r\n\r\n\t\t// Check for total internal reflection\r\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\r\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\r\n\t\tif( sinThetaTSq >= 1.0 ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\r\n\r\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\r\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\r\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\r\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\r\n\r\n\t}\r\n\r\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\r\n\tfloat iorRatioToF0( float eta ) {\r\n\r\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\r\n\r\n\t}\r\n\r\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\r\n\r\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t\t\treturn f90;\r\n\r\n\t\t}\r\n\r\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\r\n\r\n\t}\r\n\r\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\r\n\t// the glTF but is causing blown out pixels. Should be revisited\r\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\r\n\r\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t// \t\treturn 1.0;\r\n\r\n\t// \t}\r\n\r\n\t// \treturn schlickFresnel( cosTheta, f0 );\r\n\r\n\t// }\r\n\r\n\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\r\n\r\n\t\tfloat dotHV = dot( wo, wh );\r\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat dotHL = dot( wi, wh );\r\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\r\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\r\n\r\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"d9skn\", function(module, exports) {\n\n$parcel$export(module.exports, \"shape_intersection_functions\", () => $993216e4b4262820$export$c580e1bca0d1e835);\nconst $993216e4b4262820$export$c580e1bca0d1e835 = /* glsl */ `\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the rectangle on that same plane.\r\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\r\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = p - center;\r\n\r\n\t\t\t// check if p falls inside the rectangle\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\r\n\r\n\t\t\t\tfloat a2 = dot( v, vi );\r\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\r\n\r\n\t\t\t\t\tdist = t;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\r\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = hit - position;\r\n\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tfloat a2 = dot( v, vi );\r\n\r\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\r\n\r\n\t\t\t\tdist = t;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"jpfro\", function(module, exports) {\n\n$parcel$export(module.exports, \"texture_sample_functions\", () => $e20c545bebebbdde$export$4c62bb41ef52ef46);\nconst $e20c545bebebbdde$export$4c62bb41ef52ef46 = /*glsl */ `\r\n\r\n\t// add texel fetch functions for texture arrays\r\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\r\n\r\n\t\tuint width = uint( textureSize( tex, 0 ).x );\r\n\t\tuvec2 uv;\r\n\t\tuv.x = index % width;\r\n\t\tuv.y = index / width;\r\n\r\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\r\n\r\n\t}\r\n\r\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\t\treturn\r\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\r\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\r\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"gCBx4\", function(module, exports) {\n\n$parcel$export(module.exports, \"stratified_functions\", () => $c19d4f19383277fc$export$a7b9b03dc39b0c39);\nconst $c19d4f19383277fc$export$a7b9b03dc39b0c39 = /* glsl */ `\r\n\r\n\tuniform sampler2D stratifiedTexture;\r\n\tuniform sampler2D stratifiedOffsetTexture;\r\n\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\tvec4 pixelSeed = vec4( 0 );\r\n\r\n\tvec4 rand4( int v ) {\r\n\r\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\r\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\r\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\r\n\r\n\t}\r\n\r\n\tvec3 rand3( int v ) {\r\n\r\n\t\treturn rand4( v ).xyz;\r\n\r\n\t}\r\n\r\n\tvec2 rand2( int v ) {\r\n\r\n\t\treturn rand4( v ).xy;\r\n\r\n\t}\r\n\r\n\tfloat rand( int v ) {\r\n\r\n\t\treturn rand4( v ).x;\r\n\r\n\t}\r\n\r\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\r\n\r\n\t\t// tile the small noise texture across the entire screen\r\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\r\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\r\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\r\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\r\n\r\n\t\t// note that using \"texelFetch\" here seems to break Android for some reason\r\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"6voD8\", function(module, exports) {\n\n$parcel$export(module.exports, \"bsdf_functions\", () => $4bc8be5fc03f5cd3$export$c0d7886d8c99f58c);\n/*\r\nwi     : incident vector or light vector (pointing toward the light)\r\nwo     : outgoing vector or view vector (pointing towards the camera)\r\nwh     : computed half vector from wo and wi\r\nEval   : Get the color and pdf for a direction\r\nSample : Get the direction, color, and pdf for a sample\r\neta    : Greek character used to denote the \"ratio of ior\"\r\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\r\nf90    : Amount of light reflected at grazing angles\r\n*/ const $4bc8be5fc03f5cd3$export$c0d7886d8c99f58c = /* glsl */ `\r\n\r\n\t// diffuse\r\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\r\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\r\n\r\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\r\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\r\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\r\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\r\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\r\n\r\n\t\t// TODO: subsurface approx?\r\n\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\r\n\r\n\t\treturn wi.z / PI;\r\n\r\n\t}\r\n\r\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\r\n\t\tlightDirection.z += 1.0;\r\n\t\tlightDirection = normalize( lightDirection );\r\n\r\n\t\treturn lightDirection;\r\n\r\n\t}\r\n\r\n\t// specular\r\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\r\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\r\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\r\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\r\n\r\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\r\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\r\n\r\n\t\t// PDF\r\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\r\n\t\tfloat incidentTheta = acos( wo.z );\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\r\n\r\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 12 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\r\n\t// transmission\r\n\t/*\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tbool thinFilm = surf.thinFilm;\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\r\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( filteredRoughness ),\r\n\t\t\trand2( 13 )\r\n\t\t);\r\n\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\t*/\r\n\r\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\r\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\t// PDF\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\t// if ( F >= 1.0 ) {\r\n\r\n\t\t// \treturn 0.0;\r\n\r\n\t\t// }\r\n\r\n\t\t// return 1.0 / ( 1.0 - F );\r\n\r\n\t\t// reverted to previous to transmission. The above was causing black pixels\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\t\tfloat cosTheta = min( wo.z, 1.0 );\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\r\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\r\n\t\tif ( cannotRefract ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 1.0 - reflectance );\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\r\n\t// clearcoat\r\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tfloat ior = 1.5;\r\n\t\tfloat f0 = iorRatioToF0( ior );\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\r\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\r\n\r\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\r\n\r\n\t\t// PDF\r\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\r\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 14 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\t// sheen\r\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\r\n\r\n\t\tfloat cosThetaO = saturateCos( wo.z );\r\n\t\tfloat cosThetaI = saturateCos( wi.z );\r\n\t\tfloat cosThetaH = wh.z;\r\n\r\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\r\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\r\n\r\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\t\tvec3 color = surf.sheenColor;\r\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\r\n\t\tcolor *= wi.z;\r\n\r\n\t\treturn color;\r\n\r\n\t}\r\n\r\n\t// bsdf\r\n\tvoid getLobeWeights(\r\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\r\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\r\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\r\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\r\n\r\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\r\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\r\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\r\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\r\n\r\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\r\n\t\tdiffuseWeight /= totalWeight;\r\n\t\tspecularWeight /= totalWeight;\r\n\t\ttransmissionWeight /= totalWeight;\r\n\t\tclearcoatWeight /= totalWeight;\r\n\t}\r\n\r\n\tfloat bsdfEval(\r\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\r\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\r\n\t\tfloat spdf = 0.0;\r\n\t\tfloat dpdf = 0.0;\r\n\t\tfloat tpdf = 0.0;\r\n\t\tfloat cpdf = 0.0;\r\n\t\tcolor = vec3( 0.0 );\r\n\r\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\r\n\r\n\t\t// diffuse\r\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\r\n\t\t\tcolor *= 1.0 - surf.transmission;\r\n\r\n\t\t}\r\n\r\n\t\t// ggx specular\r\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tvec3 outColor;\r\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\r\n\t\t\tcolor += outColor;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\r\n\r\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\t// sheen\r\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\r\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\r\n\r\n\t\t// clearcoat\r\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\r\n\r\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\r\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\tfloat pdf =\r\n\t\t\tdpdf * diffuseWeight\r\n\t\t\t+ spdf * specularWeight\r\n\t\t\t+ tpdf * transmissionWeight\r\n\t\t\t+ cpdf * clearcoatWeight;\r\n\r\n\t\t// retrieve specular rays for the shadows flag\r\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\r\n\r\n\t\treturn pdf;\r\n\r\n\t}\r\n\r\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tcolor = surf.color / ( 4.0 * PI );\r\n\t\t\treturn 1.0 / ( 4.0 * PI );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\r\n\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\r\n\r\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat specularPdf;\r\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\r\n\r\n\t}\r\n\r\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tScatterRecord sampleRec;\r\n\t\t\tsampleRec.specularPdf = 0.0;\r\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\r\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\r\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\r\n\t\t\treturn sampleRec;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tmat3 normalBasis = surf.normalBasis;\r\n\t\tmat3 invBasis = surf.normalInvBasis;\r\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\r\n\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\r\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat pdf[4];\r\n\t\tpdf[0] = diffuseWeight;\r\n\t\tpdf[1] = specularWeight;\r\n\t\tpdf[2] = transmissionWeight;\r\n\t\tpdf[3] = clearcoatWeight;\r\n\r\n\t\tfloat cdf[4];\r\n\t\tcdf[0] = pdf[0];\r\n\t\tcdf[1] = pdf[1] + cdf[0];\r\n\t\tcdf[2] = pdf[2] + cdf[1];\r\n\t\tcdf[3] = pdf[3] + cdf[2];\r\n\r\n\t\tif( cdf[3] != 0.0 ) {\r\n\r\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\r\n\t\t\tcdf[0] *= invMaxCdf;\r\n\t\t\tcdf[1] *= invMaxCdf;\r\n\t\t\tcdf[2] *= invMaxCdf;\r\n\t\t\tcdf[3] *= invMaxCdf;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcdf[0] = 1.0;\r\n\t\t\tcdf[1] = 0.0;\r\n\t\t\tcdf[2] = 0.0;\r\n\t\t\tcdf[3] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wi;\r\n\t\tvec3 clearcoatWi;\r\n\r\n\t\tfloat r = rand( 15 );\r\n\t\tif ( r <= cdf[0] ) { // diffuse\r\n\r\n\t\t\twi = diffuseDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[1] ) { // specular\r\n\r\n\t\t\twi = specularDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\r\n\r\n\t\t\twi = transmissionDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\r\n\r\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\r\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\r\n\r\n\t\t}\r\n\r\n\t\tScatterRecord result;\r\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\r\n\t\tresult.direction = normalize( surf.normalBasis * wi );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"4GDCw\", function(module, exports) {\n\n$parcel$export(module.exports, \"fog_functions\", () => $3699d1726d2f89b6$export$7e0eb49b04f8be76);\nconst $3699d1726d2f89b6$export$7e0eb49b04f8be76 = /* glsl */ `\r\n\r\n\t// returns the hit distance given the material density\r\n\tfloat intersectFogVolume( Material material, float u ) {\r\n\r\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\r\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\r\n\r\n\t}\r\n\r\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\r\n\r\n\t\tScatterRecord sampleRec;\r\n\t\tsampleRec.specularPdf = 0.0;\r\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\r\n\t\tsampleRec.direction = sampleSphere( uv );\r\n\t\tsampleRec.color = surf.color;\r\n\t\treturn sampleRec;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"9kAYu\", function(module, exports) {\n\n$parcel$export(module.exports, \"iridescence_functions\", () => $6cb2a9b144b85589$export$c5fa12fdf656cb44);\nconst $6cb2a9b144b85589$export$c5fa12fdf656cb44 = /* glsl */ `\r\n\r\n\t// XYZ to sRGB color space\r\n\tconst mat3 XYZ_TO_REC709 = mat3(\r\n\t\t3.2404542, -0.9692660,  0.0556434,\r\n\t\t-1.5371385,  1.8760108, -0.2040259,\r\n\t\t-0.4985314,  0.0415560,  1.0572252\r\n\t);\r\n\r\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\r\n\r\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\r\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\r\n\r\n\t}\r\n\r\n\t// Conversion FO/IOR\r\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\r\n\r\n\t}\r\n\r\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\r\n\r\n\t}\r\n\r\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\r\n\r\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\r\n\r\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\r\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\r\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\r\n\r\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\r\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\r\n\t\txyz /= 1.0685e-7;\r\n\r\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\r\n\t\treturn srgb;\r\n\r\n\t}\r\n\r\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\r\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\r\n\r\n\t\tvec3 I;\r\n\r\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\r\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\r\n\r\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\r\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\r\n\r\n\t\t// Handle TIR:\r\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n\t\tif ( cosTheta2Sq < 0.0 ) {\r\n\r\n\t\t\treturn vec3( 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\r\n\r\n\t\t// First interface\r\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\r\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\r\n\t\tfloat R21 = R12;\r\n\t\tfloat T121 = 1.0 - R12;\r\n\t\tfloat phi12 = 0.0;\r\n\t\tif ( iridescenceIor < outsideIOR ) {\r\n\r\n\t\t\tphi12 = PI;\r\n\r\n\t\t}\r\n\r\n\t\tfloat phi21 = PI - phi12;\r\n\r\n\t\t// Second interface\r\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\r\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\r\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\r\n\t\tvec3 phi23 = vec3( 0.0 );\r\n\t\tif ( baseIOR[0] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 0 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[1] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 1 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[2] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 2 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\t// Phase shift\r\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\r\n\t\tvec3 phi = vec3( phi21 ) + phi23;\r\n\r\n\t\t// Compound terms\r\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\r\n\t\tvec3 r123 = sqrt( R123 );\r\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\r\n\r\n\t\t// Reflectance term for m = 0 (DC term amplitude)\r\n\t\tvec3 C0 = R12 + Rs;\r\n\t\tI = C0;\r\n\r\n\t\t// Reflectance term for m > 0 (pairs of diracs)\r\n\t\tvec3 Cm = Rs - T121;\r\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\r\n\r\n\t\t\tCm *= r123;\r\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\r\n\t\t\tI += Cm * Sm;\r\n\r\n\t\t}\r\n\r\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n\t\treturn max( I, vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"5SszG\", function(module, exports) {\n\n$parcel$export(module.exports, \"sheen_functions\", () => $44782939f1da8c08$export$41b398d23411fca);\nconst $44782939f1da8c08$export$41b398d23411fca = /* glsl */ `\r\n\r\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetD( float cosThetaH, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat invAlpha = 1.0 / alpha;\r\n\r\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\r\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\r\n\r\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\r\n\r\n\t}\r\n\r\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\r\n\r\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\r\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\r\n\r\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\r\n\r\n\t}\r\n\r\n\tfloat velvetL( float x, float alpha ) {\r\n\r\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\r\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\r\n\r\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\r\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\r\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\r\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\r\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\r\n\r\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\r\n\r\n\t}\r\n\r\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetLambda( float cosTheta, float alpha ) {\r\n\r\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\r\n\r\n\t}\r\n\r\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\r\n\r\n\t}\r\n\r\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\r\n\r\n\t\tcosTheta = saturate( cosTheta );\r\n\r\n\t\tfloat c = 1.0 - cosTheta;\r\n\t\tfloat c3 = c * c * c;\r\n\r\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\r\n\r\n\t}\r\n\r\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\r\n\r\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\r\n\r\n\t}\r\n\r\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\r\n\t\treturn 1.0 - maxSheenColor * eWo;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"hB5SN\", function(module, exports) {\n\n$parcel$export(module.exports, \"inside_fog_volume_function\", () => $ccfa748eb10216c5$export$9b383298f1837cb1);\nconst $ccfa748eb10216c5$export$9b383298f1837cb1 = /* glsl */ `\r\n\r\n#ifndef FOG_CHECK_ITERATIONS\r\n#define FOG_CHECK_ITERATIONS 30\r\n#endif\r\n\r\n// returns whether the given material is a fog material or not\r\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\r\n\r\n\tuint i = materialIndex * uint( MATERIAL_PIXELS );\r\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\r\n\treturn bool( int( s14.b ) & 4 );\r\n\r\n}\r\n\r\n// returns true if we're within the first fog volume we hit\r\nbool bvhIntersectFogVolumeHit(\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\tusampler2D materialIndexAttribute, sampler2D materials,\r\n\tinout Material material\r\n) {\r\n\r\n\tmaterial.fogVolume = false;\r\n\r\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\r\n\r\n\t\t// find nearest hit\r\n\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\tfloat side = 1.0;\r\n\t\tfloat dist = 0.0;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\t\tif ( hit ) {\r\n\r\n\t\t\t// if it's a fog volume return whether we hit the front or back face\r\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\r\n\r\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\r\n\t\t\t\treturn side == - 1.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// move the ray forward\r\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n`;\n\n});\n\nparcelRegister(\"1zk7M\", function(module, exports) {\n\n$parcel$export(module.exports, \"attenuate_hit_function\", () => $1248aba150c298a9$export$2cef3f20f6a7d7fc);\nconst $1248aba150c298a9$export$2cef3f20f6a7d7fc = /* glsl */ `\r\n\r\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\r\n\t// returns true if a solid surface was hit\r\n\tbool attenuateHit(\r\n\t\tRenderState state,\r\n\t\tRay ray, float rayDist,\r\n\t\tout vec3 color\r\n\t) {\r\n\r\n\t\t// store the original bounce index so we can reset it after\r\n\t\tuint originalBounceIndex = sobolBounceIndex;\r\n\r\n\t\tint traversals = state.traversals;\r\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\r\n\t\tbool isShadowRay = state.isShadowRay;\r\n\t\tMaterial fogMaterial = state.fogMaterial;\r\n\r\n\t\tvec3 startPoint = ray.origin;\r\n\r\n\t\t// hit results\r\n\t\tSurfaceHit surfaceHit;\r\n\r\n\t\tcolor = vec3( 1.0 );\r\n\r\n\t\tbool result = true;\r\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\r\n\r\n\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\r\n\r\n\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\tresult = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\r\n\r\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\r\n\t\t\t\tif ( totalDist > rayDist ) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\r\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\r\n\t\t\t\t// TODO: should we account for emissive surfaces here?\r\n\r\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t// adjust the ray to the new surface\r\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\r\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\t\t\tfogMaterial = material;\r\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t\t\t// albedo\r\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\t\t\talbedo *= vertexColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// alphaMap\r\n\t\t\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transmission\r\n\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// metalness\r\n\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\r\n\t\t\t\tif (\r\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\r\n\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\r\n\r\n\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tresult = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\r\n\r\n\t\t\t\t\t// only attenuate by surface color on the way in\r\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\r\n\r\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\r\n\r\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\r\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the bounce index\r\n\t\tsobolBounceIndex = originalBounceIndex;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"eJ3gD\", function(module, exports) {\n\n$parcel$export(module.exports, \"camera_util_functions\", () => $ab87cd757b5ff812$export$4f78a71f798e1125);\nconst $ab87cd757b5ff812$export$4f78a71f798e1125 = /* glsl */ `\r\n\r\n\tvec3 ndcToRayOrigin( vec2 coord ) {\r\n\r\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\r\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\r\n\t}\r\n\r\n\tRay getCameraRay() {\r\n\r\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\r\n\r\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\r\n\t\t// around this pixel's UV coordinate for AA\r\n\t\tvec2 ruv = rand2( 0 );\r\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\r\n\t\tRay ray;\r\n\r\n\t\t#if CAMERA_TYPE == 2\r\n\r\n\t\t\t// Equirectangular projection\r\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\r\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\r\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\r\n\r\n\t\t\tray.direction = normalize( rayDirection4.xyz );\r\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\r\n\r\n\t\t#else\r\n\r\n\t\t\t// get [- 1, 1] normalized device coordinates\r\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\r\n\t\t\tray.origin = ndcToRayOrigin( ndc );\r\n\r\n\t\t\t#if CAMERA_TYPE == 1\r\n\r\n\t\t\t\t// Orthographic projection\r\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\r\n\t\t\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// Perspective projection\r\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\r\n\t\t#if FEATURE_DOF\r\n\t\t{\r\n\r\n\t\t\t// depth of field\r\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\r\n\r\n\t\t\t// get the aperture sample\r\n\t\t\t// if blades === 0 then we assume a circle\r\n\t\t\tvec3 shapeUVW= rand3( 1 );\r\n\t\t\tint blades = physicalCamera.apertureBlades;\r\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\r\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\r\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\r\n\r\n\t\t\t// rotate the aperture shape\r\n\t\t\tapertureSample =\r\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\r\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\r\n\r\n\t\t\t// create the new ray\r\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\r\n\t\t\tray.direction = focalPoint - ray.origin;\r\n\r\n\t\t}\r\n\t\t#endif\r\n\r\n\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\treturn ray;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"eZnIg\", function(module, exports) {\n\n$parcel$export(module.exports, \"direct_light_contribution_function\", () => $ae99281879ede2b8$export$dfc473f79b3116e1);\nconst $ae99281879ede2b8$export$dfc473f79b3116e1 = /*glsl*/ `\r\n\r\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\r\n\r\n\t\tvec3 result = vec3( 0.0 );\r\n\r\n\t\t// uniformly pick a light or environment map\r\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\r\n\r\n\t\t\t// sample a light or environment\r\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\r\n\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tlightRec.pdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the light area\r\n\t\t\tRay lightRay;\r\n\t\t\tlightRay.origin = rayOrigin;\r\n\t\t\tlightRay.direction = lightRec.direction;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tlightRec.pdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\r\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\r\n\r\n\t\t\t// find a sample in the environment map to include in the contribution\r\n\t\t\tvec3 envColor, envDirection;\r\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\r\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\r\n\r\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\r\n\t\t\t// results so we ignore the sample in this case.\r\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tenvPdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the surface\r\n\t\t\tRay envRay;\r\n\t\t\tenvRay.origin = rayOrigin;\r\n\t\t\tenvRay.direction = envDirection;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tenvPdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tenvPdf /= lightsDenom;\r\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\r\n\t\t// See issue #470\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"bwtQK\", function(module, exports) {\n\n$parcel$export(module.exports, \"get_surface_record_function\", () => $8639d66b89a7dedc$export$4b59180d6e57d4f);\nconst $8639d66b89a7dedc$export$4b59180d6e57d4f = /* glsl */ `\r\n\r\n\t#define SKIP_SURFACE 0\r\n\t#define HIT_SURFACE 1\r\n\tint getSurfaceRecord(\r\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\r\n\t\tfloat accumulatedRoughness,\r\n\t\tinout SurfaceRecord surf\r\n\t) {\r\n\r\n\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\r\n\r\n\t\t\tSurfaceRecord fogSurface;\r\n\t\t\tfogSurface.volumeParticle = true;\r\n\t\t\tfogSurface.color = material.color;\r\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\r\n\t\t\tfogSurface.normal = normal;\r\n\t\t\tfogSurface.faceNormal = normal;\r\n\t\t\tfogSurface.clearcoatNormal = normal;\r\n\r\n\t\t\tsurf = fogSurface;\r\n\t\t\treturn HIT_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// uv coord for textures\r\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t// albedo\r\n\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\talbedo *= vertexColor;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMap\r\n\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t}\r\n\r\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\r\n\t\t// and it's single sided.\r\n\t\t// - alpha test is disabled when it === 0\r\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\r\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\r\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\r\n\t\tfloat alphaTest = material.alphaTest;\r\n\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\tif (\r\n\t\t\t// material sidedness\r\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\r\n\r\n\t\t\t// alpha test\r\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t// opacity\r\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\r\n\t\t) {\r\n\r\n\t\t\treturn SKIP_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// fetch the interpolated smooth normal\r\n\t\tvec3 normal = normalize( textureSampleBarycoord(\r\n\t\t\tattributesArray,\r\n\t\t\tATTR_NORMAL,\r\n\t\t\tsurfaceHit.barycoord,\r\n\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t).xyz );\r\n\r\n\t\t// roughness\r\n\t\tfloat roughness = material.roughness;\r\n\t\tif ( material.roughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\r\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// metalness\r\n\t\tfloat metalness = material.metalness;\r\n\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t}\r\n\r\n\t\t// emission\r\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\r\n\t\tif ( material.emissiveMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\r\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tfloat transmission = material.transmission;\r\n\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// normal\r\n\t\tif ( material.flatShading ) {\r\n\r\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\r\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\r\n\t\t\t// interpolated vertex normals.\r\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 baseNormal = normal;\r\n\t\tif ( material.normalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.normalScale;\r\n\t\t\t\tnormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnormal *= surfaceHit.side;\r\n\r\n\t\t// clearcoat\r\n\t\tfloat clearcoat = material.clearcoat;\r\n\t\tif ( material.clearcoatMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatRoughness\r\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\r\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatNormal\r\n\t\tvec3 clearcoatNormal = baseNormal;\r\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\r\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclearcoatNormal *= surfaceHit.side;\r\n\r\n\t\t// sheenColor\r\n\t\tvec3 sheenColor = material.sheenColor;\r\n\t\tif ( material.sheenColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// sheenRoughness\r\n\t\tfloat sheenRoughness = material.sheenRoughness;\r\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence = material.iridescence;\r\n\t\tif ( material.iridescenceMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\r\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence thickness\r\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\r\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\r\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\r\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\r\n\r\n\t\t}\r\n\r\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\r\n\r\n\t\t// specular color\r\n\t\tvec3 specularColor = material.specularColor;\r\n\t\tif ( material.specularColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// specular intensity\r\n\t\tfloat specularIntensity = material.specularIntensity;\r\n\t\tif ( material.specularIntensityMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\tsurf.volumeParticle = false;\r\n\r\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\r\n\t\tsurf.normal = normal;\r\n\r\n\t\tsurf.metalness = metalness;\r\n\t\tsurf.color = albedo.rgb;\r\n\t\tsurf.emission = emission;\r\n\r\n\t\tsurf.ior = material.ior;\r\n\t\tsurf.transmission = transmission;\r\n\t\tsurf.thinFilm = material.thinFilm;\r\n\t\tsurf.attenuationColor = material.attenuationColor;\r\n\t\tsurf.attenuationDistance = material.attenuationDistance;\r\n\r\n\t\tsurf.clearcoatNormal = clearcoatNormal;\r\n\t\tsurf.clearcoat = clearcoat;\r\n\r\n\t\tsurf.sheen = material.sheen;\r\n\t\tsurf.sheenColor = sheenColor;\r\n\r\n\t\tsurf.iridescence = iridescence;\r\n\t\tsurf.iridescenceIor = material.iridescenceIor;\r\n\t\tsurf.iridescenceThickness = iridescenceThickness;\r\n\r\n\t\tsurf.specularColor = specularColor;\r\n\t\tsurf.specularIntensity = specularIntensity;\r\n\r\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\r\n\t\t// applied by its brdf function\r\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\r\n\t\tsurf.roughness = roughness * roughness;\r\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\r\n\t\tsurf.sheenRoughness = sheenRoughness;\r\n\r\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\r\n\t\t// then we can just always assume this is a front face.\r\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\r\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\r\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\r\n\r\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\r\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\r\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\r\n\t\t// sharp internal reflections\r\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\r\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\r\n\r\n\t\t// get the normal frames\r\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\r\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\r\n\r\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\r\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\r\n\r\n\t\treturn HIT_SURFACE;\r\n\r\n\t}\r\n`;\n\n});\n\nparcelRegister(\"ioRiK\", function(module, exports) {\n\n$parcel$export(module.exports, \"render_structs\", () => $d653d06e472927b5$export$dd7d5457c7c15273);\nconst $d653d06e472927b5$export$dd7d5457c7c15273 = /* glsl */ `\r\n\r\n\tstruct Ray {\r\n\r\n\t\tvec3 origin;\r\n\t\tvec3 direction;\r\n\r\n\t};\r\n\r\n\tstruct SurfaceHit {\r\n\r\n\t\tuvec4 faceIndices;\r\n\t\tvec3 barycoord;\r\n\t\tvec3 faceNormal;\r\n\t\tfloat side;\r\n\t\tfloat dist;\r\n\r\n\t};\r\n\r\n\tstruct RenderState {\r\n\r\n\t\tbool firstRay;\r\n\t\tbool transmissiveRay;\r\n\t\tbool isShadowRay;\r\n\t\tfloat accumulatedRoughness;\r\n\t\tint transmissiveTraversals;\r\n\t\tint traversals;\r\n\t\tuint depth;\r\n\t\tvec3 throughputColor;\r\n\t\tMaterial fogMaterial;\r\n\r\n\t};\r\n\r\n\tRenderState initRenderState() {\r\n\r\n\t\tRenderState result;\r\n\t\tresult.firstRay = true;\r\n\t\tresult.transmissiveRay = true;\r\n\t\tresult.isShadowRay = false;\r\n\t\tresult.accumulatedRoughness = 0.0;\r\n\t\tresult.transmissiveTraversals = 0;\r\n\t\tresult.traversals = 0;\r\n\t\tresult.throughputColor = vec3( 1.0 );\r\n\t\tresult.depth = 0u;\r\n\t\tresult.fogMaterial.fogVolume = false;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"euI5d\", function(module, exports) {\n\n$parcel$export(module.exports, \"trace_scene_function\", () => $a8d61006286aaacf$export$32c6608be890cd25);\nconst $a8d61006286aaacf$export$32c6608be890cd25 = /* glsl */ `\r\n\r\n\t#define NO_HIT 0\r\n\t#define SURFACE_HIT 1\r\n\t#define LIGHT_HIT 2\r\n\t#define FOG_HIT 3\r\n\r\n\t// Passing the global variable 'lights' into this function caused shader program errors.\r\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\r\n\t// For more information, refer to: https://github.com/disini/three-gpu-pathtracer/pull/457\r\n\tint traceScene(\r\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\r\n\t) {\r\n\r\n\t\tint result = NO_HIT;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\r\n\r\n\t\t#if FEATURE_FOG\r\n\r\n\t\tif ( fogMaterial.fogVolume ) {\r\n\r\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\r\n\t\t\t// as other objects\r\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\r\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\r\n\r\n\t\t\t\tsurfaceHit.side = 1.0;\r\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\r\n\t\t\t\tsurfaceHit.dist = particleDist;\r\n\t\t\t\treturn FOG_HIT;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t\tif ( hit ) {\r\n\r\n\t\t\tresult = SURFACE_HIT;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\n\n\n\n//# sourceMappingURL=areaLight.5654e8b2.js.map\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending, Vector4, NearestFilter } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { BlendMaterial } from '../materials/fullscreen/BlendMaterial.js';\r\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\r\nimport { PhysicalPathTracingMaterial } from '../materials/pathtracing/PhysicalPathTracingMaterial.js';\r\n\r\nfunction* renderTask() {\r\n\r\n\tconst {\r\n\t\t_renderer,\r\n\t\t_fsQuad,\r\n\t\t_blendQuad,\r\n\t\t_primaryTarget,\r\n\t\t_blendTargets,\r\n\t\t_sobolTarget,\r\n\t\t_subframe,\r\n\t\talpha,\r\n\t\tmaterial,\r\n\t} = this;\r\n\tconst _ogScissor = new Vector4();\r\n\tconst _ogViewport = new Vector4();\r\n\r\n\tconst blendMaterial = _blendQuad.material;\r\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\tblendMaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NoBlending;\r\n\t\t\tmaterial.opacity = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NormalBlending;\r\n\r\n\t\t}\r\n\r\n\t\tconst [ subX, subY, subW, subH ] = _subframe;\r\n\r\n\t\tconst w = _primaryTarget.width;\r\n\t\tconst h = _primaryTarget.height;\r\n\t\tmaterial.resolution.set( w * subW, h * subH );\r\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\r\n\t\tmaterial.stratifiedTexture.init( 20, material.bounces + material.transmissiveBounces + 5 );\r\n\t\tmaterial.stratifiedTexture.next();\r\n\t\tmaterial.seed ++;\r\n\r\n\t\tconst tilesX = this.tiles.x || 1;\r\n\t\tconst tilesY = this.tiles.y || 1;\r\n\t\tconst totalTiles = tilesX * tilesY;\r\n\r\n\t\tconst pxSubW = Math.ceil( w * subW );\r\n\t\tconst pxSubH = Math.ceil( h * subH );\r\n\t\tconst pxSubX = Math.floor( subX * w );\r\n\t\tconst pxSubY = Math.floor( subY * h );\r\n\r\n\t\tconst pxTileW = Math.ceil( pxSubW / tilesX );\r\n\t\tconst pxTileH = Math.ceil( pxSubH / tilesY );\r\n\r\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\r\n\r\n\t\t\t\t// store og state\r\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\r\n\t\t\t\tconst ogScissorTest = _renderer.getScissorTest();\r\n\t\t\t\t_renderer.getScissor( _ogScissor );\r\n\t\t\t\t_renderer.getViewport( _ogViewport );\r\n\r\n\t\t\t\tlet tx = x;\r\n\t\t\t\tlet ty = y;\r\n\t\t\t\tif ( ! this.stableTiles ) {\r\n\r\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\r\n\t\t\t\t\ttx = tileIndex % tilesX;\r\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\r\n\r\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// set the scissor and the viewport on the render target\r\n\t\t\t\t// note that when using the webgl renderer set viewport the device pixel ratio\r\n\t\t\t\t// is multiplied into the field causing some pixels to not be rendered\r\n\t\t\t\tconst reverseTy = tilesY - ty - 1;\r\n\t\t\t\t_primaryTarget.scissor.set(\r\n\t\t\t\t\tpxSubX + tx * pxTileW,\r\n\t\t\t\t\tpxSubY + reverseTy * pxTileH,\r\n\t\t\t\t\tMath.min( pxTileW, pxSubW - tx * pxTileW ),\r\n\t\t\t\t\tMath.min( pxTileH, pxSubH - reverseTy * pxTileH ),\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_primaryTarget.viewport.set(\r\n\t\t\t\t\tpxSubX,\r\n\t\t\t\t\tpxSubY,\r\n\t\t\t\t\tpxSubW,\r\n\t\t\t\t\tpxSubH,\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\r\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t\t\t_renderer.setScissorTest( true );\r\n\r\n\t\t\t\t_renderer.autoClear = false;\r\n\t\t\t\t_fsQuad.render( _renderer );\r\n\r\n\t\t\t\t// reset original renderer state\r\n\t\t\t\t_renderer.setViewport( _ogViewport );\r\n\t\t\t\t_renderer.setScissor( _ogScissor );\r\n\t\t\t\t_renderer.setScissorTest( ogScissorTest );\r\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\t\t\t\t_renderer.autoClear = ogAutoClear;\r\n\r\n\t\t\t\t// swap and blend alpha targets\r\n\t\t\t\tif ( alpha ) {\r\n\r\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\r\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\r\n\r\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\r\n\t\t\t\t\t_blendQuad.render( _renderer );\r\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.samples += ( 1 / totalTiles );\r\n\r\n\t\t\t\t// round the samples value if we've finished the tiles\r\n\t\t\t\tif ( x === tilesX - 1 && y === tilesY - 1 ) {\r\n\r\n\t\t\t\t\tthis.samples = Math.round( this.samples );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tyield;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst ogClearColor = new Color();\r\nexport class PathTracingRenderer {\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._fsQuad.material;\r\n\r\n\t}\r\n\r\n\tset material( v ) {\r\n\r\n\t\tthis._fsQuad.material.removeEventListener( 'recompilation', this._compileFunction );\r\n\t\tv.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t\tthis._fsQuad.material = v;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\r\n\r\n\t}\r\n\r\n\tset alpha( v ) {\r\n\r\n\t\tif ( this._alpha === v ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! v ) {\r\n\r\n\t\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\t\tthis._blendTargets[ 1 ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis._alpha = v;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tget alpha() {\r\n\r\n\t\treturn this._alpha;\r\n\r\n\t}\r\n\r\n\tget isCompiling() {\r\n\r\n\t\treturn Boolean( this._compilePromise );\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.camera = null;\r\n\t\tthis.tiles = new Vector2( 3, 3 );\r\n\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.stableTiles = true;\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._subframe = new Vector4( 0, 0, 1, 1 );\r\n\t\tthis._opacityFactor = 1.0;\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._alpha = false;\r\n\t\tthis._fsQuad = new FullScreenQuad( new PhysicalPathTracingMaterial() );\r\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\r\n\t\tthis._task = null;\r\n\t\tthis._currentTile = 0;\r\n\t\tthis._compilePromise = null;\r\n\r\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\r\n\r\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t} );\r\n\t\tthis._blendTargets = [\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t];\r\n\r\n\t\t// function for listening to for triggered compilation so we can wait for compilation to finish\r\n\t\t// before starting to render\r\n\t\tthis._compileFunction = () => {\r\n\r\n\t\t\tconst promise = this.compileMaterial( this._fsQuad._mesh );\r\n\t\t\tpromise.then( () => {\r\n\r\n\t\t\t\tif ( this._compilePromise === promise ) {\r\n\r\n\t\t\t\t\tthis._compilePromise = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tthis._compilePromise = promise;\r\n\r\n\t\t};\r\n\r\n\t\tthis.material.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t}\r\n\r\n\tcompileMaterial() {\r\n\r\n\t\treturn this._renderer.compileAsync( this._fsQuad._mesh );\r\n\r\n\t}\r\n\r\n\tsetCamera( camera ) {\r\n\r\n\t\tconst { material } = this;\r\n\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\r\n\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\r\n\t\tmaterial.physicalCamera.updateFrom( camera );\r\n\r\n\t\t// Perspective camera (default)\r\n\t\tlet cameraType = 0;\r\n\r\n\t\t// An orthographic projection matrix will always have the bottom right element == 1\r\n\t\t// And a perspective projection matrix will always have the bottom right element == 0\r\n\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\r\n\r\n\t\t\t// Orthographic\r\n\t\t\tcameraType = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( camera.isEquirectCamera ) {\r\n\r\n\t\t\t// Equirectangular\r\n\t\t\tcameraType = 2;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\r\n\r\n\t\tthis.camera = camera;\r\n\r\n\t}\r\n\r\n\tsetSize( w, h ) {\r\n\r\n\t\tw = Math.ceil( w );\r\n\t\th = Math.ceil( h );\r\n\r\n\t\tif ( this._primaryTarget.width === w && this._primaryTarget.height === h ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis._primaryTarget.setSize( w, h );\r\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\r\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tgetSize( target ) {\r\n\r\n\t\ttarget.x = this._primaryTarget.width;\r\n\t\ttarget.y = this._primaryTarget.height;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._primaryTarget.dispose();\r\n\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\tthis._blendTargets[ 1 ].dispose();\r\n\t\tthis._sobolTarget.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\t\tthis._blendQuad.dispose();\r\n\t\tthis._task = null;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\r\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.getClearColor( ogClearColor );\r\n\r\n\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\r\n\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._task = null;\r\n\r\n\t\tthis.material.stratifiedTexture.stableNoise = this.stableNoise;\r\n\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\tthis.material.seed = 0;\r\n\t\t\tthis.material.stratifiedTexture.reset();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\t// ensure we've updated our defines before rendering so we can ensure we\r\n\t\t// can wait for compilation to finish\r\n\t\tthis.material.onBeforeRender();\r\n\t\tif ( this.isCompiling ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this._task ) {\r\n\r\n\t\t\tthis._task = renderTask.call( this );\r\n\r\n\t\t}\r\n\r\n\t\tthis._task.next();\r\n\r\n\t}\r\n\r\n}\r\n","import { NoBlending } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\n\r\nexport class BlendMaterial extends MaterialBase {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\ttarget1: { value: null },\r\n\t\t\t\ttarget2: { value: null },\r\n\t\t\t\topacity: { value: 1.0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tuniform sampler2D target1;\r\n\t\t\t\tuniform sampler2D target2;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\r\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\r\n\r\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\r\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\r\n\r\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\r\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { MaterialBase } from '../materials/MaterialBase.js';\r\nimport { sobol_common, sobol_point_generation } from '../shader/rand/sobol.glsl.js';\r\n\r\nclass SobolNumbersMaterial extends MaterialBase {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t${ sobol_common }\r\n\t\t\t\t${ sobol_point_generation }\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\r\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class SobolNumberMapGenerator {\r\n\r\n\tgenerate( renderer, dimensions = 256 ) {\r\n\r\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\r\n\r\n\t\t\ttype: FloatType,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tgenerateMipmaps: false,\r\n\r\n\t\t} );\r\n\r\n\t\tconst ogTarget = renderer.getRenderTarget();\r\n\t\trenderer.setRenderTarget( target );\r\n\r\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\r\n\t\tquad.material.resolution.set( dimensions, dimensions );\r\n\t\tquad.render( renderer );\r\n\r\n\t\trenderer.setRenderTarget( ogTarget );\r\n\t\tquad.dispose();\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n","// References\r\n// - https://jcgt.org/published/0009/04/01/\r\n// - Code from https://www.shadertoy.com/view/WtGyDm\r\n\r\n// functions to generate multi-dimensions variables of the same functions\r\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\r\nfunction generateSobolFunctionVariants( dim = 1 ) {\r\n\r\n\tlet type = 'uint';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\ttype = 'uvec' + dim;\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\t\t${ type } sobolReverseBits( ${ type } x ) {\r\n\r\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\r\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\r\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\r\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\r\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\r\n\r\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx += seed;\r\n\t\t\tx ^= x * 0x6c50b47cu;\r\n\t\t\tx ^= x * 0xb82f1e52u;\r\n\t\t\tx ^= x * 0xc7afe638u;\r\n\t\t\tx ^= x * 0x8d22f6e6u;\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\r\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\r\n\t\t\tx = sobolReverseBits( x );\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nfunction generateSobolSampleFunctions( dim = 1 ) {\r\n\r\n\tlet utype = 'uint';\r\n\tlet vtype = 'float';\r\n\tlet num = '';\r\n\tlet components = '.r';\r\n\tlet combineValues = '1u';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\tutype = 'uvec' + dim;\r\n\t\tvtype = 'vec' + dim;\r\n\t\tnum = dim + '';\r\n\t\tif ( dim === 2 ) {\r\n\r\n\t\t\tcomponents = '.rg';\r\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\r\n\r\n\t\t} else if ( dim === 3 ) {\r\n\r\n\t\t\tcomponents = '.rgb';\r\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcomponents = '';\r\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\r\n\t\t${ vtype } sobol${ num }( int effect ) {\r\n\r\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\r\n\t\t\tuint index = sobolPathIndex;\r\n\r\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\r\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\r\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\r\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\r\n\r\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\r\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\r\n\r\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nexport const sobol_common = /* glsl */`\r\n\r\n\t// Utils\r\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\r\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\r\n\r\n\t${ generateSobolFunctionVariants( 1 ) }\r\n\t${ generateSobolFunctionVariants( 2 ) }\r\n\t${ generateSobolFunctionVariants( 3 ) }\r\n\t${ generateSobolFunctionVariants( 4 ) }\r\n\r\n\tuint sobolHash( uint x ) {\r\n\r\n\t\t// finalizer from murmurhash3\r\n\t\tx ^= x >> 16;\r\n\t\tx *= 0x85ebca6bu;\r\n\t\tx ^= x >> 13;\r\n\t\tx *= 0xc2b2ae35u;\r\n\t\tx ^= x >> 16;\r\n\t\treturn x;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_point_generation = /* glsl */`\r\n\r\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\r\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\r\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\r\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\r\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\r\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\r\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\r\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\r\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\r\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\r\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\r\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\r\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\r\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\r\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\r\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\r\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\r\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\r\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\r\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\r\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\r\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\r\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\r\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\r\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\r\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\r\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\r\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\r\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\r\n\t);\r\n\r\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\r\n\r\n\t\tuint X = 0u;\r\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\r\n\r\n\t\t\tuint mask = ( index >> bit ) & 1u;\r\n\t\t\tX ^= mask * directions[ bit ];\r\n\r\n\t\t}\r\n\t\treturn X;\r\n\r\n\t}\r\n\r\n\tvec4 generateSobolPoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\treturn vec4( 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\t// NOTE: this sobol \"direction\" is also available but we can't write out 5 components\r\n\t\t// uint x = index & 0x00ffffffu;\r\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\r\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\r\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\r\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\r\n\r\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_functions = /* glsl */`\r\n\r\n\t// Seeds\r\n\tuniform sampler2D sobolTexture;\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\r\n\tuint sobolGetSeed( uint bounce, uint effect ) {\r\n\r\n\t\treturn sobolHash(\r\n\t\t\tsobolHashCombine(\r\n\t\t\t\tsobolHashCombine(\r\n\t\t\t\t\tsobolHash( bounce ),\r\n\t\t\t\t\tsobolPixelIndex\r\n\t\t\t\t),\r\n\t\t\t\teffect\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tvec4 sobolGetTexturePoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\tindex = index % SOBOL_MAX_POINTS;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\r\n\t\tuint y = index / dim.x;\r\n\t\tuint x = index - y * dim.x;\r\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\r\n\t\treturn texture( sobolTexture, uv );\r\n\r\n\t}\r\n\r\n\t${ generateSobolSampleFunctions( 1 ) }\r\n\t${ generateSobolSampleFunctions( 2 ) }\r\n\t${ generateSobolSampleFunctions( 3 ) }\r\n\t${ generateSobolSampleFunctions( 4 ) }\r\n\r\n`;\r\n","import { ClampToEdgeWrapping, HalfFloatType, Matrix4, Vector2 } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\nimport {\r\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\r\n\tBVHShaderGLSL,\r\n} from 'three-mesh-bvh';\r\n\r\n// uniforms\r\nimport { PhysicalCameraUniform } from '../../uniforms/PhysicalCameraUniform.js';\r\nimport { EquirectHdrInfoUniform } from '../../uniforms/EquirectHdrInfoUniform.js';\r\nimport { LightsInfoUniformStruct } from '../../uniforms/LightsInfoUniformStruct.js';\r\nimport { AttributesTextureArray } from '../../uniforms/AttributesTextureArray.js';\r\nimport { MaterialsTexture, MATERIAL_PIXELS } from '../../uniforms/MaterialsTexture.js';\r\nimport { RenderTarget2DArray } from '../../uniforms/RenderTarget2DArray.js';\r\nimport { StratifiedSamplesTexture } from '../../uniforms/StratifiedSamplesTexture.js';\r\nimport { BlueNoiseTexture } from '../../textures/BlueNoiseTexture.js';\r\n\r\n// general glsl\r\nimport * as StructsGLSL from '../../shader/structs/index.js';\r\nimport * as SamplingGLSL from '../../shader/sampling/index.js';\r\nimport * as CommonGLSL from '../../shader/common/index.js';\r\nimport * as RandomGLSL from '../../shader/rand/index.js';\r\nimport * as BSDFGLSL from '../../shader/bsdf/index.js';\r\nimport * as PTBVHGLSL from '../../shader/bvh/index.js';\r\n\r\n// path tracer glsl\r\nimport * as RenderGLSL from './glsl/index.js';\r\n\r\nexport class PhysicalPathTracingMaterial extends MaterialBase {\r\n\r\n\tonBeforeRender() {\r\n\r\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\r\n\t\tthis.setDefine( 'FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0 );\r\n\t\tthis.setDefine( 'FEATURE_FOG', this.materials.features.isUsed( 'FOG' ) ? 1 : 0 );\r\n\r\n\t}\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthWrite: false,\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\tFEATURE_MIS: 1,\r\n\t\t\t\tFEATURE_RUSSIAN_ROULETTE: 1,\r\n\t\t\t\tFEATURE_DOF: 1,\r\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\r\n\t\t\t\tFEATURE_FOG: 1,\r\n\r\n\t\t\t\t// 0 = PCG\r\n\t\t\t\t// 1 = Sobol\r\n\t\t\t\t// 2 = Stratified List\r\n\t\t\t\tRANDOM_TYPE: 2,\r\n\r\n\t\t\t\t// 0 = Perspective\r\n\t\t\t\t// 1 = Orthographic\r\n\t\t\t\t// 2 = Equirectangular\r\n\t\t\t\tCAMERA_TYPE: 0,\r\n\r\n\t\t\t\tDEBUG_MODE: 0,\r\n\r\n\t\t\t\tATTR_NORMAL: 0,\r\n\t\t\t\tATTR_TANGENT: 1,\r\n\t\t\t\tATTR_UV: 2,\r\n\t\t\t\tATTR_COLOR: 3,\r\n\t\t\t\tMATERIAL_PIXELS: MATERIAL_PIXELS,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\t// path trace uniforms\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\t\t\t\topacity: { value: 1 },\r\n\t\t\t\tbounces: { value: 10 },\r\n\t\t\t\ttransmissiveBounces: { value: 10 },\r\n\t\t\t\tfilterGlossyFactor: { value: 0 },\r\n\r\n\t\t\t\t// camera uniforms\r\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\r\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\r\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\r\n\r\n\t\t\t\t// scene uniforms\r\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\r\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\r\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\r\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\r\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\r\n\r\n\t\t\t\t// light uniforms\r\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\r\n\t\t\t\tiesProfiles: { value: new RenderTarget2DArray( 360, 180, {\r\n\t\t\t\t\ttype: HalfFloatType,\r\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\r\n\t\t\t\t\twrapT: ClampToEdgeWrapping,\r\n\t\t\t\t} ).texture },\r\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\r\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\r\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\r\n\r\n\t\t\t\t// background uniforms\r\n\t\t\t\tbackgroundBlur: { value: 0.0 },\r\n\t\t\t\tbackgroundMap: { value: null },\r\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\r\n\t\t\t\tbackgroundIntensity: { value: 1.0 },\r\n\t\t\t\tbackgroundRotation: { value: new Matrix4() },\r\n\r\n\t\t\t\t// randomness uniforms\r\n\t\t\t\tseed: { value: 0 },\r\n\t\t\t\tsobolTexture: { value: null },\r\n\t\t\t\tstratifiedTexture: { value: new StratifiedSamplesTexture() },\r\n\t\t\t\tstratifiedOffsetTexture: { value: new BlueNoiseTexture( 64, 1 ) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\r\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define RAY_OFFSET 1e-4\r\n\t\t\t\t#define INFINITY 1e20\r\n\r\n\t\t\t\tprecision highp isampler2D;\r\n\t\t\t\tprecision highp usampler2D;\r\n\t\t\t\tprecision highp sampler2DArray;\r\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\t// bvh intersection\r\n\t\t\t\t${ BVHShaderGLSL.common_functions }\r\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\r\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\r\n\r\n\t\t\t\t// uniform structs\r\n\t\t\t\t${ StructsGLSL.camera_struct }\r\n\t\t\t\t${ StructsGLSL.lights_struct }\r\n\t\t\t\t${ StructsGLSL.equirect_struct }\r\n\t\t\t\t${ StructsGLSL.material_struct }\r\n\t\t\t\t${ StructsGLSL.surface_record_struct }\r\n\r\n\t\t\t\t// random\r\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\r\n\r\n\t\t\t\t\t${ RandomGLSL.stratified_functions }\r\n\r\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\r\n\r\n\t\t\t\t\t${ RandomGLSL.pcg_functions }\r\n\t\t\t\t\t${ RandomGLSL.sobol_common }\r\n\t\t\t\t\t${ RandomGLSL.sobol_functions }\r\n\r\n\t\t\t\t\t#define rand(v) sobol(v)\r\n\t\t\t\t\t#define rand2(v) sobol2(v)\r\n\t\t\t\t\t#define rand3(v) sobol3(v)\r\n\t\t\t\t\t#define rand4(v) sobol4(v)\r\n\r\n\t\t\t\t#else \t\t\t\t\t// PCG\r\n\r\n\t\t\t\t${ RandomGLSL.pcg_functions }\r\n\r\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\r\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\r\n\t\t\t\t\tuint sobolPixelIndex = 0u;\r\n\t\t\t\t\tuint sobolPathIndex = 0u;\r\n\t\t\t\t\tuint sobolBounceIndex = 0u;\r\n\r\n\t\t\t\t\t#define rand(v) pcgRand()\r\n\t\t\t\t\t#define rand2(v) pcgRand2()\r\n\t\t\t\t\t#define rand3(v) pcgRand3()\r\n\t\t\t\t\t#define rand4(v) pcgRand4()\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// common\r\n\t\t\t\t${ CommonGLSL.texture_sample_functions }\r\n\t\t\t\t${ CommonGLSL.fresnel_functions }\r\n\t\t\t\t${ CommonGLSL.util_functions }\r\n\t\t\t\t${ CommonGLSL.math_functions }\r\n\t\t\t\t${ CommonGLSL.shape_intersection_functions }\r\n\r\n\t\t\t\t// environment\r\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\r\n\t\t\t\tuniform mat4 environmentRotation;\r\n\t\t\t\tuniform float environmentIntensity;\r\n\r\n\t\t\t\t// lighting\r\n\t\t\t\tuniform sampler2DArray iesProfiles;\r\n\t\t\t\tuniform LightsInfo lights;\r\n\r\n\t\t\t\t// background\r\n\t\t\t\tuniform float backgroundBlur;\r\n\t\t\t\tuniform float backgroundAlpha;\r\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\tuniform sampler2D backgroundMap;\r\n\t\t\t\tuniform mat4 backgroundRotation;\r\n\t\t\t\tuniform float backgroundIntensity;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// camera\r\n\t\t\t\tuniform mat4 cameraWorldMatrix;\r\n\t\t\t\tuniform mat4 invProjectionMatrix;\r\n\t\t\t\t#if FEATURE_DOF\r\n\r\n\t\t\t\tuniform PhysicalCamera physicalCamera;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// geometry\r\n\t\t\t\tuniform sampler2DArray attributesArray;\r\n\t\t\t\tuniform usampler2D materialIndexAttribute;\r\n\t\t\t\tuniform sampler2D materials;\r\n\t\t\t\tuniform sampler2DArray textures;\r\n\t\t\t\tuniform BVH bvh;\r\n\r\n\t\t\t\t// path tracer\r\n\t\t\t\tuniform int bounces;\r\n\t\t\t\tuniform int transmissiveBounces;\r\n\t\t\t\tuniform float filterGlossyFactor;\r\n\t\t\t\tuniform int seed;\r\n\r\n\t\t\t\t// image\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t// globals\r\n\t\t\t\tmat3 envRotation3x3;\r\n\t\t\t\tmat3 invEnvRotation3x3;\r\n\t\t\t\tfloat lightsDenom;\r\n\r\n\t\t\t\t// sampling\r\n\t\t\t\t${ SamplingGLSL.shape_sampling_functions }\r\n\t\t\t\t${ SamplingGLSL.equirect_functions }\r\n\t\t\t\t${ SamplingGLSL.light_sampling_functions }\r\n\r\n\t\t\t\t${ PTBVHGLSL.inside_fog_volume_function }\r\n\t\t\t\t${ BSDFGLSL.ggx_functions }\r\n\t\t\t\t${ BSDFGLSL.sheen_functions }\r\n\t\t\t\t${ BSDFGLSL.iridescence_functions }\r\n\t\t\t\t${ BSDFGLSL.fog_functions }\r\n\t\t\t\t${ BSDFGLSL.bsdf_functions }\r\n\r\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\r\n\r\n\t\t\t\t\treturn clamp(\r\n\t\t\t\t\t\tmax(\r\n\t\t\t\t\t\t\troughness,\r\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\r\n\t\t\t\t\t\t0.0,\r\n\t\t\t\t\t\t1.0\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\r\n\r\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\r\n\r\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\r\n\t\t\t\t\treturn backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\r\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t${ RenderGLSL.render_structs }\r\n\t\t\t\t${ RenderGLSL.camera_util_functions }\r\n\t\t\t\t${ RenderGLSL.trace_scene_function }\r\n\t\t\t\t${ RenderGLSL.attenuate_hit_function }\r\n\t\t\t\t${ RenderGLSL.direct_light_contribution_function }\r\n\t\t\t\t${ RenderGLSL.get_surface_record_function }\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t// init\r\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\r\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\r\n\t\t\t\t\tsobolPathIndex = uint( seed );\r\n\r\n\t\t\t\t\t// get camera ray\r\n\t\t\t\t\tRay ray = getCameraRay();\r\n\r\n\t\t\t\t\t// inverse environment rotation\r\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\r\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\r\n\t\t\t\t\tlightsDenom =\r\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\r\n\t\t\t\t\t\t\tfloat( lights.count ) :\r\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\r\n\r\n\t\t\t\t\t// final color\r\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\r\n\r\n\t\t\t\t\t// surface results\r\n\t\t\t\t\tSurfaceHit surfaceHit;\r\n\t\t\t\t\tScatterRecord scatterRec;\r\n\r\n\t\t\t\t\t// path tracing state\r\n\t\t\t\t\tRenderState state = initRenderState();\r\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\r\n\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\r\n\t\t\t\t\t\tray.origin, - ray.direction,\r\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\r\n\t\t\t\t\t\tstate.fogMaterial\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\r\n\r\n\t\t\t\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\t\t\t\tstate.depth ++;\r\n\t\t\t\t\t\tstate.traversals = bounces - i;\r\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\r\n\r\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\r\n\r\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\r\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\r\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\r\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\tLightRecord lightRec;\r\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\r\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\r\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\r\n\t\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the contribution\r\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\r\n\r\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\r\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\r\n\t\t\t\t\t\t\t\tvec3 envColor;\r\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\r\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\r\n\r\n\t\t\t\t\t\t\t\t// and weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\r\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\r\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\r\n\r\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\r\n\r\n\t\t\t\t\t\t\tstate.fogMaterial = material;\r\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// early out if this is a matte material\r\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\r\n\r\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\r\n\t\t\t\t\t\t// then skip it\r\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tSurfaceRecord surf;\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgetSurfaceRecord(\r\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\r\n\t\t\t\t\t\t\t\tsurf\r\n\t\t\t\t\t\t\t) == SKIP_SURFACE\r\n\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\r\n\t\t\t\t\t\t\t// crash the context with too long a loop.\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\r\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\r\n\r\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\r\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t// next event estimation\r\n\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\r\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\r\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\r\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\r\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// accumulate emissive color\r\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\r\n\r\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\r\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\r\n\t\t\t\t\t\t// perform this separate from a bounce\r\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\r\n\t\t\t\t\t\t\ti --;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// handle throughput color transformation\r\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\r\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\r\n\r\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\r\n\r\n\t\t\t\t\t\t// russian roulette path termination\r\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\r\n\t\t\t\t\t\tuint minBounces = 3u;\r\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\r\n\r\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\r\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\r\n\t\t\t\t\t\trrProb = sqrt( rrProb );\r\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\r\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\r\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\r\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\r\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\r\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// prepare for next ray\r\n\t\t\t\t\t\tray.direction = scatterRec.direction;\r\n\t\t\t\t\t\tray.origin = hitPoint;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t\t#if DEBUG_MODE == 1\r\n\r\n\t\t\t\t\t// output the number of rays checked in the path and number of\r\n\t\t\t\t\t// transmissive rays encountered.\r\n\t\t\t\t\tgl_FragColor.rgb = vec3(\r\n\t\t\t\t\t\tfloat( state.depth ),\r\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\r\n\t\t\t\t\t\t0.0\r\n\t\t\t\t\t);\r\n\t\t\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { PhysicalCamera } from '../objects/PhysicalCamera.js';\r\nexport class PhysicalCameraUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.bokehSize = 0;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 10;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tupdateFrom( camera ) {\r\n\r\n\t\tif ( camera instanceof PhysicalCamera ) {\r\n\r\n\t\t\tthis.bokehSize = camera.bokehSize;\r\n\t\t\tthis.apertureBlades = camera.apertureBlades;\r\n\t\t\tthis.apertureRotation = camera.apertureRotation;\r\n\t\t\tthis.focusDistance = camera.focusDistance;\r\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.bokehSize = 0;\r\n\t\t\tthis.apertureRotation = 0;\r\n\t\t\tthis.apertureBlades = 0;\r\n\t\t\tthis.focusDistance = 10;\r\n\t\t\tthis.anamorphicRatio = 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { PerspectiveCamera } from 'three';\r\n\r\nexport class PhysicalCamera extends PerspectiveCamera {\r\n\r\n\tset bokehSize( size ) {\r\n\r\n\t\tthis.fStop = this.getFocalLength() / size;\r\n\r\n\t}\r\n\r\n\tget bokehSize() {\r\n\r\n\t\treturn this.getFocalLength() / this.fStop;\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.fStop = 1.4;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 25;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.fStop = source.fStop;\r\n\t\tthis.apertureBlades = source.apertureBlades;\r\n\t\tthis.apertureRotation = source.apertureRotation;\r\n\t\tthis.focusDistance = source.focusDistance;\r\n\t\tthis.anamorphicRatio = source.anamorphicRatio;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping, RGBAFormat, FloatType, ClampToEdgeWrapping } from 'three';\r\nimport { toHalfFloatArray } from '../utils/TextureUtils.js';\r\n\r\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\r\n\r\n\tlet lower = offset;\r\n\tlet upper = offset + count - 1;\r\n\r\n\twhile ( lower < upper ) {\r\n\r\n\t\t// calculate the midpoint for this iteration using a bitwise shift right operator to save 1 floating point multiplication\r\n\t\t// and 1 truncation from the double tilde operator to improve performance\r\n\t\t// this results in much better performance over using standard \"~ ~ ( (lower + upper) ) / 2\" to calculate the midpoint\r\n\t\tconst mid = ( lower + upper ) >> 1;\r\n\r\n\t\t// check if the middle array value is above or below the target and shift\r\n\t\t// which half of the array we're looking at\r\n\t\tif ( array[ mid ] < targetValue ) {\r\n\r\n\t\t\tlower = mid + 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tupper = mid;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn lower - offset;\r\n\r\n}\r\n\r\nfunction colorToLuminance( r, g, b ) {\r\n\r\n\t// https://en.wikipedia.org/wiki/Relative_luminance\r\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\r\n\r\n}\r\n\r\n// ensures the data is all floating point values and flipY is false\r\nfunction preprocessEnvMap( envMap, targetType = HalfFloatType ) {\r\n\r\n\tconst map = envMap.clone();\r\n\tmap.source = new Source( { ...map.image } );\r\n\tconst { width, height, data } = map.image;\r\n\r\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\r\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\r\n\tlet newData = data;\r\n\tif ( map.type !== targetType ) {\r\n\r\n\t\tif ( targetType === HalfFloatType ) {\r\n\r\n\t\t\tnewData = new Uint16Array( data.length );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewData = new Float32Array( data.length );\r\n\r\n\t\t}\r\n\r\n\t\tlet maxIntValue;\r\n\t\tif ( data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array ) {\r\n\r\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT - 1 ) - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT ) - 1;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet v = data[ i ];\r\n\t\t\tif ( map.type === HalfFloatType ) {\r\n\r\n\t\t\t\tv = DataUtils.fromHalfFloat( data[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( map.type !== FloatType && map.type !== HalfFloatType ) {\r\n\r\n\t\t\t\tv /= maxIntValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( targetType === HalfFloatType ) {\r\n\r\n\t\t\t\tnewData[ i ] = DataUtils.toHalfFloat( v );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.image.data = newData;\r\n\t\tmap.type = targetType;\r\n\r\n\t}\r\n\r\n\t// remove any y flipping for cdf computation\r\n\tif ( map.flipY ) {\r\n\r\n\t\tconst ogData = newData;\r\n\t\tnewData = newData.slice();\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst newY = height - y - 1;\r\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\r\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\r\n\r\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\r\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\r\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\r\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.flipY = false;\r\n\t\tmap.image.data = newData;\r\n\r\n\t}\r\n\r\n\treturn map;\r\n\r\n}\r\n\r\nexport class EquirectHdrInfoUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// Default to a white texture and associated weights so we don't\r\n\t\t// just render black initially.\r\n\t\tconst blackTex = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 0, 0 ] ) ), 1, 1 );\r\n\t\tblackTex.type = HalfFloatType;\r\n\t\tblackTex.format = RGBAFormat;\r\n\t\tblackTex.minFilter = LinearFilter;\r\n\t\tblackTex.magFilter = LinearFilter;\r\n\t\tblackTex.wrapS = RepeatWrapping;\r\n\t\tblackTex.wrapT = RepeatWrapping;\r\n\t\tblackTex.generateMipmaps = false;\r\n\t\tblackTex.needsUpdate = true;\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\r\n\t\t// used to sampling a random value to a relevant row to sample from\r\n\t\tconst marginalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 1 ] ) ), 1, 2 );\r\n\t\tmarginalWeights.type = HalfFloatType;\r\n\t\tmarginalWeights.format = RedFormat;\r\n\t\tmarginalWeights.minFilter = LinearFilter;\r\n\t\tmarginalWeights.magFilter = LinearFilter;\r\n\t\tmarginalWeights.generateMipmaps = false;\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\r\n\t\t// used to sampling a random value to a relevant pixel to sample from\r\n\t\tconst conditionalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 1, 1 ] ) ), 2, 2 );\r\n\t\tconditionalWeights.type = HalfFloatType;\r\n\t\tconditionalWeights.format = RedFormat;\r\n\t\tconditionalWeights.minFilter = LinearFilter;\r\n\t\tconditionalWeights.magFilter = LinearFilter;\r\n\t\tconditionalWeights.generateMipmaps = false;\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.map = blackTex;\r\n\t\tthis.marginalWeights = marginalWeights;\r\n\t\tthis.conditionalWeights = conditionalWeights;\r\n\t\tthis.totalSum = 0;\r\n\r\n\t\t// TODO: Add support for float or half float types here. We need to pass this into\r\n\t\t// the preprocess function and ensure our CDF and MDF textures are appropriately sized\r\n\t\t// Ideally we wouldn't upscale a bit depth if we didn't need to.\r\n\t\t// this.type = HalfFloatType;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.marginalWeights.dispose();\r\n\t\tthis.conditionalWeights.dispose();\r\n\t\tthis.map.dispose();\r\n\r\n\t}\r\n\r\n\tupdateFrom( hdr ) {\r\n\r\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\r\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\r\n\t\tconst map = preprocessEnvMap( hdr );\r\n\t\tmap.wrapS = RepeatWrapping;\r\n\t\tmap.wrapT = ClampToEdgeWrapping;\r\n\r\n\t\tconst { width, height, data } = map.image;\r\n\r\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\r\n\t\t// \"marginal\" = \"row relative to row sum\"\r\n\r\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\r\n\t\tconst pdfConditional = new Float32Array( width * height );\r\n\t\tconst cdfConditional = new Float32Array( width * height );\r\n\r\n\t\tconst pdfMarginal = new Float32Array( height );\r\n\t\tconst cdfMarginal = new Float32Array( height );\r\n\r\n\t\tlet totalSumValue = 0.0;\r\n\t\tlet cumulativeWeightMarginal = 0.0;\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tlet cumulativeRowWeight = 0.0;\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst r = DataUtils.fromHalfFloat( data[ 4 * i + 0 ] );\r\n\t\t\t\tconst g = DataUtils.fromHalfFloat( data[ 4 * i + 1 ] );\r\n\t\t\t\tconst b = DataUtils.fromHalfFloat( data[ 4 * i + 2 ] );\r\n\r\n\t\t\t\t// the probability of the pixel being selected in this row is the\r\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\r\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\r\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\r\n\t\t\t\tcumulativeRowWeight += weight;\r\n\t\t\t\ttotalSumValue += weight;\r\n\r\n\t\t\t\tpdfConditional[ i ] = weight;\r\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// can happen if the row is all black\r\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\r\n\r\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\r\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\r\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\r\n\r\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\r\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\r\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\r\n\r\n\t\t}\r\n\r\n\t\t// can happen if the texture is all black\r\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\r\n\r\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\r\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute a sorted index of distributions and the probabilities along them for both\r\n\t\t// the marginal and conditional data. These will be used to sample with a random number\r\n\t\t// to retrieve a uv value to sample in the environment map.\r\n\t\t// These values continually increase so it's okay to interpolate between them.\r\n\t\tconst marginalDataArray = new Uint16Array( height );\r\n\t\tconst conditionalDataArray = new Uint16Array( width * height );\r\n\r\n\t\t// we add a half texel offset so we're sampling the center of the pixel\r\n\t\tfor ( let i = 0; i < height; i ++ ) {\r\n\r\n\t\t\tconst dist = ( i + 1 ) / height;\r\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\r\n\r\n\t\t\tmarginalDataArray[ i ] = DataUtils.toHalfFloat( ( row + 0.5 ) / height );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst dist = ( x + 1 ) / width;\r\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\r\n\r\n\t\t\t\tconditionalDataArray[ i ] = DataUtils.toHalfFloat( ( col + 0.5 ) / width );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.dispose();\r\n\r\n\t\tconst { marginalWeights, conditionalWeights } = this;\r\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.totalSum = totalSumValue;\r\n\t\tthis.map = map;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataUtils } from 'three';\r\n\r\n\r\nexport function toHalfFloatArray( f32Array ) {\r\n\r\n\tconst f16Array = new Uint16Array( f32Array.length );\r\n\tfor ( let i = 0, n = f32Array.length; i < n; ++ i ) {\r\n\r\n\t\tf16Array[ i ] = DataUtils.toHalfFloat( f32Array[ i ] );\r\n\r\n\t}\r\n\r\n\treturn f16Array;\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4, NearestFilter } from 'three';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nconst LIGHT_PIXELS = 6;\r\nconst RECT_AREA_LIGHT = 0;\r\nconst CIRC_AREA_LIGHT = 1;\r\nconst SPOT_LIGHT = 2;\r\nconst DIR_LIGHT = 3;\r\nconst POINT_LIGHT = 4;\r\n\r\nconst u = new Vector3();\r\nconst v = new Vector3();\r\nconst m = new Matrix4();\r\nconst worldQuaternion = new Quaternion();\r\nconst eye = new Vector3();\r\nconst target = new Vector3();\r\nconst up = new Vector3( 0, 1, 0 );\r\nexport class LightsInfoUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\r\n\t\ttex.format = RGBAFormat;\r\n\t\ttex.type = FloatType;\r\n\t\ttex.wrapS = ClampToEdgeWrapping;\r\n\t\ttex.wrapT = ClampToEdgeWrapping;\r\n\t\ttex.generateMipmaps = false;\r\n\t\ttex.minFilter = NearestFilter;\r\n\t\ttex.magFilter = NearestFilter;\r\n\r\n\t\tthis.tex = tex;\r\n\t\tthis.count = 0;\r\n\r\n\t}\r\n\r\n\tupdateFrom( lights, iesTextures = [] ) {\r\n\r\n\t\tconst tex = this.tex;\r\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\r\n\r\n\t\tif ( tex.image.width !== dimension ) {\r\n\r\n\t\t\ttex.dispose();\r\n\r\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\ttex.image.width = dimension;\r\n\t\t\ttex.image.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = tex.image.data;\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst l = lights[ i ];\r\n\r\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\t// initialize to 0\r\n\t\t\tfor ( let p = 0; p < LIGHT_PIXELS * 4; p ++ ) {\r\n\r\n\t\t\t\tfloatArray[ baseIndex + p ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 1\r\n\t\t    // position\r\n\t\t\tl.getWorldPosition( v );\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t// type\r\n\t\t\tlet type = RECT_AREA_LIGHT;\r\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\r\n\r\n\t\t\t\ttype = CIRC_AREA_LIGHT;\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\ttype = SPOT_LIGHT;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\ttype = DIR_LIGHT;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\ttype = POINT_LIGHT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// color\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\r\n\r\n\t\t\t// intensity\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\r\n\r\n\t\t\tl.getWorldQuaternion( worldQuaternion );\r\n\r\n\t\t\tif ( l.isRectAreaLight ) {\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\tconst radius = l.radius || 0;\r\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\tm.lookAt( eye, target, up );\r\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\t// radius\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\r\n\r\n\t\t\t\t// decay\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\r\n\t\t\t\t// distance\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t\t// coneCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\r\n\r\n\t\t\t\t// sample 6\r\n\t\t\t\t// penumbraCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\r\n\r\n\t\t\t\t// iesProfile\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.iesMap ? iesTextures.indexOf( l.iesMap ) : - 1;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\tindex += 4;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\tindex += 1;\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\tconst targetPosition = v.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = lights.length;\r\n\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\ttex.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\r\n\r\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\r\n\r\n\tupdateNormalAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 0, attr );\r\n\r\n\t}\r\n\r\n\tupdateTangentAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 1, attr );\r\n\r\n\t}\r\n\r\n\tupdateUvAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 2, attr );\r\n\r\n\t}\r\n\r\n\tupdateColorAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 3, attr );\r\n\r\n\t}\r\n\r\n\tupdateFrom( normal, tangent, uv, color ) {\r\n\r\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\r\n\r\n\t}\r\n\r\n}\r\n","import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\r\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\r\n\r\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\r\n\r\n\tif ( fromStride > toStride ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// scale non-float values to their normalized range\r\n\tconst count = fromArray.length / fromStride;\r\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\r\n\tlet maxValue = 1.0;\r\n\tswitch ( fromArray.constructor ) {\r\n\r\n\tcase Uint8Array:\r\n\tcase Uint16Array:\r\n\tcase Uint32Array:\r\n\t\tmaxValue = 2 ** bpe - 1;\r\n\t\tbreak;\r\n\r\n\tcase Int8Array:\r\n\tcase Int16Array:\r\n\tcase Int32Array:\r\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\r\n\t\tbreak;\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tconst i4 = 4 * i;\r\n\t\tconst is = fromStride * i;\r\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\r\n\r\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class FloatAttributeTextureArray extends DataArrayTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._textures = [];\r\n\t\tthis.type = FloatType;\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.internalFormat = 'RGBA32F';\r\n\r\n\t}\r\n\r\n\tupdateAttribute( index, attr ) {\r\n\r\n\t\t// update the texture\r\n\t\tconst tex = this._textures[ index ];\r\n\t\ttex.updateFrom( attr );\r\n\r\n\t\t// ensure compatibility\r\n\t\tconst baseImage = tex.image;\r\n\t\tconst image = this.image;\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\r\n\r\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\r\n\r\n\t\t}\r\n\r\n\t\t// update the image\r\n\t\tconst { width, height, data } = image;\r\n\t\tconst length = width * height * 4;\r\n\t\tconst offset = length * index;\r\n\t\tlet itemSize = attr.itemSize;\r\n\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\titemSize = 4;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data\r\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tsetAttributes( attrs ) {\r\n\r\n\t\t// ensure the attribute count\r\n\t\tconst itemCount = attrs[ 0 ].count;\r\n\t\tconst attrsLength = attrs.length;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\r\n\r\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// initialize all textures\r\n\t\tconst textures = this._textures;\r\n\t\twhile ( textures.length < attrsLength ) {\r\n\r\n\t\t\tconst tex = new FloatVertexAttributeTexture();\r\n\t\t\ttextures.push( tex );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( textures.length > attrsLength ) {\r\n\r\n\t\t\ttextures.pop();\r\n\r\n\t\t}\r\n\r\n\t\t// update all textures\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// determine if we need to create a new array\r\n\t\tconst baseTexture = textures[ 0 ];\r\n\t\tconst baseImage = baseTexture.image;\r\n\t\tconst image = this.image;\r\n\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\r\n\r\n\t\t\timage.width = baseImage.width;\r\n\t\t\timage.height = baseImage.height;\r\n\t\t\timage.depth = attrsLength;\r\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\r\n\r\n\t\t}\r\n\r\n\t\t// copy the other texture data into the data array texture\r\n\t\tconst { data, width, height } = image;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tconst tex = textures[ i ];\r\n\t\t\tconst length = width * height * 4;\r\n\t\t\tconst offset = length * i;\r\n\r\n\t\t\tlet itemSize = attrs[ i ].itemSize;\r\n\t\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\t\titemSize = 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\t}\r\n\r\n\t\t// reset the texture\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\r\nimport { getTextureHash } from '../core/utils/sceneUpdateUtils.js';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nexport const MATERIAL_PIXELS = 47;\r\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\r\n\r\nclass MaterialFeatures {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n\tisUsed( feature ) {\r\n\r\n\t\treturn feature in this._features;\r\n\r\n\t}\r\n\r\n\tsetUsed( feature, used = true ) {\r\n\r\n\t\tif ( used === false ) {\r\n\r\n\t\t\tdelete this._features[ feature ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._features[ feature ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MaterialsTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\r\n\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.type = FloatType;\r\n\t\tthis.wrapS = ClampToEdgeWrapping;\r\n\t\tthis.wrapT = ClampToEdgeWrapping;\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.features = new MaterialFeatures();\r\n\r\n\t}\r\n\r\n\tupdateFrom( materials, textures ) {\r\n\r\n\t\tfunction getTexture( material, key, def = - 1 ) {\r\n\r\n\t\t\tif ( key in material && material[ key ] ) {\r\n\r\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\r\n\t\t\t\treturn textureLookUp[ hash ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn def;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getField( material, key, def ) {\r\n\r\n\t\t\treturn key in material ? material[ key ] : def;\r\n\r\n\t\t}\r\n\r\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\r\n\r\n\t\t\tconst texture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\r\n\r\n\t\t\t// check if texture exists\r\n\t\t\tif ( texture ) {\r\n\r\n\t\t\t\tif ( texture.matrixAutoUpdate ) {\r\n\r\n\t\t\t\t\ttexture.updateMatrix();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst elements = texture.matrix.elements;\r\n\r\n\t\t\t\tlet i = 0;\r\n\r\n\t\t\t\t// first row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t\t// second row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 8;\r\n\r\n\t\t}\r\n\r\n\t\tlet index = 0;\r\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\r\n\t\tconst { image, features } = this;\r\n\r\n\t\t// index the list of textures based on shareable source\r\n\t\tconst textureLookUp = {};\r\n\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\t\ttextureLookUp[ getTextureHash( textures[ i ] ) ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tif ( image.width !== dimension ) {\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\timage.width = dimension;\r\n\t\t\timage.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = image.data;\r\n\r\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\r\n\t\t// can't encode texture ids that way.\r\n\t\t// const intArray = new Int32Array( floatArray.buffer );\r\n\r\n\t\tfeatures.reset();\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst m = materials[ i ];\r\n\r\n\t\t\tif ( m.isFogVolumeMaterial ) {\r\n\r\n\t\t\t\tfeatures.setUsed( 'FOG' );\r\n\r\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\r\n\r\n\t\t\t\t\tfloatArray[ index + j ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sample 0 .rgb\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\r\n\r\n\t\t\t\t// sample 2 .a\r\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t\t// sample 3 .rgb\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\r\n\r\n\t\t\t\t// sample 13 .g\r\n\t\t\t\t// reusing opacity field\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\r\n\r\n\t\t\t\t// side\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\r\n\r\n\t\t\t\t// sample 14 .b\r\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\r\n\r\n\t\t\t\tindex += MATERIAL_STRIDE;\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 0\r\n\t\t\t// color\r\n\t\t\tfloatArray[ index ++ ] = m.color.r;\r\n\t\t\tfloatArray[ index ++ ] = m.color.g;\r\n\t\t\tfloatArray[ index ++ ] = m.color.b;\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\r\n\r\n\t\t\t// sample 1\r\n\t\t\t// metalness & roughness\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// transmission & emissiveIntensity\r\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t// sample 3\r\n\t\t\t// emission\r\n\t\t\tif ( 'emissive' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\r\n\r\n\t\t\t// sample 4\r\n\t\t\t// normals\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\r\n\t\t\tif ( 'normalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\r\n\r\n \t\t\t} else {\r\n\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n \t\t\t}\r\n\r\n\t\t\t// clearcoat\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\r\n\r\n\t\t\t// sample 6\r\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\r\n\r\n\t\t\t// sample 7\r\n\t\t\t// sheen\r\n\t\t\tif ( 'sheenColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\r\n\r\n\t\t\t// sample 8\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\r\n\r\n\t\t\t// iridescence\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\r\n\r\n\t\t\t// sample 9\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\r\n\r\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\r\n\r\n\t\t\t// sample 10\r\n\t\t\t// specular color\r\n\t\t\tif ( 'specularColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\r\n\r\n\t\t\t// sample 11\r\n\t\t\t// specular intensity\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\r\n\r\n\t\t\t// isThinFilm\r\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\r\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// sample 12\r\n\t\t\tif ( 'attenuationColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\r\n\r\n\t\t\t// sample 13\r\n\t\t\t// alphaMap\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\r\n\r\n\t\t\t// side & matte\r\n\t\t\tfloatArray[ index ++ ] = m.opacity;\r\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\r\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( m.side ) {\r\n\r\n\t\t\t\tcase FrontSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase BackSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase DoubleSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 14\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'matte', false ) ); // matte\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'castShadow', true ) ); // shadow\r\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\r\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\r\n\r\n\t\t\t// map transform 15\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\r\n\r\n\t\t\t// metalnessMap transform 17\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\r\n\r\n\t\t\t// roughnessMap transform 19\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\r\n\r\n\t\t\t// transmissionMap transform 21\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\r\n\r\n\t\t\t// emissiveMap transform 22\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\r\n\r\n\t\t\t// normalMap transform 25\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatMap transform 27\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatNormalMap transform 29\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatRoughnessMap transform 31\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// sheenColorMap transform 33\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\r\n\r\n\t\t\t// sheenRoughnessMap transform 35\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceMap transform 37\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceThicknessMap transform 39\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\r\n\r\n\t\t\t// specularColorMap transform 41\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\r\n\r\n\t\t\t// specularIntensityMap transform 43\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\r\n\r\n\t\t\t// alphaMap transform 45\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'alphaMap', floatArray, index );\r\n\r\n\t\t}\r\n\r\n\t\t// check if the contents have changed\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","function uuidSort( a, b ) {\r\n\r\n\tif ( a.uuid < b.uuid ) return 1;\r\n\tif ( a.uuid > b.uuid ) return - 1;\r\n\treturn 0;\r\n\r\n}\r\n\r\n// we must hash the texture to determine uniqueness using the encoding, as well, because the\r\n// when rendering each texture to the texture array they must have a consistent color space.\r\nexport function getTextureHash( t ) {\r\n\r\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\r\n\r\n}\r\n\r\n// reduce the set of textures to just those with a unique source while retaining\r\n// the order of the textures.\r\nfunction reduceTexturesToUniqueSources( textures ) {\r\n\r\n\tconst sourceSet = new Set();\r\n\tconst result = [];\r\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\tconst tex = textures[ i ];\r\n\t\tconst hash = getTextureHash( tex );\r\n\t\tif ( ! sourceSet.has( hash ) ) {\r\n\r\n\t\t\tsourceSet.add( hash );\r\n\t\t\tresult.push( tex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function getIesTextures( lights ) {\r\n\r\n\tconst textures = lights.map( l => l.iesMap || null ).filter( t => t );\r\n\tconst textureSet = new Set( textures );\r\n\treturn Array.from( textureSet ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getTextures( materials ) {\r\n\r\n\tconst textureSet = new Set();\r\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\tconst material = materials[ i ];\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst textureArray = Array.from( textureSet );\r\n\treturn reduceTexturesToUniqueSources( textureArray ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getLights( scene ) {\r\n\r\n\tconst lights = [];\r\n\tscene.traverse( c => {\r\n\r\n\t\tif ( c.visible ) {\r\n\r\n\t\t\tif (\r\n\t\t\t\tc.isRectAreaLight ||\r\n\t\t\t\tc.isSpotLight ||\r\n\t\t\t\tc.isPointLight ||\r\n\t\t\t\tc.isDirectionalLight\r\n\t\t\t) {\r\n\r\n\t\t\t\tlights.push( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn lights.sort( uuidSort );\r\n\r\n}\r\n","import {\r\n\tWebGLArrayRenderTarget,\r\n\tRGBAFormat,\r\n\tUnsignedByteType,\r\n\tColor,\r\n\tRepeatWrapping,\r\n\tLinearFilter,\r\n\tNoToneMapping,\r\n\tShaderMaterial,\r\n} from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\n\r\nconst prevColor = new Color();\r\nfunction getTextureHash( texture ) {\r\n\r\n\treturn texture ? `${ texture.uuid }:${ texture.version }` : null;\r\n\r\n}\r\n\r\nfunction assignOptions( target, options ) {\r\n\r\n\tfor ( const key in options ) {\r\n\r\n\t\tif ( key in target ) {\r\n\r\n\t\t\ttarget[ key ] = options[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\r\n\r\n\tconstructor( width, height, options ) {\r\n\r\n\t\tconst textureOptions = {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: UnsignedByteType,\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\twrapS: RepeatWrapping,\r\n\t\t\twrapT: RepeatWrapping,\r\n\t\t\tgenerateMipmaps: false,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tsuper( width, height, 1, textureOptions );\r\n\r\n\t\t// manually assign the options because passing options into the\r\n\t\t// constructor does not work\r\n\t\tassignOptions( this.texture, textureOptions );\r\n\r\n\t\tthis.texture.setTextures = ( ...args ) => {\r\n\r\n\t\t\tthis.setTextures( ...args );\r\n\r\n\t\t};\r\n\r\n\t\tthis.hashes = [ null ];\r\n\r\n\t\tconst fsQuad = new FullScreenQuad( new CopyMaterial() );\r\n\t\tthis.fsQuad = fsQuad;\r\n\r\n\t}\r\n\r\n\tsetTextures( renderer, textures, width = this.width, height = this.height ) {\r\n\r\n\t\t// save previous renderer state\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevToneMapping = renderer.toneMapping;\r\n\t\tconst prevAlpha = renderer.getClearAlpha();\r\n\t\trenderer.getClearColor( prevColor );\r\n\r\n\t\t// resize the render target and ensure we don't have an empty texture\r\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\r\n\t\tconst depth = textures.length || 1;\r\n\t\tif ( width !== this.width || height !== this.height || this.depth !== depth ) {\r\n\r\n\t\t\tthis.setSize( width, height, depth );\r\n\t\t\tthis.hashes = new Array( depth ).fill( null );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setClearColor( 0, 0 );\r\n\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t// render each texture into each layer of the target\r\n\t\tconst fsQuad = this.fsQuad;\r\n\t\tconst hashes = this.hashes;\r\n\t\tlet updated = false;\r\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\r\n\r\n\t\t\tconst texture = textures[ i ];\r\n\t\t\tconst hash = getTextureHash( texture );\r\n\t\t\tif ( texture && ( hashes[ i ] !== hash || texture.isWebGLRenderTarget ) ) {\r\n\r\n\t\t\t\t// revert to default texture transform before rendering\r\n\t\t\t\ttexture.matrixAutoUpdate = false;\r\n\t\t\t\ttexture.matrix.identity();\r\n\r\n\t\t\t\tfsQuad.material.map = texture;\r\n\r\n\t\t\t\trenderer.setRenderTarget( this, i );\r\n\t\t\t\tfsQuad.render( renderer );\r\n\r\n\t\t\t\t// restore custom texture transform\r\n\t\t\t\ttexture.updateMatrix();\r\n\t\t\t\ttexture.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t// ensure textures are not updated unnecessarily\r\n\t\t\t\thashes[ i ] = hash;\r\n\t\t\t\tupdated = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the renderer\r\n\t\tfsQuad.material.map = null;\r\n\t\trenderer.setClearColor( prevColor, prevAlpha );\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.toneMapping = prevToneMapping;\r\n\r\n\t\treturn updated;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tsuper.dispose();\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass CopyMaterial extends ShaderMaterial {\r\n\r\n\tget map() {\r\n\r\n\t\treturn this.uniforms.map.value;\r\n\r\n\t}\r\n\tset map( v ) {\r\n\r\n\t\tthis.uniforms.map.value = v;\r\n\r\n\t}\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tmap: { value: null },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\tuniform sampler2D map;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat } from 'three';\r\nimport { StratifiedSamplerCombined } from './stratified/StratifiedSamplerCombined.js';\r\n\r\n// https://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator\r\nclass RandomGenerator {\r\n\r\n\tconstructor( seed = 0 ) {\r\n\r\n\t\t// LCG using GCC's constants\r\n\t\tthis.m = 0x80000000; // 2**31;\r\n\t\tthis.a = 1103515245;\r\n\t\tthis.c = 12345;\r\n\r\n\t\tthis.seed = seed;\r\n\r\n\t}\r\n\r\n\tnextInt() {\r\n\r\n\t\tthis.seed = ( this.a * this.seed + this.c ) % this.m;\r\n\t\treturn this.seed;\r\n\r\n\t}\r\n\r\n\tnextFloat() {\r\n\r\n\t\t// returns in range [0,1]\r\n\t\treturn this.nextInt() / ( this.m - 1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class StratifiedSamplesTexture extends DataTexture {\r\n\r\n\tconstructor( count = 1, depth = 1, strata = 8 ) {\r\n\r\n\t\tsuper( new Float32Array( 1 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.strata = strata;\r\n\t\tthis.sampler = null;\r\n\t\tthis.generator = new RandomGenerator();\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.random = () => {\r\n\r\n\t\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\t\treturn this.generator.nextFloat();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn Math.random();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.init( count, depth, strata );\r\n\r\n\t}\r\n\r\n\tinit( count = this.image.height, depth = this.image.width, strata = this.strata ) {\r\n\r\n\t\tconst { image } = this;\r\n\t\tif ( image.width === depth && image.height === count && this.sampler !== null ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst dimensions = new Array( count * depth ).fill( 4 );\r\n\t\tconst sampler = new StratifiedSamplerCombined( strata, dimensions, this.random );\r\n\r\n\t\timage.width = depth;\r\n\t\timage.height = count;\r\n\t\timage.data = sampler.samples;\r\n\r\n\t\tthis.sampler = sampler;\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.next();\r\n\r\n\t}\r\n\r\n\tnext() {\r\n\r\n\t\tthis.sampler.next();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.sampler.reset();\r\n\t\tthis.generator.seed = 0;\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nimport { StratifiedSampler } from './StratifiedSampler.js';\r\n\r\n// Stratified set of data with each tuple stratified separately and combined\r\nexport class StratifiedSamplerCombined {\r\n\r\n\tconstructor( strataCount, listOfDimensions, random = Math.random ) {\r\n\r\n\t\tlet totalDim = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\ttotalDim += dim;\r\n\r\n\t\t}\r\n\r\n\t\tconst combined = new Float32Array( totalDim );\r\n\t\tconst strataObjs = [];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\tconst sampler = new StratifiedSampler( strataCount, dim, random );\r\n\t\t\tsampler.samples = new Float32Array( combined.buffer, offset, sampler.samples.length );\r\n\t\t\toffset += sampler.samples.length * 4;\r\n\t\t\tstrataObjs.push( sampler );\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = combined;\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.next();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn combined;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reset();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nexport function shuffle( arr, random = Math.random() ) {\r\n\r\n\tfor ( let i = arr.length - 1; i > 0; i -- ) {\r\n\r\n\t  const j = Math.floor( random() * ( i + 1 ) );\r\n\t  const x = arr[ i ];\r\n\t  arr[ i ] = arr[ j ];\r\n\t  arr[ j ] = x;\r\n\r\n\t}\r\n\r\n\treturn arr;\r\n\r\n}\r\n\r\n// strataCount : The number of bins per dimension\r\n// dimensions  : The number of dimensions to generate stratified values for\r\nexport class StratifiedSampler {\r\n\r\n\tconstructor( strataCount, dimensions, random = Math.random ) {\r\n\r\n\t\tconst l = strataCount ** dimensions;\r\n\t\tconst strata = new Uint16Array( l );\r\n\t\tlet index = l;\r\n\r\n\t\t// each integer represents a statum bin\r\n\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tstrata[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = new Float32Array( dimensions );\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\t\tstrata[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tconst { samples } = this;\r\n\r\n\t\t\tif ( index >= strata.length ) {\r\n\r\n\t\t\t\tshuffle( strata, random );\r\n\t\t\t\tthis.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet stratum = strata[ index ++ ];\r\n\r\n\t\t\tfor ( let i = 0; i < dimensions; i ++ ) {\r\n\r\n\t\t\t\tsamples[ i ] = ( stratum % strataCount + random() ) / strataCount;\r\n\t\t\t\tstratum = Math.floor( stratum / strataCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn samples;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat, RGFormat, RedFormat } from 'three';\r\nimport { BlueNoiseGenerator } from './blueNoise/BlueNoiseGenerator.js';\r\n\r\nfunction getStride( channels ) {\r\n\r\n\tif ( channels >= 3 ) {\r\n\r\n\t\treturn 4;\r\n\r\n\t} else {\r\n\r\n\t\treturn channels;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getFormat( channels ) {\r\n\r\n\tswitch ( channels ) {\r\n\r\n\tcase 1:\r\n\t\treturn RedFormat;\r\n\tcase 2:\r\n\t\treturn RGFormat;\r\n\tdefault:\r\n\t\treturn RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class BlueNoiseTexture extends DataTexture {\r\n\r\n\tconstructor( size = 64, channels = 1 ) {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.size = size;\r\n\t\tthis.channels = channels;\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst channels = this.channels;\r\n\t\tconst size = this.size;\r\n\t\tconst generator = new BlueNoiseGenerator();\r\n\t\tgenerator.channels = channels;\r\n\t\tgenerator.size = size;\r\n\r\n\t\tconst stride = getStride( channels );\r\n\t\tconst format = getFormat( stride );\r\n\t\tif ( this.image.width !== size || format !== this.format ) {\r\n\r\n\t\t\tthis.image.width = size;\r\n\t\t\tthis.image.height = size;\r\n\t\t\tthis.image.data = new Float32Array( ( size ** 2 ) * stride );\r\n\t\t\tthis.format = format;\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tconst data = this.image.data;\r\n\t\tfor ( let i = 0, l = channels; i < l; i ++ ) {\r\n\r\n\t\t\tconst result = generator.generate();\r\n\t\t\tconst bin = result.data;\r\n\t\t\tconst maxValue = result.maxValue;\r\n\r\n\t\t\tfor ( let j = 0, l2 = bin.length; j < l2; j ++ ) {\r\n\r\n\t\t\t\tconst value = bin[ j ] / maxValue;\r\n\t\t\t\tdata[ j * stride + i ] = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n","import { shuffleArray, fillWithOnes } from './utils.js';\r\nimport { BlueNoiseSamples } from './BlueNoiseSamples.js';\r\n\r\nexport class BlueNoiseGenerator {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.random = Math.random;\r\n\t\tthis.sigma = 1.5;\r\n\t\tthis.size = 64;\r\n\t\tthis.majorityPointsRatio = 0.1;\r\n\r\n\t\tthis.samples = new BlueNoiseSamples( 1 );\r\n\t\tthis.savedSamples = new BlueNoiseSamples( 1 );\r\n\r\n\t}\r\n\r\n\tgenerate() {\r\n\r\n\t\t// http://cv.ulichney.com/papers/1993-void-cluster.pdf\r\n\r\n\t\tconst {\r\n\t\t\tsamples,\r\n\t\t\tsavedSamples,\r\n\t\t\tsigma,\r\n\t\t\tmajorityPointsRatio,\r\n\t\t\tsize,\r\n\t\t} = this;\r\n\r\n\t\tsamples.resize( size );\r\n\t\tsamples.setSigma( sigma );\r\n\r\n\t\t// 1. Randomly place the minority points.\r\n\t\tconst pointCount = Math.floor( size * size * majorityPointsRatio );\r\n\t\tconst initialSamples = samples.binaryPattern;\r\n\r\n\t\tfillWithOnes( initialSamples, pointCount );\r\n\t\tshuffleArray( initialSamples, this.random );\r\n\r\n\t\tfor ( let i = 0, l = initialSamples.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( initialSamples[ i ] === 1 ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 2. Remove minority point that is in densest cluster and place it in the largest void.\r\n\t\twhile ( true ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tconst voidIndex = samples.findVoid();\r\n\t\t\tif ( clusterIndex === voidIndex ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( clusterIndex );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsamples.addPointIndex( voidIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\r\n\t\t// in the dither array.\r\n\t\tconst ditherArray = new Uint32Array( size * size );\r\n\t\tsavedSamples.copy( samples );\r\n\r\n\t\tlet rank;\r\n\t\trank = samples.count - 1;\r\n\t\twhile ( rank >= 0 ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank --;\r\n\r\n\t\t}\r\n\r\n\t\t// 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\r\n\t\t// the initial binary pattern.\r\n\t\tconst totalSize = size * size;\r\n\t\trank = savedSamples.count;\r\n\t\twhile ( rank < totalSize / 2 ) {\r\n\r\n\t\t\tconst voidIndex = savedSamples.findVoid();\r\n\t\t\tsavedSamples.addPointIndex( voidIndex );\r\n\t\t\tditherArray[ voidIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\t// 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\r\n\t\t// and iteratively removing them.\r\n\t\tsavedSamples.invert();\r\n\r\n\t\twhile ( rank < totalSize ) {\r\n\r\n\t\t\tconst clusterIndex = savedSamples.findCluster();\r\n\t\t\tsavedSamples.removePointIndex( clusterIndex );\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { data: ditherArray, maxValue: totalSize };\r\n\r\n\t}\r\n\r\n}\r\n","export function shuffleArray( array, random = Math.random ) {\r\n\r\n\tfor ( let i = array.length - 1; i > 0; i -- ) {\r\n\r\n\t\tconst replaceIndex = ~ ~ ( ( random() - 1e-6 ) * i );\r\n\t\tconst tmp = array[ i ];\r\n\t\tarray[ i ] = array[ replaceIndex ];\r\n\t\tarray[ replaceIndex ] = tmp;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function fillWithOnes( array, count ) {\r\n\r\n\tarray.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tarray[ i ] = 1;\r\n\r\n\t}\r\n\r\n}\r\n","export class BlueNoiseSamples {\r\n\r\n\tconstructor( size ) {\r\n\r\n\t\tthis.count = 0;\r\n\t\tthis.size = - 1;\r\n\t\tthis.sigma = - 1;\r\n\t\tthis.radius = - 1;\r\n\t\tthis.lookupTable = null;\r\n\t\tthis.score = null;\r\n\t\tthis.binaryPattern = null;\r\n\r\n\t\tthis.resize( size );\r\n\t\tthis.setSigma( 1.5 );\r\n\r\n\t}\r\n\r\n\tfindVoid() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 0 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore < currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tfindCluster() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = - Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 1 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore > currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tsetSigma( sigma ) {\r\n\r\n\t\tif ( sigma === this.sigma ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// generate a radius in which the score will be updated under the\r\n\t\t// assumption that e^-10 is insignificant enough to be the border at\r\n\t\t// which we drop off.\r\n\t\tconst radius = ~ ~ ( Math.sqrt( 10 * 2 * ( sigma ** 2 ) ) + 1 );\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tconst lookupTable = new Float32Array( lookupWidth * lookupWidth );\r\n\t\tconst sigma2 = sigma * sigma;\r\n\t\tfor ( let x = - radius; x <= radius; x ++ ) {\r\n\r\n\t\t\tfor ( let y = - radius; y <= radius; y ++ ) {\r\n\r\n\t\t\t\tconst index = ( radius + y ) * lookupWidth + x + radius;\r\n\t\t\t\tconst dist2 = x * x + y * y;\r\n\t\t\t\tlookupTable[ index ] = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.lookupTable = lookupTable;\r\n\t\tthis.sigma = sigma;\r\n\t\tthis.radius = radius;\r\n\r\n\t}\r\n\r\n\tresize( size ) {\r\n\r\n\t\tif ( this.size !== size ) {\r\n\r\n\t\t\tthis.size = size;\r\n\t\t\tthis.score = new Float32Array( size * size );\r\n\t\t\tthis.binaryPattern = new Uint8Array( size * size );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\tconst { binaryPattern, score, size } = this;\r\n\r\n\t\tscore.fill( 0 );\r\n\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] === 0 ) {\r\n\r\n\t\t\t\tconst y = ~ ~ ( i / size );\r\n\t\t\t\tconst x = i - y * size;\r\n\t\t\t\tthis.updateScore( x, y, 1 );\r\n\t\t\t\tbinaryPattern[ i ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinaryPattern[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateScore( x, y, multiplier ) {\r\n\r\n\t\t// TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\r\n\t\t// everything in the buffer?\r\n\t\tconst { size, score, lookupTable } = this;\r\n\r\n\t\t// const sigma2 = sigma * sigma;\r\n\t\t// const radius = Math.floor( size / 2 );\r\n\t\tconst radius = this.radius;\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tfor ( let px = - radius; px <= radius; px ++ ) {\r\n\r\n\t\t\tfor ( let py = - radius; py <= radius; py ++ ) {\r\n\r\n\t\t\t\t// const dist2 = px * px + py * py;\r\n\t\t\t\t// const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t\tconst lookupIndex = ( radius + py ) * lookupWidth + px + radius;\r\n\t\t\t\tconst value = lookupTable[ lookupIndex ];\r\n\r\n\t\t\t\tlet sx = ( x + px );\r\n\t\t\t\tsx = sx < 0 ? size + sx : sx % size;\r\n\r\n\t\t\t\tlet sy = ( y + py );\r\n\t\t\t\tsy = sy < 0 ? size + sy : sy % size;\r\n\r\n\t\t\t\tconst sindex = sy * size + sx;\r\n\t\t\t\tscore[ sindex ] += multiplier * value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\taddPointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 1;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, 1 );\r\n\t\tthis.count ++;\r\n\r\n\t}\r\n\r\n\tremovePointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 0;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, - 1 );\r\n\t\tthis.count --;\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.resize( source.size );\r\n\t\tthis.score.set( source.score );\r\n\t\tthis.binaryPattern.set( source.binaryPattern );\r\n\t\tthis.setSigma( source.sigma );\r\n\t\tthis.count = source.count;\r\n\r\n\t}\r\n\r\n}\r\n","export const camera_struct = /* glsl */`\r\n\r\n\tstruct PhysicalCamera {\r\n\r\n\t\tfloat focusDistance;\r\n\t\tfloat anamorphicRatio;\r\n\t\tfloat bokehSize;\r\n\t\tint apertureBlades;\r\n\t\tfloat apertureRotation;\r\n\r\n\t};\r\n\r\n`;\r\n","export const equirect_struct = /* glsl */`\r\n\r\n\tstruct EquirectHdrInfo {\r\n\r\n\t\tsampler2D marginalWeights;\r\n\t\tsampler2D conditionalWeights;\r\n\t\tsampler2D map;\r\n\r\n\t\tfloat totalSum;\r\n\r\n\t};\r\n\r\n`;\r\n","export const lights_struct = /* glsl */`\r\n\r\n\t#define RECT_AREA_LIGHT_TYPE 0\r\n\t#define CIRC_AREA_LIGHT_TYPE 1\r\n\t#define SPOT_LIGHT_TYPE 2\r\n\t#define DIR_LIGHT_TYPE 3\r\n\t#define POINT_LIGHT_TYPE 4\r\n\r\n\tstruct LightsInfo {\r\n\r\n\t\tsampler2D tex;\r\n\t\tuint count;\r\n\r\n\t};\r\n\r\n\tstruct Light {\r\n\r\n\t\tvec3 position;\r\n\t\tint type;\r\n\r\n\t\tvec3 color;\r\n\t\tfloat intensity;\r\n\r\n\t\tvec3 u;\r\n\t\tvec3 v;\r\n\t\tfloat area;\r\n\r\n\t\t// spot light fields\r\n\t\tfloat radius;\r\n\t\tfloat near;\r\n\t\tfloat decay;\r\n\t\tfloat distance;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\tint iesProfile;\r\n\r\n\t};\r\n\r\n\tLight readLightInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 6u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\r\n\t\tLight l;\r\n\t\tl.position = s0.rgb;\r\n\t\tl.type = int( round( s0.a ) );\r\n\r\n\t\tl.color = s1.rgb;\r\n\t\tl.intensity = s1.a;\r\n\r\n\t\tl.u = s2.rgb;\r\n\t\tl.v = s3.rgb;\r\n\t\tl.area = s3.a;\r\n\r\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\t\tl.radius = s4.r;\r\n\t\t\tl.decay = s4.g;\r\n\t\t\tl.distance = s4.b;\r\n\t\t\tl.coneCos = s4.a;\r\n\r\n\t\t\tl.penumbraCos = s5.r;\r\n\t\t\tl.iesProfile = int( round( s5.g ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl.radius = 0.0;\r\n\t\t\tl.decay = 0.0;\r\n\t\t\tl.distance = 0.0;\r\n\r\n\t\t\tl.coneCos = 0.0;\r\n\t\t\tl.penumbraCos = 0.0;\r\n\t\t\tl.iesProfile = - 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn l;\r\n\r\n\t}\r\n\r\n`;\r\n","export const surface_record_struct = /* glsl */`\r\n\r\n\tstruct SurfaceRecord {\r\n\r\n\t\t// surface type\r\n\t\tbool volumeParticle;\r\n\r\n\t\t// geometry\r\n\t\tvec3 faceNormal;\r\n\t\tbool frontFace;\r\n\t\tvec3 normal;\r\n\t\tmat3 normalBasis;\r\n\t\tmat3 normalInvBasis;\r\n\r\n\t\t// cached properties\r\n\t\tfloat eta;\r\n\t\tfloat f0;\r\n\r\n\t\t// material\r\n\t\tfloat roughness;\r\n\t\tfloat filteredRoughness;\r\n\t\tfloat metalness;\r\n\t\tvec3 color;\r\n\t\tvec3 emission;\r\n\r\n\t\t// transmission\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tbool thinFilm;\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\t// clearcoat\r\n\t\tvec3 clearcoatNormal;\r\n\t\tmat3 clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis;\r\n\t\tfloat clearcoat;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tfloat filteredClearcoatRoughness;\r\n\r\n\t\t// sheen\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tfloat sheenRoughness;\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThickness;\r\n\r\n\t\t// specular\r\n\t\tvec3 specularColor;\r\n\t\tfloat specularIntensity;\r\n\t};\r\n\r\n\tstruct ScatterRecord {\r\n\t\tfloat specularPdf;\r\n\t\tfloat pdf;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t};\r\n\r\n`;\r\n","export const equirect_functions = /* glsl */`\r\n\r\n\t// samples the the given environment map in the given direction\r\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\r\n\r\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\r\n\r\n\t}\r\n\r\n\t// gets the pdf of the given direction to sample\r\n\tfloat equirectDirectionPdf( vec3 direction ) {\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tfloat theta = uv.y * PI;\r\n\t\tfloat sinTheta = sin( theta );\r\n\t\tif ( sinTheta == 0.0 ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\r\n\r\n\t}\r\n\r\n\t// samples the color given env map with CDF and returns the pdf of the direction\r\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tif ( totalSum == 0.0 ) {\r\n\r\n\t\t\tcolor = vec3( 0.0 );\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n\r\n\t// samples a direction of the envmap with color and retrieves pdf\r\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\r\n\r\n\t\t// sample env map cdf\r\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\r\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\r\n\t\tvec2 uv = vec2( u, v );\r\n\r\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\r\n\t\tdirection = derivedDirection;\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n`;\r\n","export const light_sampling_functions = /* glsl */`\r\n\r\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\r\n\r\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\r\n\r\n\t}\r\n\r\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t\t// page 32, equation 26: E[window1]\r\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\r\n\r\n\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn distanceFalloff;\r\n\r\n\t}\r\n\r\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\r\n\r\n\t\tfloat cosTheta = dot( posToLight, lightDir );\r\n\t\tfloat angle = acos( cosTheta ) / PI;\r\n\r\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\r\n\r\n\t}\r\n\r\n\tstruct LightRecord {\r\n\r\n\t\tfloat dist;\r\n\t\tvec3 direction;\r\n\t\tfloat pdf;\r\n\t\tvec3 emission;\r\n\t\tint type;\r\n\r\n\t};\r\n\r\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\r\n\r\n\t\tbool didHit = false;\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\r\n\t\t// check for backface\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\r\n\r\n\t\t\tu *= 1.0 / dot( u, u );\r\n\t\t\tv *= 1.0 / dot( v, v );\r\n\r\n\t\t\tfloat dist;\r\n\r\n\t\t\t// MIS / light intersection is not supported for punctual lights.\r\n\t\t\tif(\r\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\r\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\r\n\t\t\t\tdidHit = true;\r\n\t\t\t\tlightRec.dist = dist;\r\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\r\n\t\t\t\tlightRec.emission = light.color * light.intensity;\r\n\t\t\t\tlightRec.direction = rayDirection;\r\n\t\t\t\tlightRec.type = light.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn didHit;\r\n\r\n\t}\r\n\r\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tvec3 randomPos;\r\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// rectangular area light\r\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\r\n\r\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// circular area light\r\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\r\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\t\tfloat x = r * cos( theta );\r\n\t\t\tfloat y = r * sin( theta );\r\n\r\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\t\tvec3 direction = toLight / dist;\r\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\r\n\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.emission = light.color * light.intensity;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\r\n\t\t// TODO: the denominator is potentially zero\r\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tfloat radius = light.radius * sqrt( ruv.x );\r\n\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\tfloat x = radius * cos( theta );\r\n\t\tfloat y = radius * sin( theta );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\r\n\t\tfloat angle = acos( light.coneCos );\r\n\t\tfloat angleTan = tan( angle );\r\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\r\n\r\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\r\n\t\tvec3 direction = toLight / max( dist, EPSILON );\r\n\t\tfloat cosTheta = dot( direction, normal );\r\n\r\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\r\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\r\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\r\n\r\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\r\n\t\tlightRec.pdf = 1.0;\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\r\n\r\n\t\tLightRecord result;\r\n\r\n\t\t// pick a random light\r\n\t\tuint l = uint( ruv.x * float( lightCount ) );\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\r\n\r\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\r\n\r\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec3 lightRay = light.u - rayOrigin;\r\n\t\t\tfloat lightDist = length( lightRay );\r\n\t\t\tfloat cutoffDistance = light.distance;\r\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\r\n\t\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.direction = normalize( lightRay );\r\n\t\t\trec.dist = length( lightRay );\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\r\n\t\t\trec.type = light.type;\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.dist = 1e10;\r\n\t\t\trec.direction = light.u;\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity;\r\n\t\t\trec.type = light.type;\r\n\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// sample the light\r\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const fresnel_functions = /* glsl */`\r\n\r\n\tbool totalInternalReflection( float cosTheta, float eta ) {\r\n\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\treturn eta * sinTheta > 1.0;\r\n\r\n\t}\r\n\r\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\r\n\tfloat schlickFresnel( float cosine, float f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\r\n\r\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat ni = eta;\r\n\t\tfloat nt = 1.0;\r\n\r\n\t\t// Check for total internal reflection\r\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\r\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\r\n\t\tif( sinThetaTSq >= 1.0 ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\r\n\r\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\r\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\r\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\r\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\r\n\r\n\t}\r\n\r\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\r\n\tfloat iorRatioToF0( float eta ) {\r\n\r\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\r\n\r\n\t}\r\n\r\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\r\n\r\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t\t\treturn f90;\r\n\r\n\t\t}\r\n\r\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\r\n\r\n\t}\r\n\r\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\r\n\t// the glTF but is causing blown out pixels. Should be revisited\r\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\r\n\r\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t// \t\treturn 1.0;\r\n\r\n\t// \t}\r\n\r\n\t// \treturn schlickFresnel( cosTheta, f0 );\r\n\r\n\t// }\r\n\r\n\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\r\n\r\n\t\tfloat dotHV = dot( wo, wh );\r\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat dotHL = dot( wi, wh );\r\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\r\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\r\n\r\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\r\n\r\n\t}\r\n\r\n`;\r\n","export const shape_intersection_functions = /* glsl */`\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the rectangle on that same plane.\r\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\r\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = p - center;\r\n\r\n\t\t\t// check if p falls inside the rectangle\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\r\n\r\n\t\t\t\tfloat a2 = dot( v, vi );\r\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\r\n\r\n\t\t\t\t\tdist = t;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\r\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = hit - position;\r\n\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tfloat a2 = dot( v, vi );\r\n\r\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\r\n\r\n\t\t\t\tdist = t;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const texture_sample_functions = /*glsl */`\r\n\r\n\t// add texel fetch functions for texture arrays\r\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\r\n\r\n\t\tuint width = uint( textureSize( tex, 0 ).x );\r\n\t\tuvec2 uv;\r\n\t\tuv.x = index % width;\r\n\t\tuv.y = index / width;\r\n\r\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\r\n\r\n\t}\r\n\r\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\t\treturn\r\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\r\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\r\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\r\n\r\n\t}\r\n\r\n`;\r\n","export const stratified_functions = /* glsl */`\r\n\r\n\tuniform sampler2D stratifiedTexture;\r\n\tuniform sampler2D stratifiedOffsetTexture;\r\n\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\tvec4 pixelSeed = vec4( 0 );\r\n\r\n\tvec4 rand4( int v ) {\r\n\r\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\r\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\r\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\r\n\r\n\t}\r\n\r\n\tvec3 rand3( int v ) {\r\n\r\n\t\treturn rand4( v ).xyz;\r\n\r\n\t}\r\n\r\n\tvec2 rand2( int v ) {\r\n\r\n\t\treturn rand4( v ).xy;\r\n\r\n\t}\r\n\r\n\tfloat rand( int v ) {\r\n\r\n\t\treturn rand4( v ).x;\r\n\r\n\t}\r\n\r\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\r\n\r\n\t\t// tile the small noise texture across the entire screen\r\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\r\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\r\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\r\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\r\n\r\n\t\t// note that using \"texelFetch\" here seems to break Android for some reason\r\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\r\n\r\n\t}\r\n\r\n`;\r\n","/*\r\nwi     : incident vector or light vector (pointing toward the light)\r\nwo     : outgoing vector or view vector (pointing towards the camera)\r\nwh     : computed half vector from wo and wi\r\nEval   : Get the color and pdf for a direction\r\nSample : Get the direction, color, and pdf for a sample\r\neta    : Greek character used to denote the \"ratio of ior\"\r\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\r\nf90    : Amount of light reflected at grazing angles\r\n*/\r\n\r\nexport const bsdf_functions = /* glsl */`\r\n\r\n\t// diffuse\r\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\r\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\r\n\r\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\r\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\r\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\r\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\r\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\r\n\r\n\t\t// TODO: subsurface approx?\r\n\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\r\n\r\n\t\treturn wi.z / PI;\r\n\r\n\t}\r\n\r\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\r\n\t\tlightDirection.z += 1.0;\r\n\t\tlightDirection = normalize( lightDirection );\r\n\r\n\t\treturn lightDirection;\r\n\r\n\t}\r\n\r\n\t// specular\r\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\r\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\r\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\r\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\r\n\r\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\r\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\r\n\r\n\t\t// PDF\r\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\r\n\t\tfloat incidentTheta = acos( wo.z );\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\r\n\r\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 12 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\r\n\t// transmission\r\n\t/*\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tbool thinFilm = surf.thinFilm;\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\r\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( filteredRoughness ),\r\n\t\t\trand2( 13 )\r\n\t\t);\r\n\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\t*/\r\n\r\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\r\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\t// PDF\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\t// if ( F >= 1.0 ) {\r\n\r\n\t\t// \treturn 0.0;\r\n\r\n\t\t// }\r\n\r\n\t\t// return 1.0 / ( 1.0 - F );\r\n\r\n\t\t// reverted to previous to transmission. The above was causing black pixels\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\t\tfloat cosTheta = min( wo.z, 1.0 );\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\r\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\r\n\t\tif ( cannotRefract ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 1.0 - reflectance );\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\r\n\t// clearcoat\r\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tfloat ior = 1.5;\r\n\t\tfloat f0 = iorRatioToF0( ior );\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\r\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\r\n\r\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\r\n\r\n\t\t// PDF\r\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\r\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 14 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\t// sheen\r\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\r\n\r\n\t\tfloat cosThetaO = saturateCos( wo.z );\r\n\t\tfloat cosThetaI = saturateCos( wi.z );\r\n\t\tfloat cosThetaH = wh.z;\r\n\r\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\r\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\r\n\r\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\t\tvec3 color = surf.sheenColor;\r\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\r\n\t\tcolor *= wi.z;\r\n\r\n\t\treturn color;\r\n\r\n\t}\r\n\r\n\t// bsdf\r\n\tvoid getLobeWeights(\r\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\r\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\r\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\r\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\r\n\r\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\r\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\r\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\r\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\r\n\r\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\r\n\t\tdiffuseWeight /= totalWeight;\r\n\t\tspecularWeight /= totalWeight;\r\n\t\ttransmissionWeight /= totalWeight;\r\n\t\tclearcoatWeight /= totalWeight;\r\n\t}\r\n\r\n\tfloat bsdfEval(\r\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\r\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\r\n\t\tfloat spdf = 0.0;\r\n\t\tfloat dpdf = 0.0;\r\n\t\tfloat tpdf = 0.0;\r\n\t\tfloat cpdf = 0.0;\r\n\t\tcolor = vec3( 0.0 );\r\n\r\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\r\n\r\n\t\t// diffuse\r\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\r\n\t\t\tcolor *= 1.0 - surf.transmission;\r\n\r\n\t\t}\r\n\r\n\t\t// ggx specular\r\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tvec3 outColor;\r\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\r\n\t\t\tcolor += outColor;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\r\n\r\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\t// sheen\r\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\r\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\r\n\r\n\t\t// clearcoat\r\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\r\n\r\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\r\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\tfloat pdf =\r\n\t\t\tdpdf * diffuseWeight\r\n\t\t\t+ spdf * specularWeight\r\n\t\t\t+ tpdf * transmissionWeight\r\n\t\t\t+ cpdf * clearcoatWeight;\r\n\r\n\t\t// retrieve specular rays for the shadows flag\r\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\r\n\r\n\t\treturn pdf;\r\n\r\n\t}\r\n\r\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tcolor = surf.color / ( 4.0 * PI );\r\n\t\t\treturn 1.0 / ( 4.0 * PI );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\r\n\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\r\n\r\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat specularPdf;\r\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\r\n\r\n\t}\r\n\r\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tScatterRecord sampleRec;\r\n\t\t\tsampleRec.specularPdf = 0.0;\r\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\r\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\r\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\r\n\t\t\treturn sampleRec;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tmat3 normalBasis = surf.normalBasis;\r\n\t\tmat3 invBasis = surf.normalInvBasis;\r\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\r\n\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\r\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat pdf[4];\r\n\t\tpdf[0] = diffuseWeight;\r\n\t\tpdf[1] = specularWeight;\r\n\t\tpdf[2] = transmissionWeight;\r\n\t\tpdf[3] = clearcoatWeight;\r\n\r\n\t\tfloat cdf[4];\r\n\t\tcdf[0] = pdf[0];\r\n\t\tcdf[1] = pdf[1] + cdf[0];\r\n\t\tcdf[2] = pdf[2] + cdf[1];\r\n\t\tcdf[3] = pdf[3] + cdf[2];\r\n\r\n\t\tif( cdf[3] != 0.0 ) {\r\n\r\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\r\n\t\t\tcdf[0] *= invMaxCdf;\r\n\t\t\tcdf[1] *= invMaxCdf;\r\n\t\t\tcdf[2] *= invMaxCdf;\r\n\t\t\tcdf[3] *= invMaxCdf;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcdf[0] = 1.0;\r\n\t\t\tcdf[1] = 0.0;\r\n\t\t\tcdf[2] = 0.0;\r\n\t\t\tcdf[3] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wi;\r\n\t\tvec3 clearcoatWi;\r\n\r\n\t\tfloat r = rand( 15 );\r\n\t\tif ( r <= cdf[0] ) { // diffuse\r\n\r\n\t\t\twi = diffuseDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[1] ) { // specular\r\n\r\n\t\t\twi = specularDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\r\n\r\n\t\t\twi = transmissionDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\r\n\r\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\r\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\r\n\r\n\t\t}\r\n\r\n\t\tScatterRecord result;\r\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\r\n\t\tresult.direction = normalize( surf.normalBasis * wi );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const fog_functions = /* glsl */`\r\n\r\n\t// returns the hit distance given the material density\r\n\tfloat intersectFogVolume( Material material, float u ) {\r\n\r\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\r\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\r\n\r\n\t}\r\n\r\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\r\n\r\n\t\tScatterRecord sampleRec;\r\n\t\tsampleRec.specularPdf = 0.0;\r\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\r\n\t\tsampleRec.direction = sampleSphere( uv );\r\n\t\tsampleRec.color = surf.color;\r\n\t\treturn sampleRec;\r\n\r\n\t}\r\n\r\n`;\r\n","export const iridescence_functions = /* glsl */`\r\n\r\n\t// XYZ to sRGB color space\r\n\tconst mat3 XYZ_TO_REC709 = mat3(\r\n\t\t3.2404542, -0.9692660,  0.0556434,\r\n\t\t-1.5371385,  1.8760108, -0.2040259,\r\n\t\t-0.4985314,  0.0415560,  1.0572252\r\n\t);\r\n\r\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\r\n\r\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\r\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\r\n\r\n\t}\r\n\r\n\t// Conversion FO/IOR\r\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\r\n\r\n\t}\r\n\r\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\r\n\r\n\t}\r\n\r\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\r\n\r\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\r\n\r\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\r\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\r\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\r\n\r\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\r\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\r\n\t\txyz /= 1.0685e-7;\r\n\r\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\r\n\t\treturn srgb;\r\n\r\n\t}\r\n\r\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\r\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\r\n\r\n\t\tvec3 I;\r\n\r\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\r\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\r\n\r\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\r\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\r\n\r\n\t\t// Handle TIR:\r\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n\t\tif ( cosTheta2Sq < 0.0 ) {\r\n\r\n\t\t\treturn vec3( 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\r\n\r\n\t\t// First interface\r\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\r\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\r\n\t\tfloat R21 = R12;\r\n\t\tfloat T121 = 1.0 - R12;\r\n\t\tfloat phi12 = 0.0;\r\n\t\tif ( iridescenceIor < outsideIOR ) {\r\n\r\n\t\t\tphi12 = PI;\r\n\r\n\t\t}\r\n\r\n\t\tfloat phi21 = PI - phi12;\r\n\r\n\t\t// Second interface\r\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\r\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\r\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\r\n\t\tvec3 phi23 = vec3( 0.0 );\r\n\t\tif ( baseIOR[0] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 0 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[1] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 1 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[2] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 2 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\t// Phase shift\r\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\r\n\t\tvec3 phi = vec3( phi21 ) + phi23;\r\n\r\n\t\t// Compound terms\r\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\r\n\t\tvec3 r123 = sqrt( R123 );\r\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\r\n\r\n\t\t// Reflectance term for m = 0 (DC term amplitude)\r\n\t\tvec3 C0 = R12 + Rs;\r\n\t\tI = C0;\r\n\r\n\t\t// Reflectance term for m > 0 (pairs of diracs)\r\n\t\tvec3 Cm = Rs - T121;\r\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\r\n\r\n\t\t\tCm *= r123;\r\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\r\n\t\t\tI += Cm * Sm;\r\n\r\n\t\t}\r\n\r\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n\t\treturn max( I, vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n`;\r\n","export const sheen_functions = /* glsl */`\r\n\r\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetD( float cosThetaH, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat invAlpha = 1.0 / alpha;\r\n\r\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\r\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\r\n\r\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\r\n\r\n\t}\r\n\r\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\r\n\r\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\r\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\r\n\r\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\r\n\r\n\t}\r\n\r\n\tfloat velvetL( float x, float alpha ) {\r\n\r\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\r\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\r\n\r\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\r\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\r\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\r\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\r\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\r\n\r\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\r\n\r\n\t}\r\n\r\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetLambda( float cosTheta, float alpha ) {\r\n\r\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\r\n\r\n\t}\r\n\r\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\r\n\r\n\t}\r\n\r\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\r\n\r\n\t\tcosTheta = saturate( cosTheta );\r\n\r\n\t\tfloat c = 1.0 - cosTheta;\r\n\t\tfloat c3 = c * c * c;\r\n\r\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\r\n\r\n\t}\r\n\r\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\r\n\r\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\r\n\r\n\t}\r\n\r\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\r\n\t\treturn 1.0 - maxSheenColor * eWo;\r\n\r\n\t}\r\n\r\n`;\r\n","export const inside_fog_volume_function = /* glsl */`\r\n\r\n#ifndef FOG_CHECK_ITERATIONS\r\n#define FOG_CHECK_ITERATIONS 30\r\n#endif\r\n\r\n// returns whether the given material is a fog material or not\r\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\r\n\r\n\tuint i = materialIndex * uint( MATERIAL_PIXELS );\r\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\r\n\treturn bool( int( s14.b ) & 4 );\r\n\r\n}\r\n\r\n// returns true if we're within the first fog volume we hit\r\nbool bvhIntersectFogVolumeHit(\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\tusampler2D materialIndexAttribute, sampler2D materials,\r\n\tinout Material material\r\n) {\r\n\r\n\tmaterial.fogVolume = false;\r\n\r\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\r\n\r\n\t\t// find nearest hit\r\n\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\tfloat side = 1.0;\r\n\t\tfloat dist = 0.0;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\t\tif ( hit ) {\r\n\r\n\t\t\t// if it's a fog volume return whether we hit the front or back face\r\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\r\n\r\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\r\n\t\t\t\treturn side == - 1.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// move the ray forward\r\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n`;\r\n","export const attenuate_hit_function = /* glsl */`\r\n\r\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\r\n\t// returns true if a solid surface was hit\r\n\tbool attenuateHit(\r\n\t\tRenderState state,\r\n\t\tRay ray, float rayDist,\r\n\t\tout vec3 color\r\n\t) {\r\n\r\n\t\t// store the original bounce index so we can reset it after\r\n\t\tuint originalBounceIndex = sobolBounceIndex;\r\n\r\n\t\tint traversals = state.traversals;\r\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\r\n\t\tbool isShadowRay = state.isShadowRay;\r\n\t\tMaterial fogMaterial = state.fogMaterial;\r\n\r\n\t\tvec3 startPoint = ray.origin;\r\n\r\n\t\t// hit results\r\n\t\tSurfaceHit surfaceHit;\r\n\r\n\t\tcolor = vec3( 1.0 );\r\n\r\n\t\tbool result = true;\r\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\r\n\r\n\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\r\n\r\n\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\tresult = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\r\n\r\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\r\n\t\t\t\tif ( totalDist > rayDist ) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\r\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\r\n\t\t\t\t// TODO: should we account for emissive surfaces here?\r\n\r\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t// adjust the ray to the new surface\r\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\r\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\t\t\tfogMaterial = material;\r\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t\t\t// albedo\r\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\t\t\talbedo *= vertexColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// alphaMap\r\n\t\t\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transmission\r\n\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// metalness\r\n\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\r\n\t\t\t\tif (\r\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\r\n\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\r\n\r\n\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tresult = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\r\n\r\n\t\t\t\t\t// only attenuate by surface color on the way in\r\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\r\n\r\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\r\n\r\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\r\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the bounce index\r\n\t\tsobolBounceIndex = originalBounceIndex;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const camera_util_functions = /* glsl */`\r\n\r\n\tvec3 ndcToRayOrigin( vec2 coord ) {\r\n\r\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\r\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\r\n\t}\r\n\r\n\tRay getCameraRay() {\r\n\r\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\r\n\r\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\r\n\t\t// around this pixel's UV coordinate for AA\r\n\t\tvec2 ruv = rand2( 0 );\r\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\r\n\t\tRay ray;\r\n\r\n\t\t#if CAMERA_TYPE == 2\r\n\r\n\t\t\t// Equirectangular projection\r\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\r\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\r\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\r\n\r\n\t\t\tray.direction = normalize( rayDirection4.xyz );\r\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\r\n\r\n\t\t#else\r\n\r\n\t\t\t// get [- 1, 1] normalized device coordinates\r\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\r\n\t\t\tray.origin = ndcToRayOrigin( ndc );\r\n\r\n\t\t\t#if CAMERA_TYPE == 1\r\n\r\n\t\t\t\t// Orthographic projection\r\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\r\n\t\t\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// Perspective projection\r\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\r\n\t\t#if FEATURE_DOF\r\n\t\t{\r\n\r\n\t\t\t// depth of field\r\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\r\n\r\n\t\t\t// get the aperture sample\r\n\t\t\t// if blades === 0 then we assume a circle\r\n\t\t\tvec3 shapeUVW= rand3( 1 );\r\n\t\t\tint blades = physicalCamera.apertureBlades;\r\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\r\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\r\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\r\n\r\n\t\t\t// rotate the aperture shape\r\n\t\t\tapertureSample =\r\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\r\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\r\n\r\n\t\t\t// create the new ray\r\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\r\n\t\t\tray.direction = focalPoint - ray.origin;\r\n\r\n\t\t}\r\n\t\t#endif\r\n\r\n\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\treturn ray;\r\n\r\n\t}\r\n\r\n`;\r\n","export const direct_light_contribution_function = /*glsl*/`\r\n\r\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\r\n\r\n\t\tvec3 result = vec3( 0.0 );\r\n\r\n\t\t// uniformly pick a light or environment map\r\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\r\n\r\n\t\t\t// sample a light or environment\r\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\r\n\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tlightRec.pdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the light area\r\n\t\t\tRay lightRay;\r\n\t\t\tlightRay.origin = rayOrigin;\r\n\t\t\tlightRay.direction = lightRec.direction;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tlightRec.pdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\r\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\r\n\r\n\t\t\t// find a sample in the environment map to include in the contribution\r\n\t\t\tvec3 envColor, envDirection;\r\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\r\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\r\n\r\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\r\n\t\t\t// results so we ignore the sample in this case.\r\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tenvPdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the surface\r\n\t\t\tRay envRay;\r\n\t\t\tenvRay.origin = rayOrigin;\r\n\t\t\tenvRay.direction = envDirection;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tenvPdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tenvPdf /= lightsDenom;\r\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\r\n\t\t// See issue #470\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const get_surface_record_function = /* glsl */`\r\n\r\n\t#define SKIP_SURFACE 0\r\n\t#define HIT_SURFACE 1\r\n\tint getSurfaceRecord(\r\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\r\n\t\tfloat accumulatedRoughness,\r\n\t\tinout SurfaceRecord surf\r\n\t) {\r\n\r\n\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\r\n\r\n\t\t\tSurfaceRecord fogSurface;\r\n\t\t\tfogSurface.volumeParticle = true;\r\n\t\t\tfogSurface.color = material.color;\r\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\r\n\t\t\tfogSurface.normal = normal;\r\n\t\t\tfogSurface.faceNormal = normal;\r\n\t\t\tfogSurface.clearcoatNormal = normal;\r\n\r\n\t\t\tsurf = fogSurface;\r\n\t\t\treturn HIT_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// uv coord for textures\r\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t// albedo\r\n\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\talbedo *= vertexColor;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMap\r\n\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t}\r\n\r\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\r\n\t\t// and it's single sided.\r\n\t\t// - alpha test is disabled when it === 0\r\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\r\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\r\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\r\n\t\tfloat alphaTest = material.alphaTest;\r\n\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\tif (\r\n\t\t\t// material sidedness\r\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\r\n\r\n\t\t\t// alpha test\r\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t// opacity\r\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\r\n\t\t) {\r\n\r\n\t\t\treturn SKIP_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// fetch the interpolated smooth normal\r\n\t\tvec3 normal = normalize( textureSampleBarycoord(\r\n\t\t\tattributesArray,\r\n\t\t\tATTR_NORMAL,\r\n\t\t\tsurfaceHit.barycoord,\r\n\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t).xyz );\r\n\r\n\t\t// roughness\r\n\t\tfloat roughness = material.roughness;\r\n\t\tif ( material.roughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\r\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// metalness\r\n\t\tfloat metalness = material.metalness;\r\n\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t}\r\n\r\n\t\t// emission\r\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\r\n\t\tif ( material.emissiveMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\r\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tfloat transmission = material.transmission;\r\n\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// normal\r\n\t\tif ( material.flatShading ) {\r\n\r\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\r\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\r\n\t\t\t// interpolated vertex normals.\r\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 baseNormal = normal;\r\n\t\tif ( material.normalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.normalScale;\r\n\t\t\t\tnormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnormal *= surfaceHit.side;\r\n\r\n\t\t// clearcoat\r\n\t\tfloat clearcoat = material.clearcoat;\r\n\t\tif ( material.clearcoatMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatRoughness\r\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\r\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatNormal\r\n\t\tvec3 clearcoatNormal = baseNormal;\r\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\r\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclearcoatNormal *= surfaceHit.side;\r\n\r\n\t\t// sheenColor\r\n\t\tvec3 sheenColor = material.sheenColor;\r\n\t\tif ( material.sheenColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// sheenRoughness\r\n\t\tfloat sheenRoughness = material.sheenRoughness;\r\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence = material.iridescence;\r\n\t\tif ( material.iridescenceMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\r\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence thickness\r\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\r\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\r\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\r\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\r\n\r\n\t\t}\r\n\r\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\r\n\r\n\t\t// specular color\r\n\t\tvec3 specularColor = material.specularColor;\r\n\t\tif ( material.specularColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// specular intensity\r\n\t\tfloat specularIntensity = material.specularIntensity;\r\n\t\tif ( material.specularIntensityMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\tsurf.volumeParticle = false;\r\n\r\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\r\n\t\tsurf.normal = normal;\r\n\r\n\t\tsurf.metalness = metalness;\r\n\t\tsurf.color = albedo.rgb;\r\n\t\tsurf.emission = emission;\r\n\r\n\t\tsurf.ior = material.ior;\r\n\t\tsurf.transmission = transmission;\r\n\t\tsurf.thinFilm = material.thinFilm;\r\n\t\tsurf.attenuationColor = material.attenuationColor;\r\n\t\tsurf.attenuationDistance = material.attenuationDistance;\r\n\r\n\t\tsurf.clearcoatNormal = clearcoatNormal;\r\n\t\tsurf.clearcoat = clearcoat;\r\n\r\n\t\tsurf.sheen = material.sheen;\r\n\t\tsurf.sheenColor = sheenColor;\r\n\r\n\t\tsurf.iridescence = iridescence;\r\n\t\tsurf.iridescenceIor = material.iridescenceIor;\r\n\t\tsurf.iridescenceThickness = iridescenceThickness;\r\n\r\n\t\tsurf.specularColor = specularColor;\r\n\t\tsurf.specularIntensity = specularIntensity;\r\n\r\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\r\n\t\t// applied by its brdf function\r\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\r\n\t\tsurf.roughness = roughness * roughness;\r\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\r\n\t\tsurf.sheenRoughness = sheenRoughness;\r\n\r\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\r\n\t\t// then we can just always assume this is a front face.\r\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\r\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\r\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\r\n\r\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\r\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\r\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\r\n\t\t// sharp internal reflections\r\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\r\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\r\n\r\n\t\t// get the normal frames\r\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\r\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\r\n\r\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\r\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\r\n\r\n\t\treturn HIT_SURFACE;\r\n\r\n\t}\r\n`;\r\n","export const render_structs = /* glsl */`\r\n\r\n\tstruct Ray {\r\n\r\n\t\tvec3 origin;\r\n\t\tvec3 direction;\r\n\r\n\t};\r\n\r\n\tstruct SurfaceHit {\r\n\r\n\t\tuvec4 faceIndices;\r\n\t\tvec3 barycoord;\r\n\t\tvec3 faceNormal;\r\n\t\tfloat side;\r\n\t\tfloat dist;\r\n\r\n\t};\r\n\r\n\tstruct RenderState {\r\n\r\n\t\tbool firstRay;\r\n\t\tbool transmissiveRay;\r\n\t\tbool isShadowRay;\r\n\t\tfloat accumulatedRoughness;\r\n\t\tint transmissiveTraversals;\r\n\t\tint traversals;\r\n\t\tuint depth;\r\n\t\tvec3 throughputColor;\r\n\t\tMaterial fogMaterial;\r\n\r\n\t};\r\n\r\n\tRenderState initRenderState() {\r\n\r\n\t\tRenderState result;\r\n\t\tresult.firstRay = true;\r\n\t\tresult.transmissiveRay = true;\r\n\t\tresult.isShadowRay = false;\r\n\t\tresult.accumulatedRoughness = 0.0;\r\n\t\tresult.transmissiveTraversals = 0;\r\n\t\tresult.traversals = 0;\r\n\t\tresult.throughputColor = vec3( 1.0 );\r\n\t\tresult.depth = 0u;\r\n\t\tresult.fogMaterial.fogVolume = false;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const trace_scene_function = /* glsl */`\r\n\r\n\t#define NO_HIT 0\r\n\t#define SURFACE_HIT 1\r\n\t#define LIGHT_HIT 2\r\n\t#define FOG_HIT 3\r\n\r\n\t// Passing the global variable 'lights' into this function caused shader program errors.\r\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\r\n\t// For more information, refer to: https://github.com/disini/three-gpu-pathtracer/pull/457\r\n\tint traceScene(\r\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\r\n\t) {\r\n\r\n\t\tint result = NO_HIT;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\r\n\r\n\t\t#if FEATURE_FOG\r\n\r\n\t\tif ( fogMaterial.fogVolume ) {\r\n\r\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\r\n\t\t\t// as other objects\r\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\r\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\r\n\r\n\t\t\t\tsurfaceHit.side = 1.0;\r\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\r\n\t\t\t\tsurfaceHit.dist = particleDist;\r\n\t\t\t\treturn FOG_HIT;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t\tif ( hit ) {\r\n\r\n\t\t\tresult = SURFACE_HIT;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$d0f249dd9f03ac59$export$196da6cc71a4331","$ilwiq","$RPVlj","$4dqlL","$9kitj","$ieQ3q","$d0f249dd9f03ac59$var$renderTask","_renderer","_fsQuad","_blendQuad","_primaryTarget","_blendTargets","_sobolTarget","_subframe","alpha","material","_ogScissor","Vector4","_ogViewport","blendMaterial","blendTarget1","blendTarget2","opacity","_opacityFactor","samples","blending","NoBlending","NormalBlending","subX","subY","subW","subH","w","width","h","height","resolution","sobolTexture","texture","stratifiedTexture","bounces","transmissiveBounces","next","seed","tilesX","tiles","x","tilesY","y","totalTiles","pxSubW","Math","ceil","pxSubH","pxSubX","floor","pxSubY","pxTileW","pxTileH","ogRenderTarget","getRenderTarget","ogAutoClear","autoClear","ogScissorTest","getScissorTest","getScissor","getViewport","tx","ty","stableTiles","tileIndex","_currentTile","reverseTy","scissor","min","viewport","setRenderTarget","setScissorTest","render","setViewport","setScissor","target1","target2","round","$d0f249dd9f03ac59$var$ogClearColor","Color","removeEventListener","_compileFunction","addEventListener","target","_alpha","dispose","reset","isCompiling","Boolean","_compilePromise","constructor","renderer","camera","Vector2","stableNoise","FullScreenQuad","PhysicalPathTracingMaterial","BlendMaterial","_task","SobolNumberMapGenerator","generate","WebGLRenderTarget","format","RGBAFormat","type","FloatType","magFilter","NearestFilter","minFilter","promise","compileMaterial","_mesh","then","compileAsync","setCamera","cameraWorldMatrix","copy","matrixWorld","invProjectionMatrix","projectionMatrixInverse","physicalCamera","updateFrom","cameraType","projectionMatrix","elements","isEquirectCamera","setDefine","setSize","getSize","ogClearAlpha","getClearAlpha","getClearColor","setClearColor","clearColor","update","onBeforeRender","$311cd0e92e040f64$export$70ee8b3cbd6f21d8","$9fZ6X","MaterialBase","parameters","uniforms","value","vertexShader","fragmentShader","setValues","$6ca44f672d576995$export$4e8e5459f15b1dca","$ffLvN","$6ca44f672d576995$var$SobolNumbersMaterial","sobol_common","sobol_point_generation","dimensions","generateMipmaps","ogTarget","quad","$b1ad1c9578ecec04$var$generateSobolFunctionVariants","dim","$b1ad1c9578ecec04$var$generateSobolSampleFunctions","utype","vtype","num","components","combineValues","$b1ad1c9578ecec04$export$603c58c7e29c9b0","$b1ad1c9578ecec04$export$96e4d35266bd337b","$b1ad1c9578ecec04$export$79b4ab6803c188d5","$d471e9adcf389a5c$export$746cbc9e65f5bcb8","$2vjHu","$3mzmA","$hN8zD","$iyhQ7","$kAJM1","$TWVPU","$6Q19u","$laA5G","$12pjC","$k5Ikv","$hLXJE","$sORjD","$WBvYF","$1QwjS","$1r4sY","$asLEI","$6VF8W","$232IN","$cp6U0","$8KxWl","$fYvb1","$d9skn","$jpfro","$dUUQZ","$kmALz","$gCBx4","$6voD8","$4GDCw","$8keuf","$9kAYu","$5SszG","$hB5SN","$1zk7M","$eJ3gD","$eZnIg","$bwtQK","$ioRiK","$euI5d","bokehSize","backgroundMap","materials","features","isUsed","transparent","depthWrite","defines","FEATURE_MIS","FEATURE_RUSSIAN_ROULETTE","FEATURE_DOF","FEATURE_BACKGROUND_MAP","FEATURE_FOG","RANDOM_TYPE","CAMERA_TYPE","DEBUG_MODE","ATTR_NORMAL","ATTR_TANGENT","ATTR_UV","ATTR_COLOR","MATERIAL_PIXELS","filterGlossyFactor","PhysicalCameraUniform","Matrix4","bvh","MeshBVHUniformStruct","attributesArray","AttributesTextureArray","materialIndexAttribute","UIntVertexAttributeTexture","MaterialsTexture","textures","RenderTarget2DArray","lights","LightsInfoUniformStruct","iesProfiles","HalfFloatType","wrapS","ClampToEdgeWrapping","wrapT","environmentIntensity","environmentRotation","envMapInfo","EquirectHdrInfoUniform","backgroundBlur","backgroundAlpha","backgroundIntensity","backgroundRotation","StratifiedSamplesTexture","stratifiedOffsetTexture","BlueNoiseTexture","common_functions","bvh_struct_definitions","bvh_ray_functions","camera_struct","lights_struct","equirect_struct","material_struct","surface_record_struct","stratified_functions","pcg_functions","sobol_functions","texture_sample_functions","fresnel_functions","util_functions","math_functions","shape_intersection_functions","shape_sampling_functions","equirect_functions","light_sampling_functions","inside_fog_volume_function","ggx_functions","sheen_functions","iridescence_functions","fog_functions","bsdf_functions","render_structs","camera_util_functions","trace_scene_function","attenuate_hit_function","direct_light_contribution_function","get_surface_record_function","$d8193d8a8d6141d1$export$2e27c77dea3c9d73","$kLfIo","apertureBlades","apertureRotation","focusDistance","anamorphicRatio","PhysicalCamera","$f1d46319b05d893e$export$baf85f88dacad6d5","PerspectiveCamera","size","fStop","getFocalLength","args","source","recursive","$efdaad16b8cd905b$export$e5a77e5d6a85a862","$2vGrm","$efdaad16b8cd905b$var$binarySearchFindClosestIndexOf","array","targetValue","offset","count","length","lower","upper","mid","blackTex","DataTexture","toHalfFloatArray","Float32Array","LinearFilter","RepeatWrapping","needsUpdate","marginalWeights","RedFormat","conditionalWeights","map","totalSum","hdr","$efdaad16b8cd905b$var$preprocessEnvMap","envMap","targetType","clone","Source","image","data","newData","maxIntValue","Uint16Array","Int8Array","Int16Array","Int32Array","BYTES_PER_ELEMENT","i","l","DataUtils","fromHalfFloat","toHalfFloat","flipY","ogData","slice","newY","ogIndex","newIndex","pdfConditional","cdfConditional","pdfMarginal","cdfMarginal","totalSumValue","cumulativeWeightMarginal","cumulativeRowWeight","weight","marginalDataArray","conditionalDataArray","row","col","$1d3f65c6c5f4f52a$export$8090c803d9d233c2","f32Array","f16Array","$0a82d9ce12cf98b8$export$bb02c0eb15767758","$6ply6","$0a82d9ce12cf98b8$var$u","Vector3","$0a82d9ce12cf98b8$var$v","$0a82d9ce12cf98b8$var$m","$0a82d9ce12cf98b8$var$worldQuaternion","Quaternion","$0a82d9ce12cf98b8$var$eye","$0a82d9ce12cf98b8$var$target","$0a82d9ce12cf98b8$var$up","tex","iesTextures","dimension","sqrt","max","floatArray","baseIndex","index","p","$0a82d9ce12cf98b8$var$LIGHT_PIXELS","getWorldPosition","z","isRectAreaLight","isCircular","isSpotLight","isDirectionalLight","isPointLight","color","r","g","b","intensity","getWorldQuaternion","applyQuaternion","cross","PI","radius","setFromMatrixPosition","lookAt","setFromRotationMatrix","decay","distance","cos","angle","penumbra","iesMap","indexOf","worldPosition","targetPosition","subVectors","normalize","hash","bufferToHash","buffer","$4fa87e2831d7f36b$export$2e089d4ee1364df8","$7Ie7O","FloatAttributeTextureArray","updateNormalAttribute","attr","updateAttribute","updateTangentAttribute","updateUvAttribute","updateColorAttribute","normal","tangent","uv","setAttributes","$59d79964e8fc761c$export$74918e5550c6edfc","$59d79964e8fc761c$var$copyArrayToArray","fromArray","fromStride","toArray","toStride","bpe","maxValue","Uint8Array","Uint32Array","i4","is","j","DataArrayTexture","_textures","internalFormat","baseImage","itemSize","attrs","itemCount","attrsLength","FloatVertexAttributeTexture","push","pop","baseTexture","depth","$f69686fae5159582$export$c4a81a0bfb84e9fe","$f69686fae5159582$export$ae96f3619813ce17","$9wqOU","$f69686fae5159582$var$MaterialFeatures","_features","feature","setUsed","used","getTexture","key","def","textureLookUp","getTextureHash","getField","writeTextureMatrixToArray","textureKey","isTexture","matrixAutoUpdate","updateMatrix","matrix","m","isFogVolumeMaterial","emissive","density","normalScale","clearcoatNormalScale","sheenColor","iridescenceThicknessRange","specularColor","isThinFilm","Infinity","Number","attenuationColor","alphaTest","transmission","side","FrontSide","BackSide","DoubleSide","vertexColors","flatShading","$6eebe81d767f0e44$var$uuidSort","a","uuid","$6eebe81d767f0e44$export$62c3d260e4e2abca","t","colorSpace","$6eebe81d767f0e44$export$b22c535c66112848","Array","from","Set","filter","sort","$6eebe81d767f0e44$export$560c941db545ef55","textureSet","add","$6eebe81d767f0e44$var$reduceTexturesToUniqueSources","sourceSet","result","has","$6eebe81d767f0e44$export$3ae1ccb94aa877f9","scene","traverse","c","visible","$0c199d70d276a61d$export$dbbaa51cb2d0b2f7","$0c199d70d276a61d$var$prevColor","WebGLArrayRenderTarget","options","textureOptions","UnsignedByteType","$0c199d70d276a61d$var$assignOptions","setTextures","hashes","fsQuad","$0c199d70d276a61d$var$CopyMaterial","prevRenderTarget","prevToneMapping","toneMapping","prevAlpha","fill","NoToneMapping","updated","version","isWebGLRenderTarget","identity","ShaderMaterial","$ea06a939ea8d5f41$export$ed86923a2d1cdb9","$50JN2","$ea06a939ea8d5f41$var$RandomGenerator","nextInt","nextFloat","strata","sampler","generator","random","StratifiedSamplerCombined","$3a6078c8a44ac239$export$ec2d5f3091da4863","$1mKfc","strataCount","listOfDimensions","totalDim","combined","strataObjs","StratifiedSampler","reshuffle","$0febb7a1dd1bc005$export$4811b65fd3eaefe6","$0febb7a1dd1bc005$export$448332262467e042","arr","stratum","$cf0529a3c8d7a87e$export$df8ca2ad0d82597a","$7Afqk","channels","BlueNoiseGenerator","stride","$cf0529a3c8d7a87e$var$getFormat","RGFormat","bin","l2","$5857dc03ab71e5c3$export$395052bf180baf1f","$3voRb","$dfd8t","sigma","majorityPointsRatio","BlueNoiseSamples","savedSamples","rank","resize","setSigma","initialSamples","binaryPattern","fillWithOnes","shuffleArray","addPointIndex","clusterIndex","findCluster","removePointIndex","voidIndex","findVoid","ditherArray","totalSize","invert","$28d78c69b5764593$export$7ac3a88d34a76e7","replaceIndex","tmp","$28d78c69b5764593$export$50dc72eec73f3f5d","$9a46dd8a24c94e3f$export$ce82934b5dfddd2e","lookupTable","score","currValue","currIndex","pScore","lookupWidth","sigma2","dist2","E","updateScore","multiplier","px","py","sx","sy","sindex","$056a1129e103f8a3$export$ff29bcb3325786f4","$0b02848bbcd9659f$export$55a5ad677f09b429","$1583b7c3c4aba100$export$b8142914126932cc","$79e17c5d028db7ed$export$d11a3e67165e5cc8","$50b7fb1d651b0127$export$8450b254896ea12","$17ddf9091b3b4093$export$a22775c3497c2ab8","$65ecf25fdf796e21$export$2f3e20d8a82fe5e3","$993216e4b4262820$export$c580e1bca0d1e835","$e20c545bebebbdde$export$4c62bb41ef52ef46","$c19d4f19383277fc$export$a7b9b03dc39b0c39","$4bc8be5fc03f5cd3$export$c0d7886d8c99f58c","$3699d1726d2f89b6$export$7e0eb49b04f8be76","$6cb2a9b144b85589$export$c5fa12fdf656cb44","$44782939f1da8c08$export$41b398d23411fca","$ccfa748eb10216c5$export$9b383298f1837cb1","$1248aba150c298a9$export$2cef3f20f6a7d7fc","$ab87cd757b5ff812$export$4f78a71f798e1125","$ae99281879ede2b8$export$dfc473f79b3116e1","$8639d66b89a7dedc$export$4b59180d6e57d4f","$d653d06e472927b5$export$dd7d5457c7c15273","$a8d61006286aaacf$export$32c6608be890cd25"],"version":3,"file":"areaLight.5654e8b2.js.map"}