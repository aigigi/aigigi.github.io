{"mappings":"IqBoCI,ECm2ME,EL31MF,EAAY,EAAU,EACtB,EAAQ,EACR,EAAQ,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,IKpCP,ECFD,EACA,EAkFA,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,a,I,G,I,E,E,QtB/EJ,OAAM,UAAmB,EAAA,iBAAgB,CAExC,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAEP,IAAI,CAAC,IAAI,CAAG,EAAA,aAAY,AAEzB,CAIA,MAAO,CAAM,CAAG,KAgVX,EAAM,EACN,EA/UJ,IAMC,EAAa,SAAW,CAAe,CAAE,CAAG,EAE3C,OAAS,GAER,KARgB,EAQM,MAAM,AAAI,MAAO,iCAAqC,CAAA,GAAO,EAAA,EACnF,MARiB,EAQM,MAAM,AAAI,MAAO,kCAAsC,CAAA,GAAO,EAAA,EACrF,MARkB,EAQM,MAAM,AAAI,MAAO,sCAA0C,CAAA,GAAO,EAAA,EAC1F,SACwB,MAAM,AAAI,MAAO,mCAAuC,CAAA,GAAO,EAAA,EAExF,CAED,EAiBA,EAAQ,SAAW,CAAM,CAAE,CAAS,CAAE,CAAO,EAI5C,EAAY,AAAE,GAAY,KAC1B,IAAI,EAAI,EAAO,GAAG,CACjB,EAAI,GAAK,EAAM,EAAG,EAAI,GACtB,EAAQ,OAAO,YAAY,CAAC,KAAK,CAAE,KAAM,IAAI,YAAa,EAAO,QAAQ,CAAE,EAAG,EAL7D,OAOlB,KAAU,EAAM,CAAA,EAAI,EAAM,OAAO,CAXxB,KAW0B,GAAmB,EAAM,GAAiB,EAAI,EAAO,UAAU,EAEjG,GAAK,EAAO,GAAO,EAAM,MAAM,CAC/B,GAViB,IAWjB,GAAS,OAAO,YAAY,CAAC,KAAK,CAAE,KAAM,IAAI,YAAa,EAAO,QAAQ,CAAE,EAAG,EAX9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,CAAC,AAzcnD,EAyc0D,MAAS,CAAC,AAAA,EACzE,AA1cK,EA0cE,MAAS,CAAC,MAAM,EAC/B,KAsCqB,EAAA,EAtCT,AA3cC,EA2cM,MAAS,CAAC,KAAK,GAuCnC,EAAa,OAAO,CAAC,EAxCnB,CAIF,GAAqB,EACpB,IAmzLG,GAAkB,IAyBlB,AA3xMU,EA2xMH,SAAY,EACrB,AA5xMY,EA4xML,SAAY,CAAC,cACpB,WAAW,WACZ,WAAW,WACT,AA/xMW,EA+xMJ,SAAY,CAAC,GACtB,EAAG,GACH,GACC,EAAG,IAGH,IAEF,KACC,CAyCA,GAtkBA,AA3wLa,EA2wLN,YAAe,CAAG,GAAoB,gBAC7C,AA5wLa,EA4wLN,cAAiB,CAAG,GAAoB,kBAC/C,AA7wLa,EA6wLN,cAAiB,CAAG,GAAoB,kBAC/C,AA9wLa,EA8wLN,eAAkB,CAAG,GAAoB,mBAChD,AA/wLa,EA+wLN,gBAAmB,CAAG,GAAoB,oBAgQjD,AAxL4B,CAC7B,gBACA,uBACA,yBACA,uBACA,yBACA,iBACA,iBACA,sBACA,sBACA,eACA,WACA,YACA,YACA,YACA,YACA,eACA,gBACA,gBACA,eACA,gBACA,4BACA,gBACA,UACA,UACA,aACA,yBACA,uBACA,sBACA,mBACA,YACA,cACA,oBACA,aACA,cACA,eACA,aACA,WACA,QACA,QACA,gBACA,iBACA,mBACA,0BACA,oBACA,iBACA,qBACA,cACA,iBACA,iBACA,SACA,SACA,SACA,eACA,mBACA,gBACA,kBACA,sBACA,2BACA,yBACA,kBACA,wBACA,wBACA,qBACA,6BACA,6BACA,0BACA,6BACA,iCACA,yCACA,4BACA,oCACA,oBACA,iCACA,yCACA,gCACA,wCACA,6BACA,qCACA,0BACA,mCACA,wBACA,eACA,wCACA,sBACA,iCACA,yCACA,wCACA,qBACA,gCACA,wCACA,6BACA,uBACA,+BACA,oCACA,uBACA,UACA,+BACA,uBACA,uBACA,eACA,aACA,iBACA,yBACA,yBACA,uBACA,iBACA,sBACA,wBACA,uBACA,aACA,cACA,gBACA,sBACA,oBACA,cACA,kBACA,mBACA,YACA,eACA,sBACA,yBACA,8BACA,sCACA,uCACA,kCACA,gCACA,qBACA,gCACA,iCACA,iCACA,gBACA,4BACA,0BACA,6CACA,uBACA,iCACA,+BACA,eACA,6BACA,qBACA,cACA,iBACA,YACA,eACA,cACA,WACA,sBACA,qBACA,sBACA,cACA,mBACA,4BACA,8BACA,uBACA,4BACA,4BACA,2BACA,2BACA,sCACA,yCACA,yBACA,oBACA,iCACA,gBACA,qBACA,kBACA,kBACA,kBACA,mBACA,cACA,8BACA,sBACA,mBACA,kBACA,6BACA,kBACA,gBACA,eACA,sBACA,mBACA,oBACA,wBACE,CACqB,OAAO,CA1oK7B,SAA8B,CAAG,EACR,aAAtB,OAAO,YAA+B,OAAO,wBAAwB,CAAC,WAAY,IACpF,OAAO,cAAc,CAAC,WAAY,EAAK,CACxC,aAAc,CAAA,EACd,MAGE,IAAI,EAAM,IAAM,EAAM,iJAIlB,EAAgB,EACf,EAAc,UAAU,CAAC,MAC/B,CAAA,EAAgB,IAAM,CADrB,EAGA,GAAO,8CAAgD,EAAgB,KACnE,GAA4B,IACjC,CAAA,GAAO,0FADN,EAGA,GAAS,EAEX,CACC,GAIF,GAAwB,EACvB,GA4yKA,AA3LwB,CACzB,MACA,cACA,YACA,eACA,YACA,eACA,mBACA,sBACA,kBACA,gBACA,oBACA,gBACA,kBACA,cACA,MACA,MACA,WACA,QACA,aACA,cACA,aACA,YACA,eACA,cACA,cACA,mBACA,mBACA,6BACA,cACA,aACA,SACA,aACA,aACA,MACA,qBACA,kBACA,gCACA,6BACA,aACA,WACA,UACA,cACA,iBACA,MACA,YACA,UACA,iBACA,aACA,SACA,WACA,eACA,qBACA,oBACA,gBACA,eACA,UACA,kBACA,mBACA,YACA,cACA,YACA,sBACA,kBACA,YACA,gBACA,mBACA,sBACA,WACA,WACA,OACA,UACA,cACA,oBACA,eACA,oBACA,eACA,kBACA,qBACA,gBACA,eACA,gBACA,gBACA,mBACA,gBACA,gBACA,mBACA,qBACA,WACA,qBACA,4BACA,0BACA,WACA,cACA,aACA,gBACA,UACA,WACA,aACA,yBACA,gBACA,kBACA,gBACA,UACA,OACA,WACA,iBACA,yBACA,uBACA,aACA,0BACA,mBACA,KACA,oBACA,QACA,MACA,SACA,SACA,uBACA,4BACA,0BACA,KACA,qCACA,KACA,OACA,MACA,OACA,WACA,MACA,UACA,eACA,sBACA,gBACA,eACA,qBACA,oBACA,kBACA,uBACA,mBACA,qBACA,sBACA,qBACA,gCACA,mBACA,wBACA,mBACA,cACA,kBACA,sBACA,wBACA,mBACA,mBACA,sBACA,wBACA,sBACA,qBACA,sBACA,cACA,sBACA,aACA,sBACA,qBACA,eACA,8BACA,4BACA,6BACA,cACA,iBACA,UACA,uBACA,0BACA,uBACA,uBACA,gBACA,gBACA,SACA,SACA,wBACA,gBACA,gBACA,aACA,sBACA,oBACA,QACA,eACA,sBACE,CACiB,OAAO,CAAC,IAM1B,GAAwB,SAAS,IAE7B,GAAW,KACX,GAAW,CAAA,GAAwB,CAAA,CACvC,EA2HI,AAj1MS,EAi1MF,OAAU,CAEtB,IADgC,YAA5B,OAAO,AAl1MG,EAk1MI,OAAU,EAAgB,CAAA,AAl1M9B,EAk1MqC,OAAU,CAAG,CAAC,AAl1MnD,EAk1M0D,OAAU,CAAC,AAAA,EAC5E,AAn1MO,EAm1MA,OAAU,CAAC,MAAM,CAAG,GAChC,AAp1MY,EAo1ML,OAAU,CAAC,GAAG,KAKtB,IAAI,GAAe,CAAA,EAUpB,OARK,AA31MS,EA21MF,YAAe,EAAE,CAAA,GAAe,CAAA,CAA3C,EAEA,KAMM,EAAU,KAAK,AACrB,GAcA,MAAM,GAAa,UACb,GACJ,CAAA,EAAU,MAAM,IADjB,EAGO,GA8KF,GAAqB,MAAO,IACjC,IAAM,EAAM,MAAM,KAClB,GAAI,AAAgC,eAAhC,EAAe,GAAG,CAAC,QAAQ,CAC9B,MAAM,AAAI,MAAM,yDACjB,GAAI,AAAoC,eAApC,EAAe,OAAO,CAAC,QAAQ,CAClC,MAAM,AAAI,MAAM,4DACjB,OAAO,EAAI,aAAa,CAAC,EAAe,GAAG,CAAC,KAAK,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","sources":["<anon>","node_modules/three/examples/jsm/loaders/RGBELoader.js","node_modules/three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js","node_modules/three-mesh-bvh/src/workers/utils/WorkerBase.js","node_modules/three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js","node_modules/@parcel/runtime-js/lib/runtime-1c6990855bd7ff8d.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js","node_modules/@parcel/runtime-js/lib/runtime-c3f6ca7a2f7d9043.js","example/utils/LoaderElement.js","example/utils/generateRadialFloorTexture.js","node_modules/@parcel/runtime-js/lib/runtime-5025f3b009168116.js","node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","example/utils/getScaledSettings.js","src/materials/MaterialBase.js","src/shader/common/math_functions.glsl.js","src/shader/common/util_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","example/hdr.js","example/utils/HDRImageGenerator.js","node_modules/@monogrid/gainmap-js/dist/encode.js","node_modules/@monogrid/gainmap-js/dist/compress-D7K92XO0.js","node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js","example/libs/libultrahdr.js","node_modules/process/browser.js","node_modules/@parcel/runtime-js/lib/runtime-112f93138a3c03a1.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"891vQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"RGBELoader\", () => $5ee05658f4b0e3bf$export$d076a711b55c758a);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\nclass $5ee05658f4b0e3bf$export$d076a711b55c758a extends (0, $ilwiq.DataTextureLoader) {\n    constructor(manager){\n        super(manager);\n        this.type = (0, $ilwiq.HalfFloatType);\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const /* default error routine.  change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0,\n        //RGBE_DATA_GREEN = 1,\n        //RGBE_DATA_BLUE = 2,\n        /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4,\n        /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/ if (false !== consume) buffer.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, /* minimal header reading.  modify if you want to parse more information */ RGBE_ReadHeader = function(buffer) {\n            // regexes to parse header info fields\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, // RGBE format header struct\n            header = {\n                valid: 0,\n                /* indicate which fields are valid */ string: \"\",\n                /* the actual header string */ comments: \"\",\n                /* comments found in header */ programtype: \"RGBE\",\n                /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */ format: \"\",\n                /* RGBE format, default 32-bit_rle_rgbe */ gamma: 1.0,\n                /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */ exposure: 1.0,\n                /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */ width: 0,\n                height: 0 /* image dimensions, width/height */ \n            };\n            let line, match;\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) rgbe_error(rgbe_read_error, \"no header found\");\n            /* if you want to require the magic token then uncomment the next line */ if (!(match = line.match(magic_token_re))) rgbe_error(rgbe_format_error, \"bad initial token\");\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue; // comment line\n                }\n                if (match = line.match(gamma_re)) header.gamma = parseFloat(match[1]);\n                if (match = line.match(exposure_re)) header.exposure = parseFloat(match[1]);\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1]; //'32-bit_rle_rgbe';\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) rgbe_error(rgbe_format_error, \"missing format specifier\");\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer, w, h) {\n            const scanline_width = w;\n            if (scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n            2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) // return the flat buffer\n            return new Uint8Array(buffer);\n            if (scanline_width !== (buffer[2] << 8 | buffer[3])) rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            // read in each successive scanline\n            while(num_scanlines > 0 && pos < buffer.byteLength){\n                if (pos + 4 > buffer.byteLength) rgbe_error(rgbe_read_error);\n                rgbeStart[0] = buffer[pos++];\n                rgbeStart[1] = buffer[pos++];\n                rgbeStart[2] = buffer[pos++];\n                rgbeStart[3] = buffer[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                // read each of the four channels for the scanline into the buffer\n                // first red, then green, then blue, then exponent\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer.byteLength){\n                    count = buffer[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    if (isEncodedRun) {\n                        // a (encoded) run of the same value\n                        const byteValue = buffer[pos++];\n                        for(let i = 0; i < count; i++)scanline_buffer[ptr++] = byteValue;\n                    //ptr += count;\n                    } else {\n                        // a literal-run\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                // now convert data from buffer into rgba\n                // first red, then green, then blue, then exponent (alpha)\n                const l = scanline_width; //scanline_buffer.byteLength;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width; //1;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\n            // clamping to 65504, the maximum representable value in float16\n            destArray[destOffset + 0] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = (0, $ilwiq.DataUtils).toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = (0, $ilwiq.DataUtils).toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case 0, $ilwiq.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                data = floatArray;\n                type = (0, $ilwiq.FloatType);\n                break;\n            case 0, $ilwiq.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++)RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                data = halfArray;\n                type = (0, $ilwiq.HalfFloatType);\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type: type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case 0, $ilwiq.FloatType:\n                case 0, $ilwiq.HalfFloatType:\n                    texture.colorSpace = (0, $ilwiq.LinearSRGBColorSpace);\n                    texture.minFilter = (0, $ilwiq.LinearFilter);\n                    texture.magFilter = (0, $ilwiq.LinearFilter);\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n\n});\n\nparcelRegister(\"kqOCM\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParallelMeshBVHWorker\", () => $edfd8156d2dff8d2$export$1369cce09af89668);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nvar $cSOJe = parcelRequire(\"cSOJe\");\n\nvar $a8VBx = parcelRequire(\"a8VBx\");\n\nvar $5Gkg5 = parcelRequire(\"5Gkg5\");\nconst $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT = typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 4;\n\nclass $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"2tQrc\")));\n        super(worker);\n        this.name = \"ParallelMeshBVHWorker\";\n        this.maxWorkerCount = Math.max($edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT, 4);\n        if (!(0, $cSOJe.isSharedArrayBufferSupported)()) throw new Error(\"ParallelMeshBVHWorker: Shared Array Buffers are not supported.\");\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (!geometry.index && !options.indirect) (0, $5Gkg5.ensureIndex)(geometry, options);\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`ParallelMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = {\n                        setBoundingBox: true,\n                        ...options\n                    };\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            worker.postMessage({\n                operation: \"BUILD_BVH\",\n                maxWorkerCount: this.maxWorkerCount,\n                index: (0, $cSOJe.convertToBufferType)(index, SharedArrayBuffer),\n                position: (0, $cSOJe.convertToBufferType)(position, SharedArrayBuffer),\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            });\n        });\n    }\n}\nclass $edfd8156d2dff8d2$export$1369cce09af89668 {\n    constructor(){\n        if ((0, $cSOJe.isSharedArrayBufferSupported)()) return new $edfd8156d2dff8d2$var$_ParallelMeshBVHWorker();\n        else {\n            console.warn(\"ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.\");\n            const object = new (0, $a8VBx.GenerateMeshBVHWorker)();\n            object.maxWorkerCount = $edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT;\n            return object;\n        }\n    }\n}\n\n});\nparcelRegister(\"3ePKg\", function(module, exports) {\n\n$parcel$export(module.exports, \"WorkerBase\", () => $25bad171b6c71f9d$export$8dbf7c43841b75b7);\nclass $25bad171b6c71f9d$export$8dbf7c43841b75b7 {\n    constructor(worker){\n        this.name = \"WorkerBase\";\n        this.running = false;\n        this.worker = worker;\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${this.name}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${this.name}: Could not create Web Worker.`);\n        };\n    }\n    runTask() {}\n    generate(...args) {\n        if (this.running) throw new Error(\"GenerateMeshBVHWorker: Already running job.\");\n        if (this.worker === null) throw new Error(\"GenerateMeshBVHWorker: Worker has been disposed.\");\n        this.running = true;\n        const promise = this.runTask(this.worker, ...args);\n        promise.finally(()=>{\n            this.running = false;\n        });\n        return promise;\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n});\n\nparcelRegister(\"a8VBx\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateMeshBVHWorker\", () => $762755cd5891d020$export$426cc6213ad628cf);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $6KVZ3 = parcelRequire(\"6KVZ3\");\n\nvar $3ePKg = parcelRequire(\"3ePKg\");\n\nclass $762755cd5891d020$export$426cc6213ad628cf extends (0, $3ePKg.WorkerBase) {\n    constructor(){\n        const worker = new Worker((parcelRequire(\"jVRlM\")));\n        super(worker);\n        this.name = \"GenerateMeshBVHWorker\";\n    }\n    runTask(worker, geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            if (geometry.getAttribute(\"position\").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.\");\n            worker.onerror = (e)=>{\n                reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));\n            };\n            worker.onmessage = (e)=>{\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.serialized) {\n                    const { serialized: serialized, position: position } = data;\n                    const bvh = (0, $6KVZ3.MeshBVH).deserialize(serialized, geometry, {\n                        setIndex: false\n                    });\n                    const boundsOptions = Object.assign({\n                        setBoundingBox: true\n                    }, options);\n                    // we need to replace the arrays because they're neutered entirely by the\n                    // webworker transfer.\n                    geometry.attributes.position.array = position;\n                    if (serialized.index) {\n                        if (geometry.index) geometry.index.array = serialized.index;\n                        else {\n                            const newIndex = new (0, $ilwiq.BufferAttribute)(serialized.index, 1, false);\n                            geometry.setIndex(newIndex);\n                        }\n                    }\n                    if (boundsOptions.setBoundingBox) geometry.boundingBox = bvh.getBoundingBox(new (0, $ilwiq.Box3)());\n                    if (options.onProgress) options.onProgress(data.progress);\n                    resolve(bvh);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array : null;\n            const position = geometry.attributes.position.array;\n            const transferable = [\n                position\n            ];\n            if (index) transferable.push(index);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress),\n                    groups: [\n                        ...geometry.groups\n                    ]\n                }\n            }, transferable.map((arr)=>arr.buffer).filter((v)=>typeof SharedArrayBuffer === \"undefined\" || !(v instanceof SharedArrayBuffer)));\n        });\n    }\n}\n\n});\nparcelRegister(\"jVRlM\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $e82cb97686acadc5$var$url = new URL(\"generateMeshBVH.worker.373f3c58.js\", import.meta.url);\nmodule.exports = $7ryUf($e82cb97686acadc5$var$url.toString(), $e82cb97686acadc5$var$url.origin, true);\n\n});\nparcelRegister(\"7ryUf\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\nparcelRegister(\"2tQrc\", function(module, exports) {\n\nvar $7ryUf = parcelRequire(\"7ryUf\");\nlet $1ce6f7437f671131$var$url = new URL(\"parallelMeshBVH.worker.22cf4bb0.js\", import.meta.url);\nmodule.exports = $7ryUf($1ce6f7437f671131$var$url.toString(), $1ce6f7437f671131$var$url.origin, true);\n\n});\n\n\nparcelRegister(\"e2Pv4\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderElement\", () => $a399336cf50451da$export$c2252eb3bc5ad0b7);\nlet $a399336cf50451da$var$_styleElement;\nfunction $a399336cf50451da$var$initializeStyles() {\n    if ($a399336cf50451da$var$_styleElement) return;\n    $a399336cf50451da$var$_styleElement = document.createElement(\"style\");\n    $a399336cf50451da$var$_styleElement.textContent = /* css */ `\r\n\r\n\t\t.loader-container, .description {\r\n\t\t\tposition: absolute;\r\n\t\t\twidth: 100%;\r\n\t\t\tfont-family: 'Courier New', Courier, monospace;\r\n\t\t\tcolor: white;\r\n\t\t\tfont-weight: light;\r\n\t\t\talign-items: flex-start;\r\n\t\t\tfont-size: 14px;\r\n\t\t\tpointer-events: none;\r\n\t\t\tuser-select: none;\r\n\t\t}\r\n\r\n\t\t.loader-container {\r\n\t\t\tdisplay: flex;\r\n\t\t\tflex-direction: column;\r\n\t\t\tbottom: 0;\r\n\t\t}\r\n\r\n\t\t.description {\r\n\t\t\ttop: 0;\r\n\t\t\twidth: 100%;\r\n\t\t\ttext-align: center;\r\n\t\t\tpadding: 5px 0;\r\n\t\t}\r\n\r\n\t\t.loader-container .bar {\r\n\t\t\theight: 2px;\r\n\t\t\tbackground: white;\r\n\t\t\twidth: 100%;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples,\r\n\t\t.loader-container .percentage {\r\n\t\t\tpadding: 5px;\r\n\t\t\tmargin: 0 0 1px 1px;\r\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\r\n\t\t\tborder-radius: 2px;\r\n\t\t\tdisplay: inline-block;\r\n\t\t}\r\n\r\n\t\t.loader-container:not(.loading) .bar,\r\n\t\t.loader-container:not(.loading) .percentage,\r\n\t\t.loader-container.loading .credits,\r\n\t\t.loader-container.loading .samples,\r\n\t\t.loader-container .credits:empty {\r\n\t\t\tdisplay: none;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits a,\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples {\r\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\r\n\t\t}\r\n\t`;\n    document.head.appendChild($a399336cf50451da$var$_styleElement);\n}\nclass $a399336cf50451da$export$c2252eb3bc5ad0b7 {\n    constructor(){\n        $a399336cf50451da$var$initializeStyles();\n        const container = document.createElement(\"div\");\n        container.classList.add(\"loader-container\");\n        const percentageEl = document.createElement(\"div\");\n        percentageEl.classList.add(\"percentage\");\n        container.appendChild(percentageEl);\n        const samplesEl = document.createElement(\"div\");\n        samplesEl.classList.add(\"samples\");\n        container.appendChild(samplesEl);\n        const creditsEl = document.createElement(\"div\");\n        creditsEl.classList.add(\"credits\");\n        container.appendChild(creditsEl);\n        const loaderBarEl = document.createElement(\"div\");\n        loaderBarEl.classList.add(\"bar\");\n        container.appendChild(loaderBarEl);\n        const descriptionEl = document.createElement(\"div\");\n        descriptionEl.classList.add(\"description\");\n        container.appendChild(descriptionEl);\n        this._description = descriptionEl;\n        this._loaderBar = loaderBarEl;\n        this._percentage = percentageEl;\n        this._credits = creditsEl;\n        this._samples = samplesEl;\n        this._container = container;\n        this.setPercentage(0);\n    }\n    attach(container) {\n        container.appendChild(this._container);\n        container.appendChild(this._description);\n    }\n    setPercentage(perc) {\n        this._loaderBar.style.width = `${perc * 100}%`;\n        if (perc === 0) this._percentage.innerText = \"Loading...\";\n        else this._percentage.innerText = `${(perc * 100).toFixed(0)}%`;\n        if (perc >= 1) this._container.classList.remove(\"loading\");\n        else this._container.classList.add(\"loading\");\n    }\n    setSamples(count, compiling = false) {\n        if (compiling) this._samples.innerText = \"compiling shader...\";\n        else this._samples.innerText = `${Math.floor(count)} samples`;\n    }\n    setCredits(credits) {\n        this._credits.innerHTML = credits;\n    }\n    setDescription(description) {\n        this._description.innerHTML = description;\n    }\n}\n\n});\n\nparcelRegister(\"1EdOY\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateRadialFloorTexture\", () => $13343f7d1c4dd8ec$export$92750171fb06fc99);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nfunction $13343f7d1c4dd8ec$export$92750171fb06fc99(dim) {\n    const data = new Uint8Array(dim * dim * 4);\n    for(let x = 0; x < dim; x++)for(let y = 0; y < dim; y++){\n        const xNorm = x / (dim - 1);\n        const yNorm = y / (dim - 1);\n        const xCent = 2.0 * (xNorm - 0.5);\n        const yCent = 2.0 * (yNorm - 0.5);\n        let a = Math.max(Math.min(1.0 - Math.sqrt(xCent ** 2 + yCent ** 2), 1.0), 0.0);\n        a = a ** 2;\n        a = a * 1.5;\n        a = Math.min(a, 1.0);\n        const i = y * dim + x;\n        data[i * 4 + 0] = 255;\n        data[i * 4 + 1] = 255;\n        data[i * 4 + 2] = 255;\n        data[i * 4 + 3] = a * 255;\n    }\n    const tex = new $ilwiq.DataTexture(data, dim, dim);\n    tex.format = $ilwiq.RGBAFormat;\n    tex.type = $ilwiq.UnsignedByteType;\n    tex.minFilter = $ilwiq.LinearFilter;\n    tex.magFilter = $ilwiq.LinearFilter;\n    tex.wrapS = $ilwiq.RepeatWrapping;\n    tex.wrapT = $ilwiq.RepeatWrapping;\n    tex.needsUpdate = true;\n    return tex;\n}\n\n});\n\nparcelRegister(\"7wftx\", function(module, exports) {\n\nvar $Gr8vk = parcelRequire(\"Gr8vk\");\nmodule.exports = $Gr8vk(\"cvwp9\").then(()=>parcelRequire(\"kjyEk\"));\n\n});\nparcelRegister(\"Gr8vk\", function(module, exports) {\n\"use strict\";\n\nfunction $07f8f9093a769793$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"27Lyk\")).resolve(id));\n}\nmodule.exports = $07f8f9093a769793$var$load;\n\n});\n\n\nparcelRegister(\"cE5k3\", function(module, exports) {\n\n$parcel$export(module.exports, \"getScaledSettings\", () => $934d596524c3e5a8$export$5bc756cb1c628b75);\nfunction $934d596524c3e5a8$export$5bc756cb1c628b75() {\n    let tiles = 3;\n    let renderScale = Math.max(1 / window.devicePixelRatio, 0.5);\n    // adjust performance parameters for mobile\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    if (aspectRatio < 0.65) {\n        tiles = 4;\n        renderScale = 0.5 / window.devicePixelRatio;\n    }\n    return {\n        tiles: tiles,\n        renderScale: renderScale\n    };\n}\n\n});\n\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    set needsUpdate(v) {\n        super.needsUpdate = true;\n        this.dispatchEvent({\n            type: \"recompilation\"\n        });\n    }\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/disini/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $891vQ = parcelRequire(\"891vQ\");\n\nvar $kqOCM = parcelRequire(\"kqOCM\");\n\nvar $e2Pv4 = parcelRequire(\"e2Pv4\");\n\nvar $8mHfG = parcelRequire(\"8mHfG\");\n\nvar $1EdOY = parcelRequire(\"1EdOY\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */ /**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */ /**\n * Used internally\n *\n * @internal\n * @param canvas\n * @param mimeType\n * @param quality\n * @returns\n */ const $daaf2f33281be569$var$canvasToBlob = async (canvas, mimeType, quality)=>{\n    if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) return canvas.convertToBlob({\n        type: mimeType,\n        quality: quality || 0.9\n    });\n    else if (canvas instanceof HTMLCanvasElement) return new Promise((resolve, reject)=>{\n        canvas.toBlob((res)=>{\n            if (res) resolve(res);\n            else reject(new Error(\"Failed to convert canvas to blob\"));\n        }, mimeType, quality || 0.9);\n    });\n    /* istanbul ignore next\n      as long as this function is not exported this is only here\n      to satisfy TS strict mode internally\n    */ throw new Error(\"Unsupported canvas element\");\n};\n/**\n * Converts a RAW RGBA image buffer into the provided `mimeType` using the provided `quality`\n *\n * @category Compression\n * @group Compression\n * @param params\n * @throws {Error} if the browser does not support [createImageBitmap](https://caniuse.com/createimagebitmap)\n * @throws {Error} if the provided source image cannot be decoded\n * @throws {Error} if the function fails to create a canvas context\n */ const $daaf2f33281be569$export$db3b6bfb95261072 = async (params)=>{\n    if (typeof createImageBitmap === \"undefined\") throw new Error(\"createImageBitmap() not supported.\");\n    const { source: source, mimeType: mimeType, quality: quality, flipY: flipY } = params;\n    // eslint-disable-next-line no-undef\n    let imageBitmapSource;\n    if ((source instanceof Uint8Array || source instanceof Uint8ClampedArray) && \"sourceMimeType\" in params) imageBitmapSource = new Blob([\n        source\n    ], {\n        type: params.sourceMimeType\n    });\n    else if (source instanceof ImageData) imageBitmapSource = source;\n    else throw new Error(\"Invalid source image\");\n    const img = await createImageBitmap(imageBitmapSource);\n    const width = img.width;\n    const height = img.height;\n    let canvas;\n    if (typeof OffscreenCanvas !== \"undefined\") canvas = new OffscreenCanvas(width, height);\n    else {\n        canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n    }\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) throw new Error(\"Failed to create canvas Context\");\n    // flip Y\n    if (flipY === true) {\n        ctx.translate(0, height);\n        ctx.scale(1, -1);\n    }\n    ctx.drawImage(img, 0, 0, width, height);\n    const blob = await $daaf2f33281be569$var$canvasToBlob(canvas, mimeType, quality || 0.9);\n    const data = new Uint8Array(await blob.arrayBuffer());\n    return {\n        data: data,\n        mimeType: mimeType,\n        width: width,\n        height: height\n    };\n};\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */ \nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $1b636fde1e2ba3a5$var$getBufferForType = (type, width, height)=>{\n    let out;\n    switch(type){\n        case 0, $ilwiq.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case 0, $ilwiq.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case 0, $ilwiq.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case 0, $ilwiq.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case 0, $ilwiq.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case 0, $ilwiq.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case 0, $ilwiq.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error(\"Unsupported data type\");\n    }\n    return out;\n};\nlet $1b636fde1e2ba3a5$var$_canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */ const $1b636fde1e2ba3a5$var$canReadPixels = (type, renderer, camera, renderTargetOptions)=>{\n    if ($1b636fde1e2ba3a5$var$_canReadPixelsResult !== undefined) return $1b636fde1e2ba3a5$var$_canReadPixelsResult;\n    const testRT = new (0, $ilwiq.WebGLRenderTarget)(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new (0, $ilwiq.Mesh)(new (0, $ilwiq.PlaneGeometry)(), new (0, $ilwiq.MeshBasicMaterial)({\n        color: 0xffffff\n    }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = $1b636fde1e2ba3a5$var$getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    $1b636fde1e2ba3a5$var$_canReadPixelsResult = out[0] !== 0;\n    return $1b636fde1e2ba3a5$var$_canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */ class $1b636fde1e2ba3a5$export$3722cfe417b6ed86 {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */ constructor(options){\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */ this.render = ()=>{\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            } catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: (0, $ilwiq.RGBAFormat),\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type,\n            colorSpace: this._colorSpace,\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : (0, $ilwiq.LinearFilter),\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : (0, $ilwiq.LinearFilter),\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : (0, $ilwiq.ClampToEdgeWrapping),\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : (0, $ilwiq.ClampToEdgeWrapping)\n        };\n        this._material = options.material;\n        if (options.renderer) this._renderer = options.renderer;\n        else {\n            this._renderer = $1b636fde1e2ba3a5$export$3722cfe417b6ed86.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new (0, $ilwiq.Scene)();\n        this._camera = new (0, $ilwiq.OrthographicCamera)();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!$1b636fde1e2ba3a5$var$canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch(this._type){\n                case 0, $ilwiq.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has(\"EXT_color_buffer_float\") ? (0, $ilwiq.FloatType) : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${(0, $ilwiq.FloatType)}`);\n                this._type = alternativeType;\n            } else {\n                this._supportsReadPixels = false;\n                console.warn(\"This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown\");\n            }\n        }\n        this._quad = new (0, $ilwiq.Mesh)(new (0, $ilwiq.PlaneGeometry)(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new (0, $ilwiq.WebGLRenderTarget)(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : (0, $ilwiq.UVMapping);\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */ static instantiateRenderer() {\n        const renderer = new (0, $ilwiq.WebGLRenderer)();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */ toArray() {\n        if (!this._supportsReadPixels) throw new Error(\"Can't read pixels in this browser\");\n        const out = $1b636fde1e2ba3a5$var$getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */ toDataTexture(options) {\n        const returnValue = new (0, $ilwiq.DataTexture)(// fixed values\n        this.toArray(), this.width, this.height, (0, $ilwiq.RGBAFormat), this._type, // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || (0, $ilwiq.UVMapping), (options === null || options === void 0 ? void 0 : options.wrapS) || (0, $ilwiq.ClampToEdgeWrapping), (options === null || options === void 0 ? void 0 : options.wrapT) || (0, $ilwiq.ClampToEdgeWrapping), (options === null || options === void 0 ? void 0 : options.magFilter) || (0, $ilwiq.LinearFilter), (options === null || options === void 0 ? void 0 : options.minFilter) || (0, $ilwiq.LinearFilter), (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, // fixed value\n        (0, $ilwiq.LinearSRGBColorSpace));\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */ disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */ dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) this.renderTarget.dispose();\n        // dispose shader material texture uniforms\n        if (this.material instanceof (0, $ilwiq.ShaderMaterial)) Object.values(this.material.uniforms).forEach((v)=>{\n            if (v.value instanceof (0, $ilwiq.Texture)) v.value.dispose();\n        });\n        // dispose other material properties\n        Object.values(this.material).forEach((value)=>{\n            if (value instanceof (0, $ilwiq.Texture)) value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */ get renderer() {\n        return this._renderer;\n    }\n    /**\n     * The `WebGLRenderTarget` used.\n     */ get renderTarget() {\n        return this._renderTarget;\n    }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n    // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */ get material() {\n        return this._material;\n    }\n    /**\n     *\n     */ get type() {\n        return this._type;\n    }\n    get colorSpace() {\n        return this._colorSpace;\n    }\n}\n\n\n/**\n * Utility function to obtain a `DataTexture` from various input formats\n *\n * @category Utility\n * @group Utility\n *\n * @param image\n * @returns\n */ const $581a283dd38ad8c0$var$getDataTexture = (image)=>{\n    let dataTexture;\n    if (image instanceof (0, $ilwiq.DataTexture)) {\n        if (!(image.image.data instanceof Uint16Array) && !(image.image.data instanceof Float32Array)) throw new Error(\"Provided image is not HDR\");\n        dataTexture = image;\n    } else {\n        dataTexture = new (0, $ilwiq.DataTexture)(image.data, image.width, image.height, \"format\" in image ? image.format : (0, $ilwiq.RGBAFormat), image.type, (0, $ilwiq.UVMapping), (0, $ilwiq.RepeatWrapping), (0, $ilwiq.RepeatWrapping), (0, $ilwiq.LinearFilter), (0, $ilwiq.LinearFilter), 1, \"colorSpace\" in image && image.colorSpace === \"srgb\" ? image.colorSpace : (0, $ilwiq.LinearSRGBColorSpace));\n        // TODO: This tries to detect a raw RGBE and applies flipY\n        // see if there's a better way to detect it?\n        if (\"header\" in image && \"gamma\" in image) dataTexture.flipY = true;\n        dataTexture.needsUpdate = true;\n    }\n    return dataTexture;\n};\nconst $581a283dd38ad8c0$var$vertexShader$2 = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst $581a283dd38ad8c0$var$fragmentShader$2 = /* glsl */ `\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform sampler2D sdr;\nuniform sampler2D hdr;\nuniform vec3 gamma;\nuniform vec3 offsetSdr;\nuniform vec3 offsetHdr;\nuniform float minLog2;\nuniform float maxLog2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 sdrColor = texture2D(sdr, vUv).rgb;\n  vec3 hdrColor = texture2D(hdr, vUv).rgb;\n\n  vec3 pixelGain = (hdrColor + offsetHdr) / (sdrColor + offsetSdr);\n  vec3 logRecovery = (log2(pixelGain) - minLog2) / (maxLog2 - minLog2);\n  vec3 clampedRecovery = saturate(logRecovery);\n  gl_FragColor = vec4(pow(clampedRecovery, gamma), 1.0);\n}\n`;\n/**\n * A Material which is able to encode a gainmap\n *\n * @category Materials\n * @group Materials\n */ class $581a283dd38ad8c0$export$9b80d24e3e631c1b extends (0, $ilwiq.ShaderMaterial) {\n    /**\n     *\n     * @param params\n     */ constructor({ sdr: sdr, hdr: hdr, offsetSdr: offsetSdr, offsetHdr: offsetHdr, maxContentBoost: maxContentBoost, minContentBoost: minContentBoost, gamma: gamma }){\n        if (!maxContentBoost) throw new Error(\"maxContentBoost is required\");\n        if (!sdr) throw new Error(\"sdr is required\");\n        if (!hdr) throw new Error(\"hdr is required\");\n        const _gamma = gamma || [\n            1,\n            1,\n            1\n        ];\n        const _offsetSdr = offsetSdr || [\n            1 / 64,\n            1 / 64,\n            1 / 64\n        ];\n        const _offsetHdr = offsetHdr || [\n            1 / 64,\n            1 / 64,\n            1 / 64\n        ];\n        const _minContentBoost = minContentBoost || 1;\n        const _maxContentBoost = Math.max(maxContentBoost, 1.0001);\n        super({\n            name: \"GainMapEncoderMaterial\",\n            vertexShader: $581a283dd38ad8c0$var$vertexShader$2,\n            fragmentShader: $581a283dd38ad8c0$var$fragmentShader$2,\n            uniforms: {\n                sdr: {\n                    value: sdr\n                },\n                hdr: {\n                    value: hdr\n                },\n                gamma: {\n                    value: new (0, $ilwiq.Vector3)().fromArray(_gamma)\n                },\n                offsetSdr: {\n                    value: new (0, $ilwiq.Vector3)().fromArray(_offsetSdr)\n                },\n                offsetHdr: {\n                    value: new (0, $ilwiq.Vector3)().fromArray(_offsetHdr)\n                },\n                minLog2: {\n                    value: Math.log2(_minContentBoost)\n                },\n                maxLog2: {\n                    value: Math.log2(_maxContentBoost)\n                }\n            },\n            blending: (0, $ilwiq.NoBlending),\n            depthTest: false,\n            depthWrite: false\n        });\n        this._minContentBoost = _minContentBoost;\n        this._maxContentBoost = _maxContentBoost;\n        this._offsetSdr = _offsetSdr;\n        this._offsetHdr = _offsetHdr;\n        this._gamma = _gamma;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.gamma}\n     */ get gamma() {\n        return this._gamma;\n    }\n    set gamma(value) {\n        this._gamma = value;\n        this.uniforms.gamma.value = new (0, $ilwiq.Vector3)().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.offsetHdr}\n     */ get offsetHdr() {\n        return this._offsetHdr;\n    }\n    set offsetHdr(value) {\n        this._offsetHdr = value;\n        this.uniforms.offsetHdr.value = new (0, $ilwiq.Vector3)().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.offsetSdr}\n     */ get offsetSdr() {\n        return this._offsetSdr;\n    }\n    set offsetSdr(value) {\n        this._offsetSdr = value;\n        this.uniforms.offsetSdr.value = new (0, $ilwiq.Vector3)().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.minContentBoost}\n     * @remarks Non logarithmic space\n     */ get minContentBoost() {\n        return this._minContentBoost;\n    }\n    set minContentBoost(value) {\n        this._minContentBoost = value;\n        this.uniforms.minLog2.value = Math.log2(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.maxContentBoost}\n     * @remarks Non logarithmic space\n     */ get maxContentBoost() {\n        return this._maxContentBoost;\n    }\n    set maxContentBoost(value) {\n        this._maxContentBoost = value;\n        this.uniforms.maxLog2.value = Math.log2(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     * @remarks Logarithmic space\n     */ get gainMapMin() {\n        return [\n            Math.log2(this._minContentBoost),\n            Math.log2(this._minContentBoost),\n            Math.log2(this._minContentBoost)\n        ];\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     * @remarks Logarithmic space\n     */ get gainMapMax() {\n        return [\n            Math.log2(this._maxContentBoost),\n            Math.log2(this._maxContentBoost),\n            Math.log2(this._maxContentBoost)\n        ];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMin() {\n        return Math.min(Math.max(0, this.gainMapMin[0]), Math.max(0, this.gainMapMin[1]), Math.max(0, this.gainMapMin[2]));\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMax}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMax() {\n        return Math.max(Math.max(0, this.gainMapMax[0]), Math.max(0, this.gainMapMax[1]), Math.max(0, this.gainMapMax[2]));\n    }\n}\n/**\n *\n * @param params\n * @returns\n * @category Encoding Functions\n * @group Encoding Functions\n */ const $581a283dd38ad8c0$export$2cab4d87f6303bef = (params)=>{\n    const { image: image, sdr: sdr, renderer: renderer } = params;\n    const dataTexture = $581a283dd38ad8c0$var$getDataTexture(image);\n    const material = new $581a283dd38ad8c0$export$9b80d24e3e631c1b({\n        ...params,\n        sdr: sdr.renderTarget.texture,\n        hdr: dataTexture\n    });\n    const quadRenderer = new (0, $1b636fde1e2ba3a5$export$3722cfe417b6ed86)({\n        width: dataTexture.image.width,\n        height: dataTexture.image.height,\n        type: (0, $ilwiq.UnsignedByteType),\n        colorSpace: (0, $ilwiq.LinearSRGBColorSpace),\n        material: material,\n        renderer: renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\nconst $581a283dd38ad8c0$var$vertexShader$1 = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst $581a283dd38ad8c0$var$fragmentShader$1 = /* glsl */ `\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform sampler2D map;\nuniform float brightness;\nuniform float contrast;\nuniform float saturation;\nuniform float exposure;\n\nvarying vec2 vUv;\n\nmat4 brightnessMatrix( float brightness ) {\n  return mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    brightness, brightness, brightness, 1\n  );\n}\n\nmat4 contrastMatrix( float contrast ) {\n  float t = ( 1.0 - contrast ) / 2.0;\n  return mat4(\n    contrast, 0, 0, 0,\n    0, contrast, 0, 0,\n    0, 0, contrast, 0,\n    t, t, t, 1\n  );\n}\n\nmat4 saturationMatrix( float saturation ) {\n  vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n  float oneMinusSat = 1.0 - saturation;\n  vec3 red = vec3( luminance.x * oneMinusSat );\n  red+= vec3( saturation, 0, 0 );\n  vec3 green = vec3( luminance.y * oneMinusSat );\n  green += vec3( 0, saturation, 0 );\n  vec3 blue = vec3( luminance.z * oneMinusSat );\n  blue += vec3( 0, 0, saturation );\n  return mat4(\n    red,     0,\n    green,   0,\n    blue,    0,\n    0, 0, 0, 1\n  );\n}\n\nvec3 RRTAndODTFit( vec3 v ) {\n  vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n  vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n  return a / b;\n}\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const mat3 ACESInputMat = mat3(\n    vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n    vec3( 0.35458, 0.90834, 0.13383 ),\n    vec3( 0.04823, 0.01566, 0.83777 )\n  );\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const mat3 ACESOutputMat = mat3(\n    vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n    vec3( -0.53108,  1.10813, -0.07276 ),\n    vec3( -0.07367, -0.00605,  1.07602 )\n  );\n  color = ACESInputMat * color;\n  // Apply RRT and ODT\n  color = RRTAndODTFit( color );\n  color = ACESOutputMat * color;\n  // Clamp to [0, 1]\n  return saturate( color );\n}\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\nvec3 ReinhardToneMapping( vec3 color ) {\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 CineonToneMapping( vec3 color ) {\n  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n\n// nothing\nvec3 LinearToneMapping ( vec3 color ) {\n  return color;\n}\n\n\nvoid main() {\n  vec4 color = texture2D(map, vUv);\n\n  vec4 exposed = vec4(exposure * color.rgb, color.a);\n\n  vec4 tonemapped = vec4(TONEMAPPING_FUNCTION(exposed.rgb), color.a);\n\n  vec4 adjusted =\n    brightnessMatrix( brightness ) *\n    contrastMatrix( contrast ) *\n    saturationMatrix( saturation ) *\n    tonemapped;\n\n  gl_FragColor = adjusted;\n}\n`;\n/**\n * A Material used to adjust the SDR representation of an HDR image\n *\n * @category Materials\n * @group Materials\n */ class $581a283dd38ad8c0$export$bf0f03a8a12ec73d extends (0, $ilwiq.ShaderMaterial) {\n    /**\n     *\n     * @param params\n     */ constructor({ map: map, toneMapping: toneMapping }){\n        super({\n            name: \"SDRMaterial\",\n            vertexShader: $581a283dd38ad8c0$var$vertexShader$1,\n            fragmentShader: $581a283dd38ad8c0$var$fragmentShader$1,\n            uniforms: {\n                map: {\n                    value: map\n                },\n                brightness: {\n                    value: 0\n                },\n                contrast: {\n                    value: 1\n                },\n                saturation: {\n                    value: 1\n                },\n                exposure: {\n                    value: 1\n                }\n            },\n            blending: (0, $ilwiq.NoBlending),\n            depthTest: false,\n            depthWrite: false\n        });\n        this._brightness = 0;\n        this._contrast = 1;\n        this._saturation = 1;\n        this._exposure = 1;\n        this._map = map;\n        this.toneMapping = this._toneMapping = toneMapping || (0, $ilwiq.ACESFilmicToneMapping);\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get toneMapping() {\n        return this._toneMapping;\n    }\n    set toneMapping(value) {\n        let valid = false;\n        switch(value){\n            case 0, $ilwiq.ACESFilmicToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = \"ACESFilmicToneMapping\";\n                valid = true;\n                break;\n            case 0, $ilwiq.ReinhardToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = \"ReinhardToneMapping\";\n                valid = true;\n                break;\n            case 0, $ilwiq.CineonToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = \"CineonToneMapping\";\n                valid = true;\n                break;\n            case 0, $ilwiq.LinearToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = \"LinearToneMapping\";\n                valid = true;\n                break;\n            default:\n                console.error(`Unsupported toneMapping: ${value}. Using LinearToneMapping.`);\n                this.defines.TONEMAPPING_FUNCTION = \"LinearToneMapping\";\n                this._toneMapping = (0, $ilwiq.LinearToneMapping);\n        }\n        if (valid) this._toneMapping = value;\n        this.needsUpdate = true;\n    }\n    get brightness() {\n        return this._brightness;\n    }\n    set brightness(value) {\n        this._brightness = value;\n        this.uniforms.brightness.value = value;\n    }\n    get contrast() {\n        return this._contrast;\n    }\n    set contrast(value) {\n        this._contrast = value;\n        this.uniforms.contrast.value = value;\n    }\n    get saturation() {\n        return this._saturation;\n    }\n    set saturation(value) {\n        this._saturation = value;\n        this.uniforms.saturation.value = value;\n    }\n    get exposure() {\n        return this._exposure;\n    }\n    set exposure(value) {\n        this._exposure = value;\n        this.uniforms.exposure.value = value;\n    }\n    get map() {\n        return this._map;\n    }\n    set map(value) {\n        this._map = value;\n        this.uniforms.map.value = value;\n    }\n}\n/**\n * Renders an SDR Representation of an HDR Image\n *\n * @category Encoding Functions\n * @group Encoding Functions\n *\n * @param hdrTexture The HDR image to be rendered\n * @param renderer (optional) WebGLRenderer to use during the rendering, a disposable renderer will be create and destroyed if this is not provided.\n * @param toneMapping (optional) Tone mapping to be applied to the SDR Rendition\n * @param renderTargetOptions (optional) Options to use when creating the output renderTarget\n * @throws {Error} if the WebGLRenderer fails to render the SDR image\n */ const $581a283dd38ad8c0$export$630d5cd0f662908c = (hdrTexture, renderer, toneMapping, renderTargetOptions)=>{\n    hdrTexture.needsUpdate = true;\n    const quadRenderer = new (0, $1b636fde1e2ba3a5$export$3722cfe417b6ed86)({\n        width: hdrTexture.image.width,\n        height: hdrTexture.image.height,\n        type: (0, $ilwiq.UnsignedByteType),\n        colorSpace: (0, $ilwiq.SRGBColorSpace),\n        material: new $581a283dd38ad8c0$export$bf0f03a8a12ec73d({\n            map: hdrTexture,\n            toneMapping: toneMapping\n        }),\n        renderer: renderer,\n        renderTargetOptions: renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n/**\n * Encodes a Gainmap starting from an HDR file.\n *\n * @remarks\n * if you do not pass a `renderer` parameter\n * you must manually dispose the result\n * ```js\n * const encodingResult = await encode({ ... })\n * // do something with the buffers\n * const sdr = encodingResult.sdr.getArray()\n * const gainMap = encodingResult.gainMap.getArray()\n * // after that\n * encodingResult.sdr.dispose()\n * encodingResult.gainMap.dispose()\n * ```\n *\n * @category Encoding Functions\n * @group Encoding Functions\n *\n * @example\n * import { encode, findTextureMinMax } from '@monogrid/gainmap-js'\n * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\n *\n * // load an HDR file\n * const loader = new EXRLoader()\n * const image = await loader.loadAsync('image.exr')\n *\n * // find RAW RGB Max value of a texture\n * const textureMax = await findTextureMinMax(image)\n *\n * // Encode the gainmap\n * const encodingResult = encode({\n *   image,\n *   // this will encode the full HDR range\n *   maxContentBoost: Math.max.apply(this, textureMax)\n * })\n * // can be re-encoded after changing parameters\n * encodingResult.sdr.material.exposure = 0.9\n * encodingResult.sdr.render()\n * // or\n * encodingResult.gainMap.material.gamma = [1.1, 1.1, 1.1]\n * encodingResult.gainMap.render()\n *\n * // do something with encodingResult.gainMap.toArray()\n * // and encodingResult.sdr.toArray()\n *\n * // renderers must be manually disposed\n * encodingResult.sdr.dispose()\n * encodingResult.gainMap.dispose()\n *\n * @param params Encoding Parameters\n * @returns\n */ const $581a283dd38ad8c0$export$c564cdbbe6da493 = (params)=>{\n    const { image: image, renderer: renderer } = params;\n    const dataTexture = $581a283dd38ad8c0$var$getDataTexture(image);\n    const sdr = $581a283dd38ad8c0$export$630d5cd0f662908c(dataTexture, renderer, params.toneMapping, params.renderTargetOptions);\n    const gainMapRenderer = $581a283dd38ad8c0$export$2cab4d87f6303bef({\n        ...params,\n        image: dataTexture,\n        sdr: sdr,\n        renderer: sdr.renderer // reuse the same (maybe disposable?) renderer\n    });\n    return {\n        sdr: sdr,\n        gainMap: gainMapRenderer,\n        hdr: dataTexture,\n        getMetadata: ()=>{\n            return {\n                gainMapMax: gainMapRenderer.material.gainMapMax,\n                gainMapMin: gainMapRenderer.material.gainMapMin,\n                gamma: gainMapRenderer.material.gamma,\n                hdrCapacityMax: gainMapRenderer.material.hdrCapacityMax,\n                hdrCapacityMin: gainMapRenderer.material.hdrCapacityMin,\n                offsetHdr: gainMapRenderer.material.offsetHdr,\n                offsetSdr: gainMapRenderer.material.offsetSdr\n            };\n        }\n    };\n};\n/**\n * Encodes a Gainmap starting from an HDR file into compressed file formats (`image/jpeg`, `image/webp` or `image/png`).\n *\n * Uses {@link encode} internally, then pipes the results to {@link compress}.\n *\n * @remarks\n * if a `renderer` parameter is not provided\n * This function will automatically dispose its \"disposable\"\n * renderer, no need to dispose it manually later\n *\n * @category Encoding Functions\n * @group Encoding Functions\n * @example\n * import { encodeAndCompress, findTextureMinMax } from '@monogrid/gainmap-js'\n * import { encodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\n * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\n *\n * // load an HDR file\n * const loader = new EXRLoader()\n * const image = await loader.loadAsync('image.exr')\n *\n * // find RAW RGB Max value of a texture\n * const textureMax = await findTextureMinMax(image)\n *\n * // Encode the gainmap\n * const encodingResult = await encodeAndCompress({\n *   image,\n *   maxContentBoost: Math.max.apply(this, textureMax),\n *   mimeType: 'image/jpeg'\n * })\n *\n * // embed the compressed images + metadata into a single\n * // JPEG file\n * const jpeg = await encodeJPEGMetadata({\n *   ...encodingResult,\n *   sdr: encodingResult.sdr,\n *   gainMap: encodingResult.gainMap\n * })\n *\n * // `jpeg` will be an `Uint8Array` which can be saved somewhere\n *\n *\n * @param params Encoding Parameters\n * @throws {Error} if the browser does not support [createImageBitmap](https://caniuse.com/createimagebitmap)\n */ const $581a283dd38ad8c0$export$6523a771b37c422a = async (params)=>{\n    const encodingResult = $581a283dd38ad8c0$export$c564cdbbe6da493(params);\n    const { mimeType: mimeType, quality: quality, flipY: flipY, withWorker: withWorker } = params;\n    let compressResult;\n    let rawSDR;\n    let rawGainMap;\n    const sdrImageData = new ImageData(encodingResult.sdr.toArray(), encodingResult.sdr.width, encodingResult.sdr.height);\n    const gainMapImageData = new ImageData(encodingResult.gainMap.toArray(), encodingResult.gainMap.width, encodingResult.gainMap.height);\n    if (withWorker) {\n        const workerResult = await Promise.all([\n            withWorker.compress({\n                source: sdrImageData,\n                mimeType: mimeType,\n                quality: quality,\n                flipY: flipY\n            }),\n            withWorker.compress({\n                source: gainMapImageData,\n                mimeType: mimeType,\n                quality: quality,\n                flipY: flipY\n            })\n        ]);\n        compressResult = workerResult;\n        rawSDR = workerResult[0].source;\n        rawGainMap = workerResult[1].source;\n    } else {\n        compressResult = await Promise.all([\n            (0, $daaf2f33281be569$export$db3b6bfb95261072)({\n                source: sdrImageData,\n                mimeType: mimeType,\n                quality: quality,\n                flipY: flipY\n            }),\n            (0, $daaf2f33281be569$export$db3b6bfb95261072)({\n                source: gainMapImageData,\n                mimeType: mimeType,\n                quality: quality,\n                flipY: flipY\n            })\n        ]);\n        rawSDR = sdrImageData.data;\n        rawGainMap = gainMapImageData.data;\n    }\n    encodingResult.sdr.dispose();\n    encodingResult.gainMap.dispose();\n    return {\n        ...encodingResult,\n        ...encodingResult.getMetadata(),\n        sdr: compressResult[0],\n        gainMap: compressResult[1],\n        rawSDR: rawSDR,\n        rawGainMap: rawGainMap\n    };\n};\nconst $581a283dd38ad8c0$var$vertexShader = /* glsl */ `\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst $581a283dd38ad8c0$var$fragmentShader = /* glsl */ `\nprecision mediump float;\n\n#ifndef CELL_SIZE\n  #define CELL_SIZE 2\n#endif\n\n#ifndef COMPARE_FUNCTION\n  #define COMPARE_FUNCTION max\n#endif\n\n#ifndef INITIAL_VALUE\n  #define INITIAL_VALUE 0\n#endif\n\nuniform sampler2D map;\nuniform vec2 u_srcResolution;\n\nvarying vec2 vUv;\n\nvoid main() {\n  // compute the first pixel the source cell\n  vec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\n\n  // one pixel in source\n  vec2 onePixel = vec2(1) / u_srcResolution;\n\n  // uv for first pixel in cell. +0.5 for center of pixel\n  vec2 uv = (srcPixel + 0.5) * onePixel;\n\n  vec4 resultColor = vec4(INITIAL_VALUE);\n\n  for (int y = 0; y < CELL_SIZE; ++y) {\n    for (int x = 0; x < CELL_SIZE; ++x) {\n      resultColor = COMPARE_FUNCTION(resultColor, texture2D(map, uv + vec2(x, y) * onePixel));\n    }\n  }\n\n  gl_FragColor = resultColor;\n}\n`;\n/**\n *\n * @category Utility\n * @group Utility\n *\n * @param srcTex\n * @param mode\n * @param renderer\n * @returns\n */ const $581a283dd38ad8c0$export$1717a30775af005b = (image, mode = \"max\", renderer)=>{\n    const srcTex = $581a283dd38ad8c0$var$getDataTexture(image);\n    const cellSize = 2;\n    const mat = new (0, $ilwiq.ShaderMaterial)({\n        vertexShader: $581a283dd38ad8c0$var$vertexShader,\n        fragmentShader: $581a283dd38ad8c0$var$fragmentShader,\n        uniforms: {\n            u_srcResolution: {\n                value: new (0, $ilwiq.Vector2)(srcTex.image.width, srcTex.image.height)\n            },\n            map: {\n                value: srcTex\n            }\n        },\n        defines: {\n            CELL_SIZE: cellSize,\n            COMPARE_FUNCTION: mode,\n            INITIAL_VALUE: mode === \"max\" ? 0 : 65504 // max half float value\n        }\n    });\n    srcTex.needsUpdate = true;\n    mat.needsUpdate = true;\n    let w = srcTex.image.width;\n    let h = srcTex.image.height;\n    const quadRenderer = new (0, $1b636fde1e2ba3a5$export$3722cfe417b6ed86)({\n        width: w,\n        height: h,\n        type: srcTex.type,\n        colorSpace: srcTex.colorSpace,\n        material: mat,\n        renderer: renderer\n    });\n    const frameBuffers = [];\n    while(w > 1 || h > 1){\n        w = Math.max(1, (w + cellSize - 1) / cellSize | 0);\n        h = Math.max(1, (h + cellSize - 1) / cellSize | 0);\n        const fb = new (0, $ilwiq.WebGLRenderTarget)(w, h, {\n            type: quadRenderer.type,\n            format: srcTex.format,\n            colorSpace: quadRenderer.colorSpace,\n            minFilter: (0, $ilwiq.NearestFilter),\n            magFilter: (0, $ilwiq.NearestFilter),\n            wrapS: (0, $ilwiq.ClampToEdgeWrapping),\n            wrapT: (0, $ilwiq.ClampToEdgeWrapping),\n            generateMipmaps: false,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n        frameBuffers.push(fb);\n    }\n    w = srcTex.image.width;\n    h = srcTex.image.height;\n    frameBuffers.forEach((fbi)=>{\n        w = Math.max(1, (w + cellSize - 1) / cellSize | 0);\n        h = Math.max(1, (h + cellSize - 1) / cellSize | 0);\n        quadRenderer.renderTarget = fbi;\n        quadRenderer.render();\n        mat.uniforms.map.value = fbi.texture;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        mat.uniforms.u_srcResolution.value.x = w;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        mat.uniforms.u_srcResolution.value.y = h;\n    });\n    const out = quadRenderer.toArray();\n    quadRenderer.dispose();\n    frameBuffers.forEach((fb)=>fb.dispose());\n    return [\n        quadRenderer.type === (0, $ilwiq.FloatType) ? out[0] : (0, $ilwiq.DataUtils).fromHalfFloat(out[0]),\n        quadRenderer.type === (0, $ilwiq.FloatType) ? out[1] : (0, $ilwiq.DataUtils).fromHalfFloat(out[1]),\n        quadRenderer.type === (0, $ilwiq.FloatType) ? out[2] : (0, $ilwiq.DataUtils).fromHalfFloat(out[2])\n    ];\n};\n\n\n/* eslint-disable */ // NOTE: modified version of monogrid source file to patch it\n// so it works with parcel\n/**\r\n * @monogrid/gainmap-js v3.0.5\r\n * With , by MONOGRID <rnd@monogrid.com>\r\n */ var $cfae44f0dfdf62c0$exports = {};\n// shim for using process in browser\nvar $cfae44f0dfdf62c0$var$process = $cfae44f0dfdf62c0$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $cfae44f0dfdf62c0$var$cachedSetTimeout;\nvar $cfae44f0dfdf62c0$var$cachedClearTimeout;\nfunction $cfae44f0dfdf62c0$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $cfae44f0dfdf62c0$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        else $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        else $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    }\n})();\nfunction $cfae44f0dfdf62c0$var$runTimeout(fun) {\n    if ($cfae44f0dfdf62c0$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedSetTimeout === $cfae44f0dfdf62c0$var$defaultSetTimout || !$cfae44f0dfdf62c0$var$cachedSetTimeout) && setTimeout) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $cfae44f0dfdf62c0$var$runClearTimeout(marker) {\n    if ($cfae44f0dfdf62c0$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedClearTimeout === $cfae44f0dfdf62c0$var$defaultClearTimeout || !$cfae44f0dfdf62c0$var$cachedClearTimeout) && clearTimeout) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $cfae44f0dfdf62c0$var$queue = [];\nvar $cfae44f0dfdf62c0$var$draining = false;\nvar $cfae44f0dfdf62c0$var$currentQueue;\nvar $cfae44f0dfdf62c0$var$queueIndex = -1;\nfunction $cfae44f0dfdf62c0$var$cleanUpNextTick() {\n    if (!$cfae44f0dfdf62c0$var$draining || !$cfae44f0dfdf62c0$var$currentQueue) return;\n    $cfae44f0dfdf62c0$var$draining = false;\n    if ($cfae44f0dfdf62c0$var$currentQueue.length) $cfae44f0dfdf62c0$var$queue = $cfae44f0dfdf62c0$var$currentQueue.concat($cfae44f0dfdf62c0$var$queue);\n    else $cfae44f0dfdf62c0$var$queueIndex = -1;\n    if ($cfae44f0dfdf62c0$var$queue.length) $cfae44f0dfdf62c0$var$drainQueue();\n}\nfunction $cfae44f0dfdf62c0$var$drainQueue() {\n    if ($cfae44f0dfdf62c0$var$draining) return;\n    var timeout = $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$cleanUpNextTick);\n    $cfae44f0dfdf62c0$var$draining = true;\n    var len = $cfae44f0dfdf62c0$var$queue.length;\n    while(len){\n        $cfae44f0dfdf62c0$var$currentQueue = $cfae44f0dfdf62c0$var$queue;\n        $cfae44f0dfdf62c0$var$queue = [];\n        while(++$cfae44f0dfdf62c0$var$queueIndex < len)if ($cfae44f0dfdf62c0$var$currentQueue) $cfae44f0dfdf62c0$var$currentQueue[$cfae44f0dfdf62c0$var$queueIndex].run();\n        $cfae44f0dfdf62c0$var$queueIndex = -1;\n        len = $cfae44f0dfdf62c0$var$queue.length;\n    }\n    $cfae44f0dfdf62c0$var$currentQueue = null;\n    $cfae44f0dfdf62c0$var$draining = false;\n    $cfae44f0dfdf62c0$var$runClearTimeout(timeout);\n}\n$cfae44f0dfdf62c0$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $cfae44f0dfdf62c0$var$queue.push(new $cfae44f0dfdf62c0$var$Item(fun, args));\n    if ($cfae44f0dfdf62c0$var$queue.length === 1 && !$cfae44f0dfdf62c0$var$draining) $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $cfae44f0dfdf62c0$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$cfae44f0dfdf62c0$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$cfae44f0dfdf62c0$var$process.title = \"browser\";\n$cfae44f0dfdf62c0$var$process.browser = true;\n$cfae44f0dfdf62c0$var$process.env = {};\n$cfae44f0dfdf62c0$var$process.argv = [];\n$cfae44f0dfdf62c0$var$process.version = \"\"; // empty string to avoid regexp issues\n$cfae44f0dfdf62c0$var$process.versions = {};\nfunction $cfae44f0dfdf62c0$var$noop() {}\n$cfae44f0dfdf62c0$var$process.on = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.addListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.once = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.off = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeAllListeners = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.emit = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependOnceListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.listeners = function(name) {\n    return [];\n};\n$cfae44f0dfdf62c0$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.cwd = function() {\n    return \"/\";\n};\n$cfae44f0dfdf62c0$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.umask = function() {\n    return 0;\n};\n\n\n\nvar $6ZWSX = parcelRequire(\"6ZWSX\");\nvar $e6803e952bdec1ea$require$Buffer = $6ZWSX.Buffer;\n\nvar $8f8cee75b5422920$exports = {};\n$8f8cee75b5422920$exports = new URL(\"libultrahdr-esm.c9dc1563.wasm\", import.meta.url).toString();\n\n\n\nvar $e6803e952bdec1ea$var$Module = (()=>{\n    var _scriptDir = \"file:///example/libs/libultrahdr.js\";\n    return async function(moduleArg = {}) {\n        // include: shell.js\n        // The Module object: Our interface to the outside world. We import\n        // and export values on it. There are various ways Module can be used:\n        // 1. Not defined. We create it here\n        // 2. A function parameter, function(Module) { ..generated code.. }\n        // 3. pre-run appended it, var Module = {}; ..generated code..\n        // 4. External script tag defines var Module.\n        // We need to check if Module already exists (e.g. case 3 above).\n        // Substitution will be replaced with actual code on later stage of the build,\n        // this way Closure Compiler will not mangle it (e.g. case 4. above).\n        // Note that if you want to run closure, and also to use Module\n        // after the generated code, you will need to define   var Module = {};\n        // before the code. Then that object will be used in the code, and you\n        // can continue to use Module afterwards as well.\n        var Module = moduleArg;\n        // Set up the promise that indicates the Module is initialized\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        [\n            \"_main\",\n            \"_memory\",\n            \"___indirect_function_table\",\n            \"__embind_initialize_bindings\",\n            \"_fflush\",\n            \"onRuntimeInitialized\"\n        ].forEach((prop)=>{\n            if (!Object.getOwnPropertyDescriptor(Module[\"ready\"], prop)) Object.defineProperty(Module[\"ready\"], prop, {\n                get: ()=>abort(\"You are getting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\"),\n                set: ()=>abort(\"You are setting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\")\n            });\n        });\n        // --pre-jses are emitted after the Module integration code, so that they can\n        // refer to Module (if they choose; they can also define Module)\n        // Sometimes an existing Module object exists with properties\n        // meant to overwrite the default module functionality. Here\n        // we collect those properties and reapply _after_ we configure\n        // the current environment's defaults to avoid having to be so\n        // defensive during initialization.\n        var moduleOverrides = Object.assign({}, Module);\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        // Determine the runtime environment we are in. You can customize this by\n        // setting the ENVIRONMENT setting at compile time (see settings.js).\n        // Attempt to auto-detect the environment\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n        // N.b. Electron.js environment is simultaneously a NODE-environment, but\n        // also a web environment.\n        var ENVIRONMENT_IS_NODE = typeof $cfae44f0dfdf62c0$exports == \"object\" && typeof $cfae44f0dfdf62c0$exports.versions == \"object\" && typeof $cfae44f0dfdf62c0$exports.versions.node == \"string\";\n        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n        if (Module[\"ENVIRONMENT\"]) throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\");\n        // `/` should be present at the end if `scriptDirectory` is not empty\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) return Module[\"locateFile\"](path, scriptDirectory);\n            return scriptDirectory + path;\n        }\n        // Hooks that are implemented differently in different runtime environments.\n        var read_, readAsync, readBinary;\n        if (ENVIRONMENT_IS_NODE) {\n            if (typeof $cfae44f0dfdf62c0$exports == \"undefined\" || !$cfae44f0dfdf62c0$exports.release || $cfae44f0dfdf62c0$exports.release.name !== \"node\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n            var nodeVersion = $cfae44f0dfdf62c0$exports.versions.node;\n            var numericVersion = nodeVersion.split(\".\").slice(0, 3);\n            numericVersion = numericVersion[0] * 10000 + numericVersion[1] * 100 + numericVersion[2].split(\"-\")[0] * 1;\n            if (numericVersion < 160000) throw new Error(\"This emscripten-generated code requires node v16.0.0 (detected v\" + nodeVersion + \")\");\n            // `require()` is no-op in an ESM module, use `createRequire()` to construct\n            // the require()` function.  This is only necessary for multi-environment\n            // builds, `-sENVIRONMENT=node` emits a static import declaration instead.\n            // TODO: Swap all `require()`'s with `import()`'s?\n            const { createRequire: createRequire } = await (parcelRequire(\"7wftx\"));\n            /** @suppress{duplicate} */ var require1 = createRequire(\"file:///example/libs/libultrahdr.js\");\n            // These modules will usually be used on Node.js. Load them eagerly to avoid\n            // the complexity of lazy-loading.\n            var fs = require1(\"fs\");\n            var nodePath = require1(\"path\");\n            if (ENVIRONMENT_IS_WORKER) scriptDirectory = nodePath.dirname(scriptDirectory) + \"/\";\n            // include: node_shell_read.js\n            read_ = (filename, binary)=>{\n                // We need to re-wrap `file://` strings to URLs. Normalizing isn't\n                // necessary in that case, the path should already be absolute.\n                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n                return fs.readFileSync(filename, binary ? undefined : \"utf8\");\n            };\n            readBinary = (filename)=>{\n                var ret = read_(filename, true);\n                if (!ret.buffer) ret = new Uint8Array(ret);\n                assert(ret.buffer);\n                return ret;\n            };\n            readAsync = (filename, onload, onerror, binary = true)=>{\n                // See the comment in the `read_` function.\n                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n                fs.readFile(filename, binary ? undefined : \"utf8\", (err, data)=>{\n                    if (err) onerror(err);\n                    else onload(binary ? data.buffer : data);\n                });\n            };\n            // end include: node_shell_read.js\n            if (!Module[\"thisProgram\"] && $cfae44f0dfdf62c0$exports.argv.length > 1) thisProgram = $cfae44f0dfdf62c0$exports.argv[1].replace(/\\\\/g, \"/\");\n            $cfae44f0dfdf62c0$exports.argv.slice(2);\n            // MODULARIZE will export the module in the proper place outside, we don't need to export here\n            quit_ = (status, toThrow)=>{\n                $cfae44f0dfdf62c0$exports.exitCode = status;\n                throw toThrow;\n            };\n            Module[\"inspect\"] = ()=>\"[Emscripten Module object]\";\n        } else if (ENVIRONMENT_IS_SHELL) {\n            if (typeof $cfae44f0dfdf62c0$exports == \"object\" && typeof require1 === \"function\" || typeof window == \"object\" || typeof importScripts == \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n            if (typeof read != \"undefined\") read_ = read;\n            readBinary = (f)=>{\n                if (typeof readbuffer == \"function\") return new Uint8Array(readbuffer(f));\n                let data = read(f, \"binary\");\n                assert(typeof data == \"object\");\n                return data;\n            };\n            readAsync = (f, onload, onerror)=>{\n                setTimeout(()=>onload(readBinary(f)));\n            };\n            if (typeof clearTimeout == \"undefined\") globalThis.clearTimeout = (id)=>{};\n            if (typeof setTimeout == \"undefined\") // spidermonkey lacks setTimeout but we use it above in readAsync.\n            globalThis.setTimeout = (f)=>typeof f == \"function\" ? f() : abort();\n            if (typeof scriptArgs != \"undefined\") scriptArgs;\n            if (typeof quit == \"function\") quit_ = (status, toThrow)=>{\n                // Unlike node which has process.exitCode, d8 has no such mechanism. So we\n                // have no way to set the exit code and then let the program exit with\n                // that code when it naturally stops running (say, when all setTimeouts\n                // have completed). For that reason, we must call `quit` - the only way to\n                // set the exit code - but quit also halts immediately.  To increase\n                // consistency with node (and the web) we schedule the actual quit call\n                // using a setTimeout to give the current stack and any exception handlers\n                // a chance to run.  This enables features such as addOnPostRun (which\n                // expected to be able to run code after main returns).\n                setTimeout(()=>{\n                    if (!(toThrow instanceof ExitStatus)) {\n                        let toLog = toThrow;\n                        if (toThrow && typeof toThrow == \"object\" && toThrow.stack) toLog = [\n                            toThrow,\n                            toThrow.stack\n                        ];\n                        err(`exiting due to exception: ${toLog}`);\n                    }\n                    quit(status);\n                });\n                throw toThrow;\n            };\n            if (typeof print != \"undefined\") {\n                // Prefer to use print/printErr where they exist, as they usually work better.\n                if (typeof console == \"undefined\") console = /** @type{!Console} */ {};\n                console.log = /** @type{!function(this:Console, ...*): undefined} */ print;\n                console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ typeof printErr != \"undefined\" ? printErr : print;\n            }\n        } else // Note that this includes Node.js workers when relevant (pthreads is enabled).\n        // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n        // ENVIRONMENT_IS_NODE.\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;\n            else if (typeof document != \"undefined\" && document.currentScript) scriptDirectory = document.currentScript.src;\n            // When MODULARIZE, this JS may be executed later, after document.currentScript\n            // is gone, so we saved it, and we use it here instead of any other info.\n            if (_scriptDir) scriptDirectory = _scriptDir;\n            // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n            // otherwise, slice off the final part of the url to find the script directory.\n            // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n            // and scriptDirectory will correctly be replaced with an empty string.\n            // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n            // they are removed because they could contain a slash.\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            else scriptDirectory = \"\";\n            if (!(typeof window == \"object\" || typeof importScripts == \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n            // include: web_or_worker_shell_read.js\n            read_ = (url)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.send(null);\n                return xhr.responseText;\n            };\n            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(/** @type{!ArrayBuffer} */ xhr.response);\n            };\n            readAsync = (url, onload, onerror)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onload = ()=>{\n                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                        onload(xhr.response);\n                        return;\n                    }\n                    onerror();\n                };\n                xhr.onerror = onerror;\n                xhr.send(null);\n            };\n        } else throw new Error(\"environment detection error\");\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        // Merge back in the overrides\n        Object.assign(Module, moduleOverrides);\n        // Free the object hierarchy contained in the overrides, this lets the GC\n        // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n        moduleOverrides = null;\n        checkIncomingModuleAPI();\n        // Emit code to handle expected values on the Module object. This applies Module.x\n        // to the proper local x. This has two benefits: first, we only emit it if it is\n        // expected to arrive, and second, by using a local everywhere else that can be\n        // minified.\n        if (Module[\"arguments\"]) Module[\"arguments\"];\n        legacyModuleProp(\"arguments\", \"arguments_\");\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        legacyModuleProp(\"thisProgram\", \"thisProgram\");\n        if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n        legacyModuleProp(\"quit\", \"quit_\");\n        // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n        // Assertions on removed incoming Module JS APIs.\n        assert(typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"filePackagePrefixURL\"] == \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"read\"] == \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n        assert(typeof Module[\"readAsync\"] == \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n        assert(typeof Module[\"readBinary\"] == \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n        assert(typeof Module[\"setWindowTitle\"] == \"undefined\", \"Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)\");\n        assert(typeof Module[\"TOTAL_MEMORY\"] == \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n        legacyModuleProp(\"asm\", \"wasmExports\");\n        legacyModuleProp(\"read\", \"read_\");\n        legacyModuleProp(\"readAsync\", \"readAsync\");\n        legacyModuleProp(\"readBinary\", \"readBinary\");\n        legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\n        assert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\n        // end include: shell.js\n        // include: preamble.js\n        // === Preamble library stuff ===\n        // Documentation for the public APIs defined in this file must be updated in:\n        //    site/source/docs/api_reference/preamble.js.rst\n        // A prebuilt local version of the documentation is available at:\n        //    site/build/text/docs/api_reference/preamble.js.txt\n        // You can also build docs locally as HTML or other formats in site/\n        // An online HTML version (which may be of a different version of Emscripten)\n        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n        var wasmBinary;\n        if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n        legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\n        if (typeof WebAssembly != \"object\") abort(\"no native wasm support detected\");\n        // Wasm globals\n        var wasmMemory;\n        //========================================\n        // Runtime essentials\n        //========================================\n        // whether we are quitting the application. no code should run after this.\n        // set in exit() and abort()\n        var ABORT = false;\n        // set by exit() and abort().  Passed to 'onExit' handler.\n        // NOTE: This is also used as the process return code code in shell environments\n        // but only when noExitRuntime is false.\n        var EXITSTATUS;\n        /** @type {function(*, string=)} */ function assert(condition, text) {\n            if (!condition) abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n        }\n        // We used to include malloc/free by default in the past. Show a helpful error in\n        // builds with assertions.\n        // Memory management\n        var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        assert(!Module[\"STACK_SIZE\"], \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\");\n        assert(typeof Int32Array != \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, \"JS engine does not provide full typed array support\");\n        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n        assert(!Module[\"wasmMemory\"], \"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally\");\n        assert(!Module[\"INITIAL_MEMORY\"], \"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically\");\n        // include: runtime_stack_check.js\n        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n        function writeStackCookie() {\n            var max = _emscripten_stack_get_end();\n            assert((max & 3) == 0);\n            // If the stack ends at address zero we write our cookies 4 bytes into the\n            // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n            // monitor writes to address zero.\n            if (max == 0) max += 4;\n            // The stack grow downwards towards _emscripten_stack_get_end.\n            // We write cookies to the final two words in the stack and detect if they are\n            // ever overwritten.\n            HEAPU32[max >> 2] = 0x02135467;\n            HEAPU32[max + 4 >> 2] = 0x89BACDFE;\n            // Also test the global address 0 for integrity.\n            HEAPU32[0] = 1668509029;\n        }\n        function checkStackCookie() {\n            if (ABORT) return;\n            var max = _emscripten_stack_get_end();\n            // See writeStackCookie().\n            if (max == 0) max += 4;\n            var cookie1 = HEAPU32[max >> 2];\n            var cookie2 = HEAPU32[max + 4 >> 2];\n            if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n            // Also test the global address 0 for integrity.\n            if (HEAPU32[0] != 0x63736d65 /* 'emsc' */ ) abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\n        }\n        // end include: runtime_stack_check.js\n        // include: runtime_assertions.js\n        // Endianness check\n        (function() {\n            var h16 = new Int16Array(1);\n            var h8 = new Int8Array(h16.buffer);\n            h16[0] = 0x6373;\n            if (h8[0] !== 0x73 || h8[1] !== 0x63) throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n        })();\n        // end include: runtime_assertions.js\n        var __ATPRERUN__ = []; // functions called before the runtime is initialized\n        var __ATINIT__ = []; // functions called during startup\n        var __ATMAIN__ = []; // functions called when main() is to be run\n        var __ATPOSTRUN__ = []; // functions called after the main() is called\n        var runtimeInitialized = false;\n        function preRun() {\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length)addOnPreRun(Module[\"preRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            assert(!runtimeInitialized);\n            runtimeInitialized = true;\n            checkStackCookie();\n            if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n            FS.ignorePermissions = false;\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function preMain() {\n            checkStackCookie();\n            callRuntimeCallbacks(__ATMAIN__);\n        }\n        function postRun() {\n            checkStackCookie();\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length)addOnPostRun(Module[\"postRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        // include: runtime_math.js\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n        assert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        // end include: runtime_math.js\n        // A counter of dependencies for calling run(). If we need to\n        // do asynchronous work before running, increment this and\n        // decrement it. Incrementing must happen in a place like\n        // Module.preRun (used by emcc to add file preloading).\n        // Note that you can add dependencies in preRun, even though\n        // it happens right before run - run will be postponed until\n        // the dependencies are met.\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n        var runDependencyTracking = {};\n        function getUniqueRunDependency(id) {\n            var orig = id;\n            while(true){\n                if (!runDependencyTracking[id]) return id;\n                id = orig + Math.random();\n            }\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n            if (id) {\n                assert(!runDependencyTracking[id]);\n                runDependencyTracking[id] = 1;\n                if (runDependencyWatcher === null && typeof setInterval != \"undefined\") // Check for missing dependencies every few seconds\n                runDependencyWatcher = setInterval(()=>{\n                    if (ABORT) {\n                        clearInterval(runDependencyWatcher);\n                        runDependencyWatcher = null;\n                        return;\n                    }\n                    var shown = false;\n                    for(var dep in runDependencyTracking){\n                        if (!shown) {\n                            shown = true;\n                            err(\"still waiting on run dependencies:\");\n                        }\n                        err(`dependency: ${dep}`);\n                    }\n                    if (shown) err(\"(end of list)\");\n                }, 10000);\n            } else err(\"warning: run dependency added without ID\");\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n            if (id) {\n                assert(runDependencyTracking[id]);\n                delete runDependencyTracking[id];\n            } else err(\"warning: run dependency removed without ID\");\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback(); // can add another dependenciesFulfilled\n                }\n            }\n        }\n        /** @param {string|number=} what */ function abort(what) {\n            if (Module[\"onAbort\"]) Module[\"onAbort\"](what);\n            what = \"Aborted(\" + what + \")\";\n            // TODO(sbc): Should we remove printing and leave it up to whoever\n            // catches the exception?\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            // Use a wasm runtime error, because a JS error might be seen as a foreign\n            // exception, which means we'd run destructors on it. We need the error to\n            // simply make the program stop.\n            // FIXME This approach does not work in Wasm EH because it currently does not assume\n            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n            // a trap or not based on a hidden field within the object. So at the moment\n            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n            // allows this in the wasm spec.\n            // Suppress closure compiler warning here. Closure compiler's builtin extern\n            // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n            // though it can.\n            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n            /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            // Throw the error whether or not MODULARIZE is set because abort is used\n            // in code paths apart from instantiation where an exception is expected\n            // to be thrown when abort is called.\n            throw e;\n        }\n        // include: memoryprofiler.js\n        // end include: memoryprofiler.js\n        // include: URIUtils.js\n        // Prefix of data URIs emitted by SINGLE_FILE and related options.\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        /**\r\n   * Indicates whether filename is a base64 data URI.\r\n   * @noinline\r\n   */ var isDataURI = (filename)=>filename.startsWith(dataURIPrefix);\n        /**\r\n   * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n   * @noinline\r\n   */ var isFileURI = (filename)=>filename.startsWith(\"file://\");\n        // end include: URIUtils.js\n        function createExportWrapper(name) {\n            return function() {\n                assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n                var f = wasmExports[name];\n                assert(f, `exported native function \\`${name}\\` not found`);\n                return f.apply(null, arguments);\n            };\n        }\n        // include: runtime_exceptions.js\n        // end include: runtime_exceptions.js\n        var wasmBinaryFile;\n        if (Module[\"locateFile\"]) {\n            wasmBinaryFile = \"libultrahdr-esm.wasm\";\n            if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);\n        } else // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n        wasmBinaryFile = new URL($8f8cee75b5422920$exports).href;\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);\n            if (readBinary) return readBinary(file);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            // If we don't have the binary yet, try to load it asynchronously.\n            // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n            // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n            // Cordova or Electron apps are typically loaded from a file:// url.\n            // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == \"function\" && !isFileURI(binaryFile)) return fetch(binaryFile, {\n                    credentials: \"same-origin\"\n                }).then((response)=>{\n                    if (!response[\"ok\"]) throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                    return response[\"arrayBuffer\"]();\n                }).catch(()=>getBinarySync(binaryFile));\n                else if (readAsync) // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\n                return new Promise((resolve, reject)=>{\n                    readAsync(binaryFile, (response)=>resolve(new Uint8Array(/** @type{!ArrayBuffer} */ response)), reject);\n                });\n            }\n            // Otherwise, getBinarySync should be able to get it synchronously\n            return Promise.resolve().then(function() {\n                return (parcelRequire(\"7wftx\"));\n            }).then((res)=>getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary)=>{\n                return WebAssembly.instantiate(binary, imports);\n            }).then((instance)=>{\n                return instance;\n            }).then(receiver, (reason)=>{\n                err(`failed to asynchronously prepare wasm: ${reason}`);\n                // Warn on some common problems.\n                if (isFileURI(wasmBinaryFile)) err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n            !isFileURI(binaryFile) && // Avoid instantiateStreaming() on Node.js environment for now, as while\n            // Node.js v18.1.0 implements it, it does not have a full fetch()\n            // implementation yet.\n            //\n            // Reference:\n            //   https://github.com/emscripten-core/emscripten/pull/16917\n            !ENVIRONMENT_IS_NODE && typeof fetch == \"function\") return fetch(binaryFile, {\n                credentials: \"same-origin\"\n            }).then((response)=>{\n                // Suppress closure warning here since the upstream definition for\n                // instantiateStreaming only allows Promise<Repsponse> rather than\n                // an actual Response.\n                // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n                /** @suppress {checkTypes} */ var result = WebAssembly.instantiateStreaming(response, imports);\n                return result.then(callback, function(reason) {\n                    // We expect the most common failure cause to be a bad MIME type for the binary,\n                    // in which case falling back to ArrayBuffer instantiation should work.\n                    err(`wasm streaming compile failed: ${reason}`);\n                    err(\"falling back to ArrayBuffer instantiation\");\n                    return instantiateArrayBuffer(binaryFile, imports, callback);\n                });\n            });\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        // Create the wasm instance.\n        // Receives the wasm imports, returns the exports.\n        function createWasm() {\n            // prepare imports\n            var info = {\n                \"env\": wasmImports,\n                \"wasi_snapshot_preview1\": wasmImports\n            };\n            // Load the wasm module and create an instance of using native support in the JS engine.\n            // handle a generated wasm instance, receiving its exports and\n            // performing other necessary setup\n            /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {\n                wasmExports = instance.exports;\n                wasmMemory = wasmExports[\"memory\"];\n                assert(wasmMemory, \"memory not found in wasm exports\");\n                // This assertion doesn't hold when emscripten is run in --post-link\n                // mode.\n                // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n                //assert(wasmMemory.buffer.byteLength === 16777216);\n                updateMemoryViews();\n                wasmTable = wasmExports[\"__indirect_function_table\"];\n                assert(wasmTable, \"table not found in wasm exports\");\n                addOnInit(wasmExports[\"__wasm_call_ctors\"]);\n                removeRunDependency(\"wasm-instantiate\");\n                return wasmExports;\n            }\n            // wait for the pthread pool (if any)\n            addRunDependency(\"wasm-instantiate\");\n            // Prefer streaming instantiation if available.\n            // Async compilation can be confusing when an error on the page overwrites Module\n            // (for example, if the order of elements is wrong, and the one defining Module is\n            // later), so we save Module and check it later.\n            var trueModule = Module;\n            function receiveInstantiationResult(result) {\n                // 'result' is a ResultObject object which has both the module and instance.\n                // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n                assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n                trueModule = null;\n                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n                // When the regression is fixed, can restore the above PTHREADS-enabled path.\n                receiveInstance(result[\"instance\"]);\n            }\n            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n            // to manually instantiate the Wasm module themselves. This allows pages to\n            // run the instantiation parallel to any other async startup actions they are\n            // performing.\n            // Also pthreads and wasm workers initialize the wasm instance through this\n            // path.\n            if (Module[\"instantiateWasm\"]) try {\n                return Module[\"instantiateWasm\"](info, receiveInstance);\n            } catch (e) {\n                err(`Module.instantiateWasm callback failed with error: ${e}`);\n                // If instantiation fails, reject the module ready promise.\n                readyPromiseReject(e);\n            }\n            // If instantiation fails, reject the module ready promise.\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {}; // no exports yet; we'll fill them in later\n        }\n        // Globals used by JS i64 conversions (see makeSetValue)\n        var tempDouble;\n        var tempI64;\n        // include: runtime_debug.js\n        function legacyModuleProp(prop, newName, incomming = true) {\n            if (!Object.getOwnPropertyDescriptor(Module, prop)) Object.defineProperty(Module, prop, {\n                configurable: true,\n                get () {\n                    let extra = incomming ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\" : \"\";\n                    abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n                }\n            });\n        }\n        function ignoredModuleProp(prop) {\n            if (Object.getOwnPropertyDescriptor(Module, prop)) abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n        }\n        // forcing the filesystem exports a few things by default\n        function isExportedByForceFilesystem(name) {\n            return name === \"FS_createPath\" || name === \"FS_createDataFile\" || name === \"FS_createPreloadedFile\" || name === \"FS_unlink\" || name === \"addRunDependency\" || // The old FS has some functionality that WasmFS lacks.\n            name === \"FS_createLazyFile\" || name === \"FS_createDevice\" || name === \"removeRunDependency\";\n        }\n        function missingGlobal(sym, msg) {\n            if (typeof globalThis !== \"undefined\") Object.defineProperty(globalThis, sym, {\n                configurable: true,\n                get () {\n                    warnOnce(\"`\" + sym + \"` is not longer defined by emscripten. \" + msg);\n                    return undefined;\n                }\n            });\n        }\n        missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\n        missingGlobal(\"asm\", \"Please use wasmExports instead\");\n        function missingLibrarySymbol(sym) {\n            if (typeof globalThis !== \"undefined\" && !Object.getOwnPropertyDescriptor(globalThis, sym)) Object.defineProperty(globalThis, sym, {\n                configurable: true,\n                get () {\n                    // Can't `abort()` here because it would break code that does runtime\n                    // checks.  e.g. `if (typeof SDL === 'undefined')`.\n                    var msg = \"`\" + sym + \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n                    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n                    // library.js, which means $name for a JS name with no prefix, or name\n                    // for a JS name like _name.\n                    var librarySymbol = sym;\n                    if (!librarySymbol.startsWith(\"_\")) librarySymbol = \"$\" + sym;\n                    msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" + librarySymbol + \"')\";\n                    if (isExportedByForceFilesystem(sym)) msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n                    warnOnce(msg);\n                    return undefined;\n                }\n            });\n            // Any symbol that is not included from the JS libary is also (by definition)\n            // not exported on the Module object.\n            unexportedRuntimeSymbol(sym);\n        }\n        function unexportedRuntimeSymbol(sym) {\n            if (!Object.getOwnPropertyDescriptor(Module, sym)) Object.defineProperty(Module, sym, {\n                configurable: true,\n                get () {\n                    var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\n                    if (isExportedByForceFilesystem(sym)) msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n                    abort(msg);\n                }\n            });\n        }\n        // end include: runtime_debug.js\n        // === Body ===\n        // end include: preamble.js\n        /** @constructor */ function ExitStatus(status) {\n            this.name = \"ExitStatus\";\n            this.message = `Program terminated with exit(${status})`;\n            this.status = status;\n        }\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0)// Pass the module as the first argument.\n            callbacks.shift()(Module);\n        };\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        var ptrToString = (ptr)=>{\n            assert(typeof ptr === \"number\");\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            ptr >>>= 0;\n            return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n        };\n        var warnOnce = (text)=>{\n            if (!warnOnce.shown) warnOnce.shown = {};\n            if (!warnOnce.shown[text]) {\n                warnOnce.shown[text] = 1;\n                if (ENVIRONMENT_IS_NODE) text = \"warning: \" + text;\n                err(text);\n            }\n        };\n        /** @constructor */ function ExceptionInfo(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n            this.set_type = function(type) {\n                HEAPU32[this.ptr + 4 >> 2] = type;\n            };\n            this.get_type = function() {\n                return HEAPU32[this.ptr + 4 >> 2];\n            };\n            this.set_destructor = function(destructor) {\n                HEAPU32[this.ptr + 8 >> 2] = destructor;\n            };\n            this.get_destructor = function() {\n                return HEAPU32[this.ptr + 8 >> 2];\n            };\n            this.set_caught = function(caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[this.ptr + 12 >> 0] = caught;\n            };\n            this.get_caught = function() {\n                return HEAP8[this.ptr + 12 >> 0] != 0;\n            };\n            this.set_rethrown = function(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[this.ptr + 13 >> 0] = rethrown;\n            };\n            this.get_rethrown = function() {\n                return HEAP8[this.ptr + 13 >> 0] != 0;\n            };\n            // Initialize native structure fields. Should be called once after allocated.\n            this.init = function(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            };\n            this.set_adjusted_ptr = function(adjustedPtr) {\n                HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n            };\n            this.get_adjusted_ptr = function() {\n                return HEAPU32[this.ptr + 16 >> 2];\n            };\n            // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\n            // when the pointer is casted to some of the exception object base classes (e.g. when virtual\n            // inheritance is used). When a pointer is thrown this method should return the thrown pointer\n            // itself.\n            this.get_exception_ptr = function() {\n                // Work around a fastcomp bug, this code is still included for some reason in a build without\n                // exceptions support.\n                var isPointer = ___cxa_is_pointer_type(this.get_type());\n                if (isPointer) return HEAPU32[this.excPtr >> 2];\n                var adjusted = this.get_adjusted_ptr();\n                if (adjusted !== 0) return adjusted;\n                return this.excPtr;\n            };\n        }\n        var ___cxa_throw = (ptr, type, destructor)=>{\n            var info = new ExceptionInfo(ptr);\n            // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n            info.init(type, destructor);\n            assert(false, \"Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.\");\n        };\n        var structRegistrations = {};\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        /** @suppress {globalThis} */ function simpleReadValueFromPointer(pointer) {\n            return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var InternalError;\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach(function(type) {\n                typeDependencies[type] = dependentTypes;\n            });\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) throwInternalError(\"Mismatched type converter count\");\n                for(var i = 0; i < myTypes.length; ++i)registerType(myTypes[i], myTypeConverters[i]);\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) typeConverters[i] = registeredTypes[dt];\n                else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) onComplete(typeConverters);\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) onComplete(typeConverters);\n        };\n        var __embind_finalize_value_object = (structType)=>{\n            var reg = structRegistrations[structType];\n            delete structRegistrations[structType];\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            var fieldRecords = reg.fields;\n            var fieldTypes = fieldRecords.map((field)=>field.getterReturnType).concat(fieldRecords.map((field)=>field.setterArgumentType));\n            whenDependentTypesAreResolved([\n                structType\n            ], fieldTypes, (fieldTypes)=>{\n                var fields = {};\n                fieldRecords.forEach((field, i)=>{\n                    var fieldName = field.fieldName;\n                    var getterReturnType = fieldTypes[i];\n                    var getter = field.getter;\n                    var getterContext = field.getterContext;\n                    var setterArgumentType = fieldTypes[i + fieldRecords.length];\n                    var setter = field.setter;\n                    var setterContext = field.setterContext;\n                    fields[fieldName] = {\n                        read: (ptr)=>{\n                            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                        },\n                        write: (ptr, o)=>{\n                            var destructors = [];\n                            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                            runDestructors(destructors);\n                        }\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        \"fromWireType\": (ptr)=>{\n                            var rv = {};\n                            for(var i in fields)rv[i] = fields[i].read(ptr);\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        \"toWireType\": (destructors, o)=>{\n                            // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\n                            // assume all fields are present without checking.\n                            for(var fieldName in fields){\n                                if (!(fieldName in o)) throw new TypeError(`Missing field: \"${fieldName}\"`);\n                            }\n                            var ptr = rawConstructor();\n                            for(fieldName in fields)fields[fieldName].write(ptr, o[fieldName]);\n                            if (destructors !== null) destructors.push(rawDestructor, ptr);\n                            return ptr;\n                        },\n                        \"argPackAdvance\": GenericWireTypeSize,\n                        \"readValueFromPointer\": simpleReadValueFromPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange)=>{};\n        var embind_init_charCodes = ()=>{\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i)codes[i] = String.fromCharCode(i);\n            embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr)=>{\n            var ret = \"\";\n            var c = ptr;\n            while(HEAPU8[c])ret += embind_charCodes[HEAPU8[c++]];\n            return ret;\n        };\n        var BindingError;\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        /** @param {Object=} options */ function sharedRegisterType(rawType, registeredInstance, options = {}) {\n            var name = registeredInstance.name;\n            if (!rawType) throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) return;\n                else throwBindingError(`Cannot register type '${name}' twice`);\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        /** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {\n            if (!(\"argPackAdvance\" in registeredInstance)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        /** @suppress {globalThis} */ var __embind_register_bool = (rawType, name, trueValue, falseValue)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(wt) {\n                    // ambiguous emscripten ABI: sometimes return values are\n                    // true or false, and sometimes integers (0 or 1)\n                    return !!wt;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": function(pointer) {\n                    return this[\"fromWireType\"](HEAPU8[pointer]);\n                },\n                destructorFunction: null\n            });\n        };\n        function handleAllocatorInit() {\n            Object.assign(HandleAllocator.prototype, /** @lends {HandleAllocator.prototype} */ {\n                get (id) {\n                    assert(this.allocated[id] !== undefined, `invalid handle: ${id}`);\n                    return this.allocated[id];\n                },\n                has (id) {\n                    return this.allocated[id] !== undefined;\n                },\n                allocate (handle) {\n                    var id = this.freelist.pop() || this.allocated.length;\n                    this.allocated[id] = handle;\n                    return id;\n                },\n                free (id) {\n                    assert(this.allocated[id] !== undefined);\n                    // Set the slot to `undefined` rather than using `delete` here since\n                    // apparently arrays with holes in them can be less efficient.\n                    this.allocated[id] = undefined;\n                    this.freelist.push(id);\n                }\n            });\n        }\n        /** @constructor */ function HandleAllocator() {\n            // Reserve slot 0 so that 0 is always an invalid handle\n            this.allocated = [\n                undefined\n            ];\n            this.freelist = [];\n        }\n        var emval_handles = new HandleAllocator();\n        var __emval_decref = (handle)=>{\n            if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) emval_handles.free(handle);\n        };\n        var count_emval_handles = ()=>{\n            var count = 0;\n            for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i)if (emval_handles.allocated[i] !== undefined) ++count;\n            return count;\n        };\n        var init_emval = ()=>{\n            // reserve some special values. These never get de-allocated.\n            // The HandleAllocator takes care of reserving zero.\n            emval_handles.allocated.push({\n                value: undefined\n            }, {\n                value: null\n            }, {\n                value: true\n            }, {\n                value: false\n            });\n            emval_handles.reserved = emval_handles.allocated.length;\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                return emval_handles.get(handle).value;\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 1;\n                    case null:\n                        return 2;\n                    case true:\n                        return 3;\n                    case false:\n                        return 4;\n                    default:\n                        return emval_handles.allocate({\n                            refcount: 1,\n                            value: value\n                        });\n                }\n            }\n        };\n        var __embind_register_emval = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (handle)=>{\n                    var rv = Emval.toValue(handle);\n                    __emval_decref(handle);\n                    return rv;\n                },\n                \"toWireType\": (destructors, value)=>Emval.toHandle(value),\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: null\n            });\n        };\n        var embindRepr = (v)=>{\n            if (v === null) return \"null\";\n            var t = typeof v;\n            if (t === \"object\" || t === \"array\" || t === \"function\") return v.toString();\n            else return \"\" + v;\n        };\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(`invalid float width (${width}): ${name}`);\n            }\n        };\n        var __embind_register_float = (rawType, name, size)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>value,\n                \"toWireType\": (destructors, value)=>{\n                    if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\n                    // The VM will perform JS to Wasm value conversion, according to the spec:\n                    // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n                    return value;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        var char_0 = 48;\n        var char_9 = 57;\n        var makeLegalFunctionName = (name)=>{\n            if (undefined === name) return \"_unknown\";\n            name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n            var f = name.charCodeAt(0);\n            if (f >= char_0 && f <= char_9) return `_${name}`;\n            return name;\n        };\n        function createNamedFunction(name, body) {\n            name = makeLegalFunctionName(name);\n            // Use an abject with a computed property name to create a new function with\n            // a name specified at runtime, but without using `new Function` or `eval`.\n            return ({\n                [name]: function() {\n                    return body.apply(this, arguments);\n                }\n            })[name];\n        }\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);\n            /*\r\n\t\t * Previously, the following line was just:\r\n\t\t *   function dummy() {};\r\n\t\t * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\r\n\t\t * though at creation, the 'dummy' has the correct constructor name.  Thus,\r\n\t\t * objects created with IMVU.new would show up in the debugger as 'dummy',\r\n\t\t * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\r\n\t\t * issue.  Doublely-unfortunately, there's no way to write a test for this\r\n\t\t * behavior.  -NRD 2013.02.22\r\n\t\t */ var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy;\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\n            // humanName: a human-readable string name for the function to be generated.\n            // argTypes: An array that contains the embind type objects for all types in the function signature.\n            //    argTypes[0] is the type object for the function return value.\n            //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n            //    argTypes[2...] are the actual function parameters.\n            // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n            // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n            // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n            // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\n            var argCount = argTypes.length;\n            if (argCount < 2) throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            assert(!isAsync, \"Async bindings are only supported with JSPI.\");\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n            // TODO: This omits argument count check - enable only at -O3 or similar.\n            //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n            //       return FUNCTION_TABLE[fn];\n            //    }\n            // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n            // TODO: Remove this completely once all function invokers are being dynamically generated.\n            var needsDestructorStack = false;\n            for(var i = 1; i < argTypes.length; ++i)if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n                needsDestructorStack = true;\n                break;\n            }\n            var returns = argTypes[0].name !== \"void\";\n            var argsList = \"\";\n            var argsListWired = \"\";\n            for(var i = 0; i < argCount - 2; ++i){\n                argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n                argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n            }\n            var invokerFnBody = `\r\n\t\t  return function ${makeLegalFunctionName(humanName)}(${argsList}) {\r\n\t\t  if (arguments.length !== ${argCount - 2}) {\r\n\t\t\tthrowBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\r\n\t\t  }`;\n            if (needsDestructorStack) invokerFnBody += \"var destructors = [];\\n\";\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            var args2 = [\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            if (isClassMethodFunc) invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n            for(var i = 0; i < argCount - 2; ++i){\n                invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n                args1.push(\"argType\" + i);\n                args2.push(argTypes[i + 2]);\n            }\n            if (isClassMethodFunc) argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n            if (needsDestructorStack) invokerFnBody += \"runDestructors(destructors);\\n\";\n            else for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                if (argTypes[i].destructorFunction !== null) {\n                    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n                    args1.push(paramName + \"_dtor\");\n                    args2.push(argTypes[i].destructorFunction);\n                }\n            }\n            if (returns) invokerFnBody += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\";\n            invokerFnBody += \"}\\n\";\n            args1.push(invokerFnBody);\n            return newFunc(Function, args1).apply(null, args2);\n        }\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n                proto[methodName] = function() {\n                    // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n                    if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);\n                    return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n                };\n                // Move the previous function into the overload table.\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        /** @param {number=} numArguments */ var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) throwBindingError(`Cannot register public name '${name}' twice`);\n                // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n                // that routes between the two.\n                ensureOverloadTable(Module, name, name);\n                if (Module.hasOwnProperty(numArguments)) throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\n                // Add the new function into the overload table.\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                if (undefined !== numArguments) Module[name].numArguments = numArguments;\n            }\n        };\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++)// TODO(https://github.com/emscripten-core/emscripten/issues/17310):\n            // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\n            array.push(HEAPU32[firstElement + i * 4 >> 2]);\n            return array;\n        };\n        /** @param {number=} numArguments */ var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) throwInternalError(\"Replacing nonexistant public symbol\");\n            // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) Module[name].overloadTable[numArguments] = value;\n            else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var dynCallLegacy = (sig, ptr, args)=>{\n            assert(\"dynCall_\" + sig in Module, `bad function pointer type - dynCall function not found for sig '${sig}'`);\n            if (args && args.length) // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\n            assert(args.length === sig.substring(1).replace(/j/g, \"--\").length);\n            else assert(sig.length == 1);\n            var f = Module[\"dynCall_\" + sig];\n            return args && args.length ? f.apply(null, [\n                ptr\n            ].concat(args)) : f.call(null, ptr);\n        };\n        var wasmTableMirror = [];\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n            return func;\n        };\n        /** @param {Object=} args */ var dynCall = (sig, ptr, args)=>{\n            // Without WASM_BIGINT support we cannot directly call function with i64 as\n            // part of thier signature, so we rely the dynCall functions generated by\n            // wasm-emscripten-finalize\n            if (sig.includes(\"j\")) return dynCallLegacy(sig, ptr, args);\n            assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);\n            var rtn = getWasmTableEntry(ptr).apply(null, args);\n            return rtn;\n        };\n        var getDynCaller = (sig, ptr)=>{\n            assert(sig.includes(\"j\") || sig.includes(\"p\"), \"getDynCaller should only be called with i64 sigs\");\n            var argCache = [];\n            return function() {\n                argCache.length = 0;\n                Object.assign(argCache, arguments);\n                return dynCall(sig, ptr, argCache);\n            };\n        };\n        var embind__requireFunction = (signature, rawFunction)=>{\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) return getDynCaller(signature, rawFunction);\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n            return fp;\n        };\n        var extendError = (baseErrorType, errorName)=>{\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) return this.name;\n                else return `${this.name}: ${this.message}`;\n            };\n            return errorClass;\n        };\n        var UnboundTypeError;\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) return;\n                if (registeredTypes[type]) return;\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        };\n        var getFunctionName = (signature)=>{\n            signature = signature.trim();\n            const argsIndex = signature.indexOf(\"(\");\n            if (argsIndex !== -1) {\n                assert(signature[signature.length - 1] == \")\", \"Parentheses for argument names should match.\");\n                return signature.substr(0, argsIndex);\n            } else return signature;\n        };\n        var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync)=>{\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = readLatin1String(name);\n            name = getFunctionName(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        };\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            // integers are quite common, so generate very specialized functions\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>HEAP8[pointer >> 0] : (pointer)=>HEAPU8[pointer >> 0];\n                case 2:\n                    return signed ? (pointer)=>HEAP16[pointer >> 1] : (pointer)=>HEAPU16[pointer >> 1];\n                case 4:\n                    return signed ? (pointer)=>HEAP32[pointer >> 2] : (pointer)=>HEAPU32[pointer >> 2];\n                default:\n                    throw new TypeError(`invalid integer width (${width}): ${name}`);\n            }\n        };\n        /** @suppress {globalThis} */ var __embind_register_integer = (primitiveType, name, size, minRange, maxRange)=>{\n            name = readLatin1String(name);\n            // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\n            // out as 'i32 -1'. Always treat those as max u32.\n            if (maxRange === -1) maxRange = 4294967295;\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{\n                if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${toTypeName}`);\n                if (value < minRange || value > maxRange) throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\n            };\n            var toWireType;\n            if (isUnsignedType) toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value >>> 0;\n            };\n            else toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                // The VM will perform JS to Wasm value conversion, according to the spec:\n                // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n                return value;\n            };\n            registerType(primitiveType, {\n                name: name,\n                \"fromWireType\": fromWireType,\n                \"toWireType\": toWireType,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_memory_view = (rawType, dataTypeIndex, name)=>{\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = HEAPU32[handle >> 2];\n                var data = HEAPU32[handle + 4 >> 2];\n                return new TA(HEAP8.buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": decodeMemoryView,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        };\n        /** @suppress {globalThis} */ function readPointer(pointer) {\n            return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n        }\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            assert(typeof str === \"string\");\n            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n            // undefined and false each don't write out any bytes.\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n            for(var i = 0; i < str.length; ++i){\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n                // unit, not a Unicode code point of the character! So decode\n                // UTF16->UTF32->UTF8.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n                // and https://www.ietf.org/rfc/rfc2279.txt\n                // and https://tools.ietf.org/html/rfc3629\n                var u = str.charCodeAt(i); // possibly a lead surrogate\n                if (u >= 0xD800 && u <= 0xDFFF) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n                }\n                if (u <= 0x7F) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 0x7FF) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 0xC0 | u >> 6;\n                    heap[outIdx++] = 0x80 | u & 63;\n                } else if (u <= 0xFFFF) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 0xE0 | u >> 12;\n                    heap[outIdx++] = 0x80 | u >> 6 & 63;\n                    heap[outIdx++] = 0x80 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    if (u > 0x10FFFF) warnOnce(\"Invalid Unicode code point \" + ptrToString(u) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n                    heap[outIdx++] = 0xF0 | u >> 18;\n                    heap[outIdx++] = 0x80 | u >> 12 & 63;\n                    heap[outIdx++] = 0x80 | u >> 6 & 63;\n                    heap[outIdx++] = 0x80 | u & 63;\n                }\n            }\n            // Null-terminate the pointer to the buffer.\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>{\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        };\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n                // unit, not a Unicode code point of the character! So decode\n                // UTF16->UTF32->UTF8.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                var c = str.charCodeAt(i); // possibly a lead surrogate\n                if (c <= 0x7F) len++;\n                else if (c <= 0x7FF) len += 2;\n                else if (c >= 0xD800 && c <= 0xDFFF) {\n                    len += 4;\n                    ++i;\n                } else len += 3;\n            }\n            return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        /**\r\n\t   * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n\t   * array that contains uint8 values, returns a copy of that string as a\r\n\t   * Javascript String object.\r\n\t   * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n\t   * @param {number} idx\r\n\t   * @param {number=} maxBytesToRead\r\n\t   * @return {string}\r\n\t   */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            // TextDecoder needs to know the byte length in advance, it doesn't stop on\n            // null terminator by itself.  Also, use the length info to avoid running tiny\n            // strings through TextDecoder, since .subarray() allocates garbage.\n            // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n            // so that undefined means Infinity)\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            var str = \"\";\n            // If building with TextDecoder, we have already computed the string length\n            // above, so test loop end condition against that\n            while(idx < endPtr){\n                // For UTF8 byte structure, see:\n                // http://en.wikipedia.org/wiki/UTF-8#Description\n                // https://www.ietf.org/rfc/rfc2279.txt\n                // https://tools.ietf.org/html/rfc3629\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 0x80)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xE0) == 0xC0) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 0xF0) == 0xE0) u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                else {\n                    if ((u0 & 0xF8) != 0xF0) warnOnce(\"Invalid UTF-8 leading byte \" + ptrToString(u0) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                }\n                if (u0 < 0x10000) str += String.fromCharCode(u0);\n                else {\n                    var ch = u0 - 0x10000;\n                    str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n                }\n            }\n            return str;\n        };\n        /**\r\n\t   * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n\t   * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n\t   *\r\n\t   * @param {number} ptr\r\n\t   * @param {number=} maxBytesToRead - An optional length that specifies the\r\n\t   *   maximum number of bytes to read. You can omit this parameter to scan the\r\n\t   *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n\t   *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n\t   *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n\t   *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n\t   *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n\t   *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n\t   * @return {string}\r\n\t   */ var UTF8ToString = (ptr, maxBytesToRead)=>{\n            assert(typeof ptr == \"number\");\n            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n        };\n        var __embind_register_std_string = (rawType, name)=>{\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                // For some method names we use string keys here since they are part of\n                // the public/external API and/or used by the runtime-generated code.\n                \"fromWireType\" (value) {\n                    var length = HEAPU32[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        // Looping here to support possible embedded '0' bytes\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || HEAPU8[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) str = stringSegment;\n                                else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i)a[i] = String.fromCharCode(HEAPU8[payload + i]);\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\" (destructors, value) {\n                    if (value instanceof ArrayBuffer) value = new Uint8Array(value);\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) throwBindingError(\"Cannot pass non-string to std::string\");\n                    if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);\n                    else length = value.length;\n                    // assumes 4-byte alignment\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    HEAPU32[base >> 2] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) stringToUTF8(value, ptr, length + 1);\n                    else {\n                        if (valueIsOfTypeString) for(var i = 0; i < length; ++i){\n                            var charCode = value.charCodeAt(i);\n                            if (charCode > 255) {\n                                _free(ptr);\n                                throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                            }\n                            HEAPU8[ptr + i] = charCode;\n                        }\n                        else for(var i = 0; i < length; ++i)HEAPU8[ptr + i] = value[i];\n                    }\n                    if (destructors !== null) destructors.push(_free, base);\n                    return base;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n            var endPtr = ptr;\n            // TextDecoder needs to know the byte length in advance, it doesn't stop on\n            // null terminator by itself.\n            // Also, use the length info to avoid running tiny strings through\n            // TextDecoder, since .subarray() allocates garbage.\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n            // will always evaluate to true. This saves on code size.\n            while(!(idx >= maxIdx) && HEAPU16[idx])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n            // Fallback: decode without UTF16Decoder\n            var str = \"\";\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n            // for-loop's condition will always evaluate to true. The loop is then\n            // terminated on the first null char.\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = HEAP16[ptr + i * 2 >> 1];\n                if (codeUnit == 0) break;\n                // fromCharCode constructs a character from a UTF-16 code unit, so we can\n                // pass the UTF16 string right through.\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 0x7FFFFFFF;\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2; // Null terminator.\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n                var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n                HEAP16[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            // Null-terminate the pointer to the HEAP.\n            HEAP16[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>{\n            return str.length * 2;\n        };\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n            var i = 0;\n            var str = \"\";\n            // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n            // will always evaluate to true. This saves on code size.\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = HEAP32[ptr + i * 4 >> 2];\n                if (utf32 == 0) break;\n                ++i;\n                // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                if (utf32 >= 0x10000) {\n                    var ch = utf32 - 0x10000;\n                    str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n                } else str += String.fromCharCode(utf32);\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 0x7FFFFFFF;\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n                if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n                }\n                HEAP32[outPtr >> 2] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            // Null-terminate the pointer to the HEAP.\n            HEAP32[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n                // See http://unicode.org/faq/utf_bom.html#utf16-3\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = (rawType, charSize, name)=>{\n            name = readLatin1String(name);\n            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                getHeap = ()=>HEAPU16;\n                shift = 1;\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                getHeap = ()=>HEAPU32;\n                shift = 2;\n            }\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>{\n                    // Code mostly taken from _embind_register_std_string fromWireType\n                    var length = HEAPU32[value >> 2];\n                    var HEAP = getHeap();\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    // Looping here to support possible embedded '0' bytes\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) str = stringSegment;\n                            else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": (destructors, value)=>{\n                    if (!(typeof value == \"string\")) throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n                    // assumes 4-byte alignment\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    HEAPU32[ptr >> 2] = length >> shift;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) destructors.push(_free, ptr);\n                    return ptr;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var __embind_register_value_object = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor)=>{\n            structRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                fields: []\n            };\n        };\n        var __embind_register_value_object_field = (structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext)=>{\n            structRegistrations[structType].fields.push({\n                fieldName: readLatin1String(fieldName),\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        };\n        var __embind_register_void = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                \"argPackAdvance\": 0,\n                \"fromWireType\": ()=>undefined,\n                // TODO: assert if anything else is given?\n                \"toWireType\": (destructors, o)=>undefined\n            });\n        };\n        var __emscripten_throw_longjmp = ()=>{\n            throw Infinity;\n        };\n        var __emval_incref = (handle)=>{\n            if (handle > 4) emval_handles.get(handle).refcount += 1;\n        };\n        var emval_symbols = {};\n        var getStringOrSymbol = (address)=>{\n            var symbol = emval_symbols[address];\n            if (symbol === undefined) return readLatin1String(address);\n            return symbol;\n        };\n        var __emval_new_cstring = (v)=>{\n            return Emval.toHandle(getStringOrSymbol(v));\n        };\n        var requireRegisteredType = (rawType, humanName)=>{\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n            return impl;\n        };\n        var __emval_take_value = (type, arg)=>{\n            type = requireRegisteredType(type, \"_emval_take_value\");\n            var v = type[\"readValueFromPointer\"](arg);\n            return Emval.toHandle(v);\n        };\n        var _abort = ()=>{\n            abort(\"native code called abort()\");\n        };\n        var _emscripten_memcpy_js = (dest, src, num)=>HEAPU8.copyWithin(dest, src, src + num);\n        var getHeapMax = ()=>// Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n            // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n            // for any code that deals with heap sizes, which would require special\n            // casing all heap size related code to treat 0 specially.\n            2147483648;\n        var growMemory = (size)=>{\n            var b = wasmMemory.buffer;\n            var pages = (size - b.byteLength + 65535) / 65536;\n            try {\n                // round size grow request up to wasm page size (fixed 64KB per spec)\n                wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\n                updateMemoryViews();\n                return 1 /*success*/ ;\n            } catch (e) {\n                err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\n            }\n        // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n        // anyhow)\n        };\n        var _emscripten_resize_heap = (requestedSize)=>{\n            var oldSize = HEAPU8.length;\n            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n            requestedSize >>>= 0;\n            // With multithreaded builds, races can happen (another thread might increase the size\n            // in between), so return a failure, and let the caller retry.\n            assert(requestedSize > oldSize);\n            // Memory resize rules:\n            // 1.  Always increase heap size to at least the requested size, rounded up\n            //     to next page multiple.\n            // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n            //     geometrically: increase the heap size according to\n            //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n            //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n            // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n            //     linearly: increase the heap size by at least\n            //     MEMORY_GROWTH_LINEAR_STEP bytes.\n            // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n            //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n            // 4.  If we were unable to allocate as much memory, it may be due to\n            //     over-eager decision to excessively reserve due to (3) above.\n            //     Hence if an allocation fails, cut down on the amount of excess\n            //     growth, in an attempt to succeed to perform a smaller allocation.\n            // A limit is set for how much we can grow. We should not exceed that\n            // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) {\n                err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\n                return false;\n            }\n            var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;\n            // Loop through potential heap size increases. If we attempt a too eager\n            // reservation that fails, cut down on the attempted size and reserve a\n            // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n                // but limit overreserving (default to capping at +96MB overgrowth at most)\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = growMemory(newSize);\n                if (replacement) return true;\n            }\n            err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n            return false;\n        };\n        var ENV = {};\n        var getExecutableName = ()=>{\n            return thisProgram || \"./this.program\";\n        };\n        var getEnvStrings = ()=>{\n            if (!getEnvStrings.strings) {\n                // Default values.\n                // Browser language detection #8751\n                var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n                var env = {\n                    \"USER\": \"web_user\",\n                    \"LOGNAME\": \"web_user\",\n                    \"PATH\": \"/\",\n                    \"PWD\": \"/\",\n                    \"HOME\": \"/home/web_user\",\n                    \"LANG\": lang,\n                    \"_\": getExecutableName()\n                };\n                // Apply the user-provided values, if any.\n                for(var x in ENV)// x is a key in ENV; if ENV[x] is undefined, that means it was\n                // explicitly set to be so. We allow user code to do that to\n                // force variables with default values to remain unset.\n                if (ENV[x] === undefined) delete env[x];\n                else env[x] = ENV[x];\n                var strings = [];\n                for(var x in env)strings.push(`${x}=${env[x]}`);\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        };\n        var stringToAscii = (str, buffer)=>{\n            for(var i = 0; i < str.length; ++i){\n                assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\n                HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n            }\n            // Null-terminate the string\n            HEAP8[buffer >> 0] = 0;\n        };\n        var PATH = {\n            isAbs: (path)=>path.charAt(0) === \"/\",\n            splitPath: (filename)=>{\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot)=>{\n                // if the path tries to go above the root, `up` ends up > 0\n                var up = 0;\n                for(var i = parts.length - 1; i >= 0; i--){\n                    var last = parts[i];\n                    if (last === \".\") parts.splice(i, 1);\n                    else if (last === \"..\") {\n                        parts.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                // if the path is allowed to go above the root, restore leading ..s\n                if (allowAboveRoot) for(; up; up--)parts.unshift(\"..\");\n                return parts;\n            },\n            normalize: (path)=>{\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n                // Normalize the path\n                path = PATH.normalizeArray(path.split(\"/\").filter((p)=>!!p), !isAbsolute).join(\"/\");\n                if (!path && !isAbsolute) path = \".\";\n                if (path && trailingSlash) path += \"/\";\n                return (isAbsolute ? \"/\" : \"\") + path;\n            },\n            dirname: (path)=>{\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) // No dirname whatsoever\n                return \".\";\n                if (dir) // It has a dirname, strip trailing slash\n                dir = dir.substr(0, dir.length - 1);\n                return root + dir;\n            },\n            basename: (path)=>{\n                // EMSCRIPTEN return '/'' for '/', not an empty string\n                if (path === \"/\") return \"/\";\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf(\"/\");\n                if (lastSlash === -1) return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: function() {\n                var paths = Array.prototype.slice.call(arguments);\n                return PATH.normalize(paths.join(\"/\"));\n            },\n            join2: (l, r)=>{\n                return PATH.normalize(l + \"/\" + r);\n            }\n        };\n        var initRandomFill = ()=>{\n            if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") // for modern web browsers\n            return (view)=>crypto.getRandomValues(view);\n            else if (ENVIRONMENT_IS_NODE) // for nodejs with or without crypto support included\n            try {\n                var crypto_module = require1(\"crypto\");\n                var randomFillSync = crypto_module[\"randomFillSync\"];\n                if (randomFillSync) // nodejs with LTS crypto support\n                return (view)=>crypto_module[\"randomFillSync\"](view);\n                // very old nodejs with the original crypto API\n                var randomBytes = crypto_module[\"randomBytes\"];\n                return (view)=>(view.set(randomBytes(view.byteLength)), // Return the original view to match modern native implementations.\n                    view);\n            } catch (e) {\n            // nodejs doesn't have crypto support\n            }\n            // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n            abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n        };\n        var randomFill = (view)=>{\n            // Lazily init on the first invocation.\n            return (randomFill = initRandomFill())(view);\n        };\n        var PATH_FS = {\n            resolve: function() {\n                var resolvedPath = \"\", resolvedAbsolute = false;\n                for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                    var path = i >= 0 ? arguments[i] : FS.cwd();\n                    // Skip empty and invalid entries\n                    if (typeof path != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n                    else if (!path) return \"\"; // an invalid portion invalidates the whole thing\n                    resolvedPath = path + \"/\" + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                // At this point the path should be resolved to a full absolute path, but\n                // handle relative paths to be safe (might happen when process.cwd() fails)\n                resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((p)=>!!p), !resolvedAbsolute).join(\"/\");\n                return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n            },\n            relative: (from, to)=>{\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for(; start < arr.length; start++){\n                        if (arr[start] !== \"\") break;\n                    }\n                    var end = arr.length - 1;\n                    for(; end >= 0; end--){\n                        if (arr[end] !== \"\") break;\n                    }\n                    if (start > end) return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split(\"/\"));\n                var toParts = trim(to.split(\"/\"));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for(var i = 0; i < length; i++)if (fromParts[i] !== toParts[i]) {\n                    samePartsLength = i;\n                    break;\n                }\n                var outputParts = [];\n                for(var i = samePartsLength; i < fromParts.length; i++)outputParts.push(\"..\");\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join(\"/\");\n            }\n        };\n        var FS_stdin_getChar_buffer = [];\n        /** @type {function(string, boolean=, number=)} */ function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull) u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var FS_stdin_getChar = ()=>{\n            if (!FS_stdin_getChar_buffer.length) {\n                var result = null;\n                if (ENVIRONMENT_IS_NODE) {\n                    // we will read data by chunks of BUFSIZE\n                    var BUFSIZE = 256;\n                    var buf = $e6803e952bdec1ea$require$Buffer.alloc(BUFSIZE);\n                    var bytesRead = 0;\n                    // For some reason we must suppress a closure warning here, even though\n                    // fd definitely exists on process.stdin, and is even the proper way to\n                    // get the fd of stdin,\n                    // https://github.com/nodejs/help/issues/2136#issuecomment-523649904\n                    // This started to happen after moving this logic out of library_tty.js,\n                    // so it is related to the surrounding code in some unclear manner.\n                    /** @suppress {missingProperties} */ var fd = $cfae44f0dfdf62c0$exports.stdin.fd;\n                    try {\n                        bytesRead = fs.readSync(fd, buf);\n                    } catch (e) {\n                        // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\n                        // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\n                        if (e.toString().includes(\"EOF\")) bytesRead = 0;\n                        else throw e;\n                    }\n                    if (bytesRead > 0) result = buf.slice(0, bytesRead).toString(\"utf-8\");\n                    else result = null;\n                } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n                    // Browser.\n                    result = window.prompt(\"Input: \"); // returns null on cancel\n                    if (result !== null) result += \"\\n\";\n                } else if (typeof readline == \"function\") {\n                    // Command line.\n                    result = readline();\n                    if (result !== null) result += \"\\n\";\n                }\n                if (!result) return null;\n                FS_stdin_getChar_buffer = intArrayFromString(result, true);\n            }\n            return FS_stdin_getChar_buffer.shift();\n        };\n        var TTY = {\n            ttys: [],\n            init () {\n            // https://github.com/emscripten-core/emscripten/pull/1555\n            // if (ENVIRONMENT_IS_NODE) {\n            //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n            //   // device, it always assumes it's a TTY device. because of this, we're forcing\n            //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n            //   // with text files until FS.init can be refactored.\n            //   process.stdin.setEncoding('utf8');\n            // }\n            },\n            shutdown () {\n            // https://github.com/emscripten-core/emscripten/pull/1555\n            // if (ENVIRONMENT_IS_NODE) {\n            //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n            //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n            //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n            //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n            //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n            //   process.stdin.pause();\n            // }\n            },\n            register (dev, ops) {\n                TTY.ttys[dev] = {\n                    input: [],\n                    output: [],\n                    ops: ops\n                };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open (stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) throw new FS.ErrnoError(43);\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close (stream) {\n                    // flush any pending line data\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read (stream, buffer, offset, length, pos /* ignored */ ) {\n                    if (!stream.tty || !stream.tty.ops.get_char) throw new FS.ErrnoError(60);\n                    var bytesRead = 0;\n                    for(var i = 0; i < length; i++){\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                        if (result === null || result === undefined) break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) stream.node.timestamp = Date.now();\n                    return bytesRead;\n                },\n                write (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) throw new FS.ErrnoError(60);\n                    try {\n                        for(var i = 0; i < length; i++)stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) stream.node.timestamp = Date.now();\n                    return i;\n                }\n            },\n            default_tty_ops: {\n                get_char (tty) {\n                    return FS_stdin_getChar();\n                },\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                },\n                ioctl_tcgets (tty) {\n                    // typical setting\n                    return {\n                        c_iflag: 25856,\n                        c_oflag: 5,\n                        c_cflag: 191,\n                        c_lflag: 35387,\n                        c_cc: [\n                            0x03,\n                            0x1c,\n                            0x7f,\n                            0x15,\n                            0x04,\n                            0x00,\n                            0x01,\n                            0x00,\n                            0x11,\n                            0x13,\n                            0x1a,\n                            0x00,\n                            0x12,\n                            0x0f,\n                            0x17,\n                            0x16,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00,\n                            0x00\n                        ]\n                    };\n                },\n                ioctl_tcsets (tty, optional_actions, data) {\n                    // currently just ignore\n                    return 0;\n                },\n                ioctl_tiocgwinsz (tty) {\n                    return [\n                        24,\n                        80\n                    ];\n                }\n            },\n            default_tty1_ops: {\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val);\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                }\n            }\n        };\n        var mmapAlloc = (size)=>{\n            abort(\"internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported\");\n        };\n        var MEMFS = {\n            ops_table: null,\n            mount (mount) {\n                return MEMFS.createNode(null, \"/\", 16895 /* 0777 */ , 0);\n            },\n            createNode (parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) // no supported\n                throw new FS.ErrnoError(63);\n                if (!MEMFS.ops_table) MEMFS.ops_table = {\n                    dir: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            lookup: MEMFS.node_ops.lookup,\n                            mknod: MEMFS.node_ops.mknod,\n                            rename: MEMFS.node_ops.rename,\n                            unlink: MEMFS.node_ops.unlink,\n                            rmdir: MEMFS.node_ops.rmdir,\n                            readdir: MEMFS.node_ops.readdir,\n                            symlink: MEMFS.node_ops.symlink\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek\n                        }\n                    },\n                    file: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek,\n                            read: MEMFS.stream_ops.read,\n                            write: MEMFS.stream_ops.write,\n                            allocate: MEMFS.stream_ops.allocate,\n                            mmap: MEMFS.stream_ops.mmap,\n                            msync: MEMFS.stream_ops.msync\n                        }\n                    },\n                    link: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            readlink: MEMFS.node_ops.readlink\n                        },\n                        stream: {}\n                    },\n                    chrdev: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: FS.chrdev_stream_ops\n                    }\n                };\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                } else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n                    // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n                    // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n                    // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n                    node.contents = null;\n                } else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                } else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                // add the new node to the parent\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray (node) {\n                if (!node.contents) return new Uint8Array(0);\n                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage (node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n                // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n                // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n                // avoid overshooting the allocation cap by a very large margin.\n                var CAPACITY_DOUBLING_MAX = 1048576;\n                newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125) >>> 0);\n                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n                if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n            },\n            resizeFileStorage (node, newSize) {\n                if (node.usedBytes == newSize) return;\n                if (newSize == 0) {\n                    node.contents = null; // Fully decommit when requesting a resize to zero.\n                    node.usedBytes = 0;\n                } else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize); // Allocate new storage.\n                    if (oldContents) node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr (node) {\n                    var attr = {};\n                    // device numbers reuse inode numbers.\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) attr.size = 4096;\n                    else if (FS.isFile(node.mode)) attr.size = node.usedBytes;\n                    else if (FS.isLink(node.mode)) attr.size = node.link.length;\n                    else attr.size = 0;\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n                    //       but this is not required by the standard.\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr (node, attr) {\n                    if (attr.mode !== undefined) node.mode = attr.mode;\n                    if (attr.timestamp !== undefined) node.timestamp = attr.timestamp;\n                    if (attr.size !== undefined) MEMFS.resizeFileStorage(node, attr.size);\n                },\n                lookup (parent, name) {\n                    throw FS.genericErrors[44];\n                },\n                mknod (parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename (old_node, new_dir, new_name) {\n                    // if we're overwriting a directory at new_name, make sure it's empty.\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        } catch (e) {}\n                        if (new_node) {\n                            for(var i in new_node.contents)throw new FS.ErrnoError(55);\n                        }\n                    }\n                    // do the internal rewiring\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                    old_node.parent = new_dir;\n                },\n                unlink (parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir (parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for(var i in node.contents)throw new FS.ErrnoError(55);\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir (node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for(var key in node.contents){\n                        if (!node.contents.hasOwnProperty(key)) continue;\n                        entries.push(key);\n                    }\n                    return entries;\n                },\n                symlink (parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 41471, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink (node) {\n                    if (!FS.isLink(node.mode)) throw new FS.ErrnoError(28);\n                    return node.link;\n                }\n            },\n            stream_ops: {\n                read (stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes) return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    assert(size >= 0);\n                    if (size > 8 && contents.subarray) buffer.set(contents.subarray(position, position + size), offset);\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    return size;\n                },\n                write (stream, buffer, offset, length, position, canOwn) {\n                    // The data buffer should be a typed array view\n                    assert(!(buffer instanceof ArrayBuffer));\n                    // If the buffer is located in main memory (HEAP), and if\n                    // memory can grow, we can't hold on to references of the\n                    // memory buffer, as they may get invalidated. That means we\n                    // need to do copy its contents.\n                    if (buffer.buffer === HEAP8.buffer) canOwn = false;\n                    if (!length) return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                        if (canOwn) {\n                            assert(position === 0, \"canOwn must imply no weird position inside the file\");\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (node.usedBytes === 0 && position === 0) {\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (position + length <= node.usedBytes) {\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) // Use typed array write which is available.\n                    node.contents.set(buffer.subarray(offset, offset + length), position);\n                    else for(var i = 0; i < length; i++)node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek (stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) position += stream.position;\n                    else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) position += stream.node.usedBytes;\n                    }\n                    if (position < 0) throw new FS.ErrnoError(28);\n                    return position;\n                },\n                allocate (stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap (stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    // Only make a new copy when MAP_PRIVATE is specified.\n                    if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n                        // We can't emulate MAP_SHARED when the file is not backed by the\n                        // buffer we're mapping to (e.g. the HEAP buffer).\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    } else {\n                        // Try to avoid unnecessary slices.\n                        if (position > 0 || position + length < contents.length) {\n                            if (contents.subarray) contents = contents.subarray(position, position + length);\n                            else contents = Array.prototype.slice.call(contents, position, position + length);\n                        }\n                        allocated = true;\n                        ptr = mmapAlloc();\n                        if (!ptr) throw new FS.ErrnoError(48);\n                        HEAP8.set(contents, ptr);\n                    }\n                    return {\n                        ptr: ptr,\n                        allocated: allocated\n                    };\n                },\n                msync (stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    // should we check if bytesWritten and length are the same?\n                    return 0;\n                }\n            }\n        };\n        /** @param {boolean=} noRunDep */ var asyncLoad = (url, onload, onerror, noRunDep)=>{\n            var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : \"\";\n            readAsync(url, (arrayBuffer)=>{\n                assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\n                onload(new Uint8Array(arrayBuffer));\n                if (dep) removeRunDependency(dep);\n            }, (event)=>{\n                if (onerror) onerror();\n                else throw `Loading data file \"${url}\" failed.`;\n            });\n            if (dep) addRunDependency(dep);\n        };\n        var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn)=>{\n            return FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n        };\n        var preloadPlugins = Module[\"preloadPlugins\"] || [];\n        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror)=>{\n            // Ensure plugins are ready.\n            if (typeof Browser != \"undefined\") Browser.init();\n            var handled = false;\n            preloadPlugins.forEach((plugin)=>{\n                if (handled) return;\n                if (plugin[\"canHandle\"](fullname)) {\n                    plugin[\"handle\"](byteArray, fullname, finish, onerror);\n                    handled = true;\n                }\n            });\n            return handled;\n        };\n        var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish)=>{\n            // TODO we should allow people to just pass in a complete filename instead\n            // of parent and name being that we just join them anyways\n            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n            var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\n            function processData(byteArray) {\n                function finish(byteArray) {\n                    if (preFinish) preFinish();\n                    if (!dontCreateFile) FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                    if (onload) onload();\n                    removeRunDependency(dep);\n                }\n                if (FS_handledByPreloadPlugin(byteArray, fullname, finish, ()=>{\n                    if (onerror) onerror();\n                    removeRunDependency(dep);\n                })) return;\n                finish(byteArray);\n            }\n            addRunDependency(dep);\n            if (typeof url == \"string\") asyncLoad(url, (byteArray)=>processData(byteArray), onerror);\n            else processData(url);\n        };\n        var FS_modeStringToFlags = (str)=>{\n            var flagModes = {\n                \"r\": 0,\n                \"r+\": 2,\n                \"w\": 577,\n                \"w+\": 578,\n                \"a\": 1089,\n                \"a+\": 1090\n            };\n            var flags = flagModes[str];\n            if (typeof flags == \"undefined\") throw new Error(`Unknown file open mode: ${str}`);\n            return flags;\n        };\n        var FS_getMode = (canRead, canWrite)=>{\n            var mode = 0;\n            if (canRead) mode |= 365;\n            if (canWrite) mode |= 146;\n            return mode;\n        };\n        var ERRNO_MESSAGES = {\n            0: \"Success\",\n            1: \"Arg list too long\",\n            2: \"Permission denied\",\n            3: \"Address already in use\",\n            4: \"Address not available\",\n            5: \"Address family not supported by protocol family\",\n            6: \"No more processes\",\n            7: \"Socket already connected\",\n            8: \"Bad file number\",\n            9: \"Trying to read unreadable message\",\n            10: \"Mount device busy\",\n            11: \"Operation canceled\",\n            12: \"No children\",\n            13: \"Connection aborted\",\n            14: \"Connection refused\",\n            15: \"Connection reset by peer\",\n            16: \"File locking deadlock error\",\n            17: \"Destination address required\",\n            18: \"Math arg out of domain of func\",\n            19: \"Quota exceeded\",\n            20: \"File exists\",\n            21: \"Bad address\",\n            22: \"File too large\",\n            23: \"Host is unreachable\",\n            24: \"Identifier removed\",\n            25: \"Illegal byte sequence\",\n            26: \"Connection already in progress\",\n            27: \"Interrupted system call\",\n            28: \"Invalid argument\",\n            29: \"I/O error\",\n            30: \"Socket is already connected\",\n            31: \"Is a directory\",\n            32: \"Too many symbolic links\",\n            33: \"Too many open files\",\n            34: \"Too many links\",\n            35: \"Message too long\",\n            36: \"Multihop attempted\",\n            37: \"File or path name too long\",\n            38: \"Network interface is not configured\",\n            39: \"Connection reset by network\",\n            40: \"Network is unreachable\",\n            41: \"Too many open files in system\",\n            42: \"No buffer space available\",\n            43: \"No such device\",\n            44: \"No such file or directory\",\n            45: \"Exec format error\",\n            46: \"No record locks available\",\n            47: \"The link has been severed\",\n            48: \"Not enough core\",\n            49: \"No message of desired type\",\n            50: \"Protocol not available\",\n            51: \"No space left on device\",\n            52: \"Function not implemented\",\n            53: \"Socket is not connected\",\n            54: \"Not a directory\",\n            55: \"Directory not empty\",\n            56: \"State not recoverable\",\n            57: \"Socket operation on non-socket\",\n            59: \"Not a typewriter\",\n            60: \"No such device or address\",\n            61: \"Value too large for defined data type\",\n            62: \"Previous owner died\",\n            63: \"Not super-user\",\n            64: \"Broken pipe\",\n            65: \"Protocol error\",\n            66: \"Unknown protocol\",\n            67: \"Protocol wrong type for socket\",\n            68: \"Math result not representable\",\n            69: \"Read only file system\",\n            70: \"Illegal seek\",\n            71: \"No such process\",\n            72: \"Stale file handle\",\n            73: \"Connection timed out\",\n            74: \"Text file busy\",\n            75: \"Cross-device link\",\n            100: \"Device not a stream\",\n            101: \"Bad font file fmt\",\n            102: \"Invalid slot\",\n            103: \"Invalid request code\",\n            104: \"No anode\",\n            105: \"Block device required\",\n            106: \"Channel number out of range\",\n            107: \"Level 3 halted\",\n            108: \"Level 3 reset\",\n            109: \"Link number out of range\",\n            110: \"Protocol driver not attached\",\n            111: \"No CSI structure available\",\n            112: \"Level 2 halted\",\n            113: \"Invalid exchange\",\n            114: \"Invalid request descriptor\",\n            115: \"Exchange full\",\n            116: \"No data (for no delay io)\",\n            117: \"Timer expired\",\n            118: \"Out of streams resources\",\n            119: \"Machine is not on the network\",\n            120: \"Package not installed\",\n            121: \"The object is remote\",\n            122: \"Advertise error\",\n            123: \"Srmount error\",\n            124: \"Communication error on send\",\n            125: \"Cross mount point (not really error)\",\n            126: \"Given log. name not unique\",\n            127: \"f.d. invalid for this operation\",\n            128: \"Remote address changed\",\n            129: \"Can   access a needed shared lib\",\n            130: \"Accessing a corrupted shared lib\",\n            131: \".lib section in a.out corrupted\",\n            132: \"Attempting to link in too many libs\",\n            133: \"Attempting to exec a shared library\",\n            135: \"Streams pipe error\",\n            136: \"Too many users\",\n            137: \"Socket type not supported\",\n            138: \"Not supported\",\n            139: \"Protocol family not supported\",\n            140: \"Can't send after socket shutdown\",\n            141: \"Too many references\",\n            142: \"Host is down\",\n            148: \"No medium (in tape drive)\",\n            156: \"Level 2 not synchronized\"\n        };\n        var ERRNO_CODES = {};\n        var demangle = (func)=>{\n            warnOnce(\"warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling\");\n            return func;\n        };\n        var demangleAll = (text)=>{\n            var regex = /\\b_Z[\\w\\d_]+/g;\n            return text.replace(regex, function(x) {\n                var y = demangle(x);\n                return x === y ? x : y + \" [\" + x + \"]\";\n            });\n        };\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: null,\n            genericErrors: {},\n            filesystems: null,\n            syncFSRequests: 0,\n            lookupPath (path, opts = {}) {\n                path = PATH_FS.resolve(path);\n                if (!path) return {\n                    path: \"\",\n                    node: null\n                };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) throw new FS.ErrnoError(32);\n                // split the absolute path\n                var parts = path.split(\"/\").filter((p)=>!!p);\n                // start at the root\n                var current = FS.root;\n                var current_path = \"/\";\n                for(var i = 0; i < parts.length; i++){\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) break;\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    // jump to the mount's root node if this is a mountpoint\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) current = current.mounted.root;\n                    }\n                    // by default, lookupPath will not follow a symlink if it is the final path component.\n                    // setting opts.follow = true will override this behavior.\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while(FS.isLink(current.mode)){\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, {\n                                recurse_count: opts.recurse_count + 1\n                            });\n                            current = lookup.node;\n                            if (count++ > 40) throw new FS.ErrnoError(32);\n                        }\n                    }\n                }\n                return {\n                    path: current_path,\n                    node: current\n                };\n            },\n            getPath (node) {\n                var path;\n                while(true){\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path) return mount;\n                        return mount[mount.length - 1] !== \"/\" ? `${mount}/${path}` : mount + path;\n                    }\n                    path = path ? `${node.name}/${path}` : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName (parentid, name) {\n                var hash = 0;\n                for(var i = 0; i < name.length; i++)hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n                return (parentid + hash >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) FS.nameTable[hash] = node.name_next;\n                else {\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode (parent, name) {\n                var errCode = FS.mayLookup(parent);\n                if (errCode) throw new FS.ErrnoError(errCode, parent);\n                var hash = FS.hashName(parent.id, name);\n                for(var node = FS.nameTable[hash]; node; node = node.name_next){\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) return node;\n                }\n                // if we failed to find it in the cache, call into the VFS\n                return FS.lookup(parent, name);\n            },\n            createNode (parent, name, mode, rdev) {\n                assert(typeof parent == \"object\");\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode (node) {\n                FS.hashRemoveNode(node);\n            },\n            isRoot (node) {\n                return node === node.parent;\n            },\n            isMountpoint (node) {\n                return !!node.mounted;\n            },\n            isFile (mode) {\n                return (mode & 61440) === 32768;\n            },\n            isDir (mode) {\n                return (mode & 61440) === 16384;\n            },\n            isLink (mode) {\n                return (mode & 61440) === 40960;\n            },\n            isChrdev (mode) {\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev (mode) {\n                return (mode & 61440) === 24576;\n            },\n            isFIFO (mode) {\n                return (mode & 61440) === 4096;\n            },\n            isSocket (mode) {\n                return (mode & 49152) === 49152;\n            },\n            flagsToPermissionString (flag) {\n                var perms = [\n                    \"r\",\n                    \"w\",\n                    \"rw\"\n                ][flag & 3];\n                if (flag & 512) perms += \"w\";\n                return perms;\n            },\n            nodePermissions (node, perms) {\n                if (FS.ignorePermissions) return 0;\n                // return 0 if any user, group or owner bits are set.\n                if (perms.includes(\"r\") && !(node.mode & 292)) return 2;\n                else if (perms.includes(\"w\") && !(node.mode & 146)) return 2;\n                else if (perms.includes(\"x\") && !(node.mode & 73)) return 2;\n                return 0;\n            },\n            mayLookup (dir) {\n                var errCode = FS.nodePermissions(dir, \"x\");\n                if (errCode) return errCode;\n                if (!dir.node_ops.lookup) return 2;\n                return 0;\n            },\n            mayCreate (dir, name) {\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                } catch (e) {}\n                return FS.nodePermissions(dir, \"wx\");\n            },\n            mayDelete (dir, name, isdir) {\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                } catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, \"wx\");\n                if (errCode) return errCode;\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) return 54;\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) return 10;\n                } else {\n                    if (FS.isDir(node.mode)) return 31;\n                }\n                return 0;\n            },\n            mayOpen (node, flags) {\n                if (!node) return 44;\n                if (FS.isLink(node.mode)) return 32;\n                else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== \"r\" || // opening for write\n                    flags & 512) return 31;\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd () {\n                for(var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++){\n                    if (!FS.streams[fd]) return fd;\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStreamChecked (fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                return stream;\n            },\n            getStream: (fd)=>FS.streams[fd],\n            createStream (stream, fd = -1) {\n                if (!FS.FSStream) {\n                    FS.FSStream = /** @constructor */ function() {\n                        this.shared = {};\n                    };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, {\n                        object: {\n                            /** @this {FS.FSStream} */ get () {\n                                return this.node;\n                            },\n                            /** @this {FS.FSStream} */ set (val) {\n                                this.node = val;\n                            }\n                        },\n                        isRead: {\n                            /** @this {FS.FSStream} */ get () {\n                                return (this.flags & 2097155) !== 1;\n                            }\n                        },\n                        isWrite: {\n                            /** @this {FS.FSStream} */ get () {\n                                return (this.flags & 2097155) !== 0;\n                            }\n                        },\n                        isAppend: {\n                            /** @this {FS.FSStream} */ get () {\n                                return this.flags & 1024;\n                            }\n                        },\n                        flags: {\n                            /** @this {FS.FSStream} */ get () {\n                                return this.shared.flags;\n                            },\n                            /** @this {FS.FSStream} */ set (val) {\n                                this.shared.flags = val;\n                            }\n                        },\n                        position: {\n                            /** @this {FS.FSStream} */ get () {\n                                return this.shared.position;\n                            },\n                            /** @this {FS.FSStream} */ set (val) {\n                                this.shared.position = val;\n                            }\n                        }\n                    });\n                }\n                // clone it, so we can return an instance of FSStream\n                stream = Object.assign(new FS.FSStream(), stream);\n                if (fd == -1) fd = FS.nextfd();\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream (fd) {\n                FS.streams[fd] = null;\n            },\n            chrdev_stream_ops: {\n                open (stream) {\n                    var device = FS.getDevice(stream.node.rdev);\n                    // override node's stream ops with the device's\n                    stream.stream_ops = device.stream_ops;\n                    // forward the open call\n                    if (stream.stream_ops.open) stream.stream_ops.open(stream);\n                },\n                llseek () {\n                    throw new FS.ErrnoError(70);\n                }\n            },\n            major: (dev)=>dev >> 8,\n            minor: (dev)=>dev & 0xff,\n            makedev: (ma, mi)=>ma << 8 | mi,\n            registerDevice (dev, ops) {\n                FS.devices[dev] = {\n                    stream_ops: ops\n                };\n            },\n            getDevice: (dev)=>FS.devices[dev],\n            getMounts (mount) {\n                var mounts = [];\n                var check = [\n                    mount\n                ];\n                while(check.length){\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push.apply(check, m.mounts);\n                }\n                return mounts;\n            },\n            syncfs (populate, callback) {\n                if (typeof populate == \"function\") {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    assert(FS.syncFSRequests > 0);\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) doCallback(null);\n                }\n                // sync all mounts\n                mounts.forEach((mount)=>{\n                    if (!mount.type.syncfs) return done(null);\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount (type, opts, mountpoint) {\n                if (typeof type == \"string\") // The filesystem was not included, and instead we have an error\n                // message stored in the variable.\n                throw type;\n                var root = mountpoint === \"/\";\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) throw new FS.ErrnoError(10);\n                else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, {\n                        follow_mount: false\n                    });\n                    mountpoint = lookup.path; // use the absolute path\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                    if (!FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                }\n                var mount = {\n                    type: type,\n                    opts: opts,\n                    mountpoint: mountpoint,\n                    mounts: []\n                };\n                // create a root node for the fs\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) FS.root = mountRoot;\n                else if (node) {\n                    // set as a mountpoint\n                    node.mounted = mount;\n                    // add the new mount to the current mount's children\n                    if (node.mount) node.mount.mounts.push(mount);\n                }\n                return mountRoot;\n            },\n            unmount (mountpoint) {\n                var lookup = FS.lookupPath(mountpoint, {\n                    follow_mount: false\n                });\n                if (!FS.isMountpoint(lookup.node)) throw new FS.ErrnoError(28);\n                // destroy the nodes for this mount, and all its child mounts\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash)=>{\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) FS.destroyNode(current);\n                        current = next;\n                    }\n                });\n                // no longer a mountpoint\n                node.mounted = null;\n                // remove this mount from the child mounts\n                var idx = node.mount.mounts.indexOf(mount);\n                assert(idx !== -1);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup (parent, name) {\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod (path, mode, dev) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === \".\" || name === \"..\") throw new FS.ErrnoError(28);\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.mknod) throw new FS.ErrnoError(63);\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create (path, mode) {\n                mode = mode !== undefined ? mode : 438 /* 0666 */ ;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir (path, mode) {\n                mode = mode !== undefined ? mode : 511 /* 0777 */ ;\n                mode &= 1023;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree (path, mode) {\n                var dirs = path.split(\"/\");\n                var d = \"\";\n                for(var i = 0; i < dirs.length; ++i){\n                    if (!dirs[i]) continue;\n                    d += \"/\" + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    } catch (e) {\n                        if (e.errno != 20) throw e;\n                    }\n                }\n            },\n            mkdev (path, mode, dev) {\n                if (typeof dev == \"undefined\") {\n                    dev = mode;\n                    mode = 438 /* 0666 */ ;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink (oldpath, newpath) {\n                if (!PATH_FS.resolve(oldpath)) throw new FS.ErrnoError(44);\n                var lookup = FS.lookupPath(newpath, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.symlink) throw new FS.ErrnoError(63);\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename (old_path, new_path) {\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                // parents must exist\n                var lookup, old_dir, new_dir;\n                // let the errors from non existant directories percolate up\n                lookup = FS.lookupPath(old_path, {\n                    parent: true\n                });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, {\n                    parent: true\n                });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n                // need to be part of the same mount\n                if (old_dir.mount !== new_dir.mount) throw new FS.ErrnoError(75);\n                // source must exist\n                var old_node = FS.lookupNode(old_dir, old_name);\n                // old path should not be an ancestor of the new path\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(28);\n                // new path should not be an ancestor of the old path\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(55);\n                // see if the new path already exists\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                } catch (e) {\n                // not fatal\n                }\n                // early out if nothing needs to change\n                if (old_node === new_node) return;\n                // we'll need to delete the old entry\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                // need delete permissions if we'll be overwriting.\n                // need create permissions if new doesn't already exist.\n                errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!old_dir.node_ops.rename) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) throw new FS.ErrnoError(10);\n                // if we are going to change the parent, check write permissions\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, \"w\");\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                // remove the node from the lookup hash\n                FS.hashRemoveNode(old_node);\n                // do the underlying fs rename\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    // add the node back to the hash (in case node_ops.rename\n                    // changed its name)\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.rmdir) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) throw new FS.ErrnoError(54);\n                return node.node_ops.readdir(node);\n            },\n            unlink (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) // According to POSIX, we should map EISDIR to EPERM, but\n                // we instead do what Linux does (and we must, as we use\n                // the musl linux libc).\n                throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.unlink) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink (path) {\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) throw new FS.ErrnoError(44);\n                if (!link.node_ops.readlink) throw new FS.ErrnoError(28);\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat (path, dontFollow) {\n                var lookup = FS.lookupPath(path, {\n                    follow: !dontFollow\n                });\n                var node = lookup.node;\n                if (!node) throw new FS.ErrnoError(44);\n                if (!node.node_ops.getattr) throw new FS.ErrnoError(63);\n                return node.node_ops.getattr(node);\n            },\n            lstat (path) {\n                return FS.stat(path, true);\n            },\n            chmod (path, mode, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    mode: mode & 4095 | node.mode & -4096,\n                    timestamp: Date.now()\n                });\n            },\n            lchmod (path, mode) {\n                FS.chmod(path, mode, true);\n            },\n            fchmod (fd, mode) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chmod(stream.node, mode);\n            },\n            chown (path, uid, gid, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                });\n            },\n            lchown (path, uid, gid) {\n                FS.chown(path, uid, gid, true);\n            },\n            fchown (fd, uid, gid) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate (path, len) {\n                if (len < 0) throw new FS.ErrnoError(28);\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: true\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                if (FS.isDir(node.mode)) throw new FS.ErrnoError(31);\n                if (!FS.isFile(node.mode)) throw new FS.ErrnoError(28);\n                var errCode = FS.nodePermissions(node, \"w\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate (fd, len) {\n                var stream = FS.getStreamChecked(fd);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(28);\n                FS.truncate(stream.node, len);\n            },\n            utime (path, atime, mtime) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open (path, flags, mode) {\n                if (path === \"\") throw new FS.ErrnoError(44);\n                flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n                mode = typeof mode == \"undefined\" ? 438 /* 0666 */  : mode;\n                if (flags & 64) mode = mode & 4095 | 32768;\n                else mode = 0;\n                var node;\n                if (typeof path == \"object\") node = path;\n                else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    } catch (e) {\n                    // ignore\n                    }\n                }\n                // perhaps we need to create the node\n                var created = false;\n                if (flags & 64) {\n                    if (node) {\n                        // if O_CREAT and O_EXCL are set, error out if the node already exists\n                        if (flags & 128) throw new FS.ErrnoError(20);\n                    } else {\n                        // node doesn't exist, try to create it\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) throw new FS.ErrnoError(44);\n                // can't truncate a device\n                if (FS.isChrdev(node.mode)) flags &= -513;\n                // if asked only for a directory, then this must be one\n                if (flags & 65536 && !FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                // check permissions, if this is not a file we just created now (it is ok to\n                // create and write to a file with read-only permissions; it is read-only\n                // for later use)\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                // do truncation if necessary\n                if (flags & 512 && !created) FS.truncate(node, 0);\n                // we've already handled these, don't pass down to the underlying vfs\n                flags &= -131713;\n                // register the stream with the filesystem\n                var stream = FS.createStream({\n                    node: node,\n                    path: FS.getPath(node),\n                    flags: flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n                    ungotten: [],\n                    error: false\n                });\n                // call the new stream's open function\n                if (stream.stream_ops.open) stream.stream_ops.open(stream);\n                if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                    if (!FS.readFiles) FS.readFiles = {};\n                    if (!(path in FS.readFiles)) FS.readFiles[path] = 1;\n                }\n                return stream;\n            },\n            close (stream) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (stream.getdents) stream.getdents = null; // free readdir state\n                try {\n                    if (stream.stream_ops.close) stream.stream_ops.close(stream);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed (stream) {\n                return stream.fd === null;\n            },\n            llseek (stream, offset, whence) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (!stream.seekable || !stream.stream_ops.llseek) throw new FS.ErrnoError(70);\n                if (whence != 0 && whence != 1 && whence != 2) throw new FS.ErrnoError(28);\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read (stream, buffer, offset, length, position) {\n                assert(offset >= 0);\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.read) throw new FS.ErrnoError(28);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking) stream.position += bytesRead;\n                return bytesRead;\n            },\n            write (stream, buffer, offset, length, position, canOwn) {\n                assert(offset >= 0);\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.write) throw new FS.ErrnoError(28);\n                if (stream.seekable && stream.flags & 1024) // seek to the end before writing in append mode\n                FS.llseek(stream, 0, 2);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking) stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate (stream, offset, length) {\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (offset < 0 || length <= 0) throw new FS.ErrnoError(28);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (!stream.stream_ops.allocate) throw new FS.ErrnoError(138);\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap (stream, length, position, prot, flags) {\n                // User requests writing to file (prot & PROT_WRITE != 0).\n                // Checking if we have permissions to write to the file unless\n                // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n                // to write to file opened in read-only mode with MAP_PRIVATE flag,\n                // as all modifications will be visible only in the memory of\n                // the current process.\n                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) throw new FS.ErrnoError(2);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(2);\n                if (!stream.stream_ops.mmap) throw new FS.ErrnoError(43);\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync (stream, buffer, offset, length, mmapFlags) {\n                assert(offset >= 0);\n                if (!stream.stream_ops.msync) return 0;\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            munmap: (stream)=>0,\n            ioctl (stream, cmd, arg) {\n                if (!stream.stream_ops.ioctl) throw new FS.ErrnoError(59);\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile (path, opts = {}) {\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") ret = UTF8ArrayToString(buf, 0);\n                else if (opts.encoding === \"binary\") ret = buf;\n                FS.close(stream);\n                return ret;\n            },\n            writeFile (path, data, opts = {}) {\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                } else if (ArrayBuffer.isView(data)) FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                else throw new Error(\"Unsupported data type\");\n                FS.close(stream);\n            },\n            cwd: ()=>FS.currentPath,\n            chdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                if (lookup.node === null) throw new FS.ErrnoError(44);\n                if (!FS.isDir(lookup.node.mode)) throw new FS.ErrnoError(54);\n                var errCode = FS.nodePermissions(lookup.node, \"x\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories () {\n                FS.mkdir(\"/tmp\");\n                FS.mkdir(\"/home\");\n                FS.mkdir(\"/home/web_user\");\n            },\n            createDefaultDevices () {\n                // create /dev\n                FS.mkdir(\"/dev\");\n                // setup /dev/null\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: ()=>0,\n                    write: (stream, buffer, offset, length, pos)=>length\n                });\n                FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n                // setup /dev/tty and /dev/tty1\n                // stderr needs to print output using err() rather than out()\n                // so we register a second tty just for it.\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n                FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n                // setup /dev/[u]random\n                // use a buffer to avoid overhead of individual crypto calls per byte\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = ()=>{\n                    if (randomLeft === 0) randomLeft = randomFill(randomBuffer).byteLength;\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice(\"/dev\", \"random\", randomByte);\n                FS.createDevice(\"/dev\", \"urandom\", randomByte);\n                // we're not going to emulate the actual shm device,\n                // just create the tmp dirs that reside in it commonly\n                FS.mkdir(\"/dev/shm\");\n                FS.mkdir(\"/dev/shm/tmp\");\n            },\n            createSpecialDirectories () {\n                // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n                // name of the stream for fd 6 (see test_unistd_ttyname)\n                FS.mkdir(\"/proc\");\n                var proc_self = FS.mkdir(\"/proc/self\");\n                FS.mkdir(\"/proc/self/fd\");\n                FS.mount({\n                    mount () {\n                        var node = FS.createNode(proc_self, \"fd\", 16895 /* 0777 */ , 73);\n                        node.node_ops = {\n                            lookup (parent, name) {\n                                var fd = +name;\n                                var stream = FS.getStreamChecked(fd);\n                                var ret = {\n                                    parent: null,\n                                    mount: {\n                                        mountpoint: \"fake\"\n                                    },\n                                    node_ops: {\n                                        readlink: ()=>stream.path\n                                    }\n                                };\n                                ret.parent = ret; // make it look like a simple root node\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, \"/proc/self/fd\");\n            },\n            createStandardStreams () {\n                // TODO deprecate the old functionality of a single\n                // input / output callback and that utilizes FS.createDevice\n                // and instead require a unique set of stream ops\n                // by default, we symlink the standard streams to the\n                // default tty devices. however, if the standard streams\n                // have been overwritten we create a unique device for\n                // them instead.\n                if (Module[\"stdin\"]) FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n                if (Module[\"stdout\"]) FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n                if (Module[\"stderr\"]) FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n                else FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n                // open default streams for the stdin, stdout and stderr devices\n                var stdin = FS.open(\"/dev/stdin\", 0);\n                var stdout = FS.open(\"/dev/stdout\", 1);\n                var stderr = FS.open(\"/dev/stderr\", 1);\n                assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n                assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n                assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n            },\n            ensureErrnoError () {\n                if (FS.ErrnoError) return;\n                FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\n                    // We set the `name` property to be able to identify `FS.ErrnoError`\n                    // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n                    // - when using PROXYFS, an error can come from an underlying FS\n                    // as different FS objects have their own FS.ErrnoError each,\n                    // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n                    // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n                    this.name = \"ErrnoError\";\n                    this.node = node;\n                    this.setErrno = /** @this{Object} */ function(errno) {\n                        this.errno = errno;\n                        for(var key in ERRNO_CODES)if (ERRNO_CODES[key] === errno) {\n                            this.code = key;\n                            break;\n                        }\n                    };\n                    this.setErrno(errno);\n                    this.message = ERRNO_MESSAGES[errno];\n                    // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack\n                    // now ensures it shows what we want.\n                    if (this.stack) {\n                        // Define the stack property for Node.js 4, which otherwise errors on the next line.\n                        Object.defineProperty(this, \"stack\", {\n                            value: (new Error).stack,\n                            writable: true\n                        });\n                        this.stack = demangleAll(this.stack);\n                    }\n                };\n                FS.ErrnoError.prototype = new Error();\n                FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n                // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n                [\n                    44\n                ].forEach((code)=>{\n                    FS.genericErrors[code] = new FS.ErrnoError(code);\n                    FS.genericErrors[code].stack = \"<generic error, no stack>\";\n                });\n            },\n            staticInit () {\n                FS.ensureErrnoError();\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, \"/\");\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    \"MEMFS\": MEMFS\n                };\n            },\n            init (input, output, error) {\n                assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n                FS.init.initialized = true;\n                FS.ensureErrnoError();\n                // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n                Module[\"stdin\"] = input || Module[\"stdin\"];\n                Module[\"stdout\"] = output || Module[\"stdout\"];\n                Module[\"stderr\"] = error || Module[\"stderr\"];\n                FS.createStandardStreams();\n            },\n            quit () {\n                FS.init.initialized = false;\n                // force-flush all streams, so we get musl std streams printed out\n                _fflush(0);\n                // close all of our streams\n                for(var i = 0; i < FS.streams.length; i++){\n                    var stream = FS.streams[i];\n                    if (!stream) continue;\n                    FS.close(stream);\n                }\n            },\n            findObject (path, dontResolveLastLink) {\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) return null;\n                return ret.object;\n            },\n            analyzePath (path, dontResolveLastLink) {\n                // operate from within the context of the symlink's target\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    path = lookup.path;\n                } catch (e) {}\n                var ret = {\n                    isRoot: false,\n                    exists: false,\n                    error: 0,\n                    name: null,\n                    path: null,\n                    object: null,\n                    parentExists: false,\n                    parentPath: null,\n                    parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        parent: true\n                    });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === \"/\";\n                } catch (e) {\n                    ret.error = e.errno;\n                }\n                return ret;\n            },\n            createPath (parent, path, canRead, canWrite) {\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                var parts = path.split(\"/\").reverse();\n                while(parts.length){\n                    var part = parts.pop();\n                    if (!part) continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    } catch (e) {\n                    // ignore EEXIST\n                    }\n                    parent = current;\n                }\n                return current;\n            },\n            createFile (parent, name, properties, canRead, canWrite) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile (parent, name, data, canRead, canWrite, canOwn) {\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS_getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == \"string\") {\n                        var arr = new Array(data.length);\n                        for(var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    // make sure we can write to the file\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n                return node;\n            },\n            createDevice (parent, name, input, output) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(!!input, !!output);\n                if (!FS.createDevice.major) FS.createDevice.major = 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                // Create a fake device that a set of stream ops to emulate\n                // the old behavior.\n                FS.registerDevice(dev, {\n                    open (stream) {\n                        stream.seekable = false;\n                    },\n                    close (stream) {\n                        // flush any pending line data\n                        if (output && output.buffer && output.buffer.length) output(10);\n                    },\n                    read (stream, buffer, offset, length, pos /* ignored */ ) {\n                        var bytesRead = 0;\n                        for(var i = 0; i < length; i++){\n                            var result;\n                            try {\n                                result = input();\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                            if (result === null || result === undefined) break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) stream.node.timestamp = Date.now();\n                        return bytesRead;\n                    },\n                    write (stream, buffer, offset, length, pos) {\n                        for(var i = 0; i < length; i++)try {\n                            output(buffer[offset + i]);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (length) stream.node.timestamp = Date.now();\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile (obj) {\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n                if (typeof XMLHttpRequest != \"undefined\") throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                else if (read_) // Command-line.\n                try {\n                    // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\n                    //          read() will try to parse UTF8.\n                    obj.contents = intArrayFromString(read_(obj.url), true);\n                    obj.usedBytes = obj.contents.length;\n                } catch (e) {\n                    throw new FS.ErrnoError(29);\n                }\n                else throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n            },\n            createLazyFile (parent, name, url, canRead, canWrite) {\n                // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n                /** @constructor */ function LazyUint8Array() {\n                    this.lengthKnown = false;\n                    this.chunks = []; // Loaded chunks. Index is the chunk number\n                }\n                LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\n                    if (idx > this.length - 1 || idx < 0) return undefined;\n                    var chunkOffset = idx % this.chunkSize;\n                    var chunkNum = idx / this.chunkSize | 0;\n                    return this.getter(chunkNum)[chunkOffset];\n                };\n                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n                    this.getter = getter;\n                };\n                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n                    // Find length\n                    var xhr = new XMLHttpRequest();\n                    xhr.open(\"HEAD\", url, false);\n                    xhr.send(null);\n                    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                    var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                    var header;\n                    var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                    var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                    var chunkSize = 1048576; // Chunk size in bytes\n                    if (!hasByteServing) chunkSize = datalength;\n                    // Function to get a range from the remote URL.\n                    var doXHR = (from, to)=>{\n                        if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                        if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                        // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n                        var xhr = new XMLHttpRequest();\n                        xhr.open(\"GET\", url, false);\n                        if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                        // Some hints to the browser that we want binary data.\n                        xhr.responseType = \"arraybuffer\";\n                        if (xhr.overrideMimeType) xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        if (xhr.response !== undefined) return new Uint8Array(/** @type{Array<number>} */ xhr.response || []);\n                        return intArrayFromString(xhr.responseText || \"\", true);\n                    };\n                    var lazyArray = this;\n                    lazyArray.setDataGetter((chunkNum)=>{\n                        var start = chunkNum * chunkSize;\n                        var end = (chunkNum + 1) * chunkSize - 1; // including this byte\n                        end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") lazyArray.chunks[chunkNum] = doXHR(start, end);\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n                        return lazyArray.chunks[chunkNum];\n                    });\n                    if (usesGzip || !datalength) {\n                        // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n                        chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n                        datalength = this.getter(0).length;\n                        chunkSize = datalength;\n                        out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                    }\n                    this._length = datalength;\n                    this._chunkSize = chunkSize;\n                    this.lengthKnown = true;\n                };\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                    var lazyArray = new LazyUint8Array();\n                    Object.defineProperties(lazyArray, {\n                        length: {\n                            get: /** @this{Object} */ function() {\n                                if (!this.lengthKnown) this.cacheLength();\n                                return this._length;\n                            }\n                        },\n                        chunkSize: {\n                            get: /** @this{Object} */ function() {\n                                if (!this.lengthKnown) this.cacheLength();\n                                return this._chunkSize;\n                            }\n                        }\n                    });\n                    var properties = {\n                        isDevice: false,\n                        contents: lazyArray\n                    };\n                } else var properties = {\n                    isDevice: false,\n                    url: url\n                };\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                // This is a total hack, but I want to get this lazy file code out of the\n                // core of MEMFS. If we want to keep this lazy file concept I feel it should\n                // be its own thin LAZYFS proxying calls to MEMFS.\n                if (properties.contents) node.contents = properties.contents;\n                else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                // Add a function that defers querying the file size until it is asked the first time.\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: /** @this {FSNode} */ function() {\n                            return this.contents.length;\n                        }\n                    }\n                });\n                // override each stream op with one that tries to force load the lazy file first\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key)=>{\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = function forceLoadLazyFile() {\n                        FS.forceLoadFile(node);\n                        return fn.apply(null, arguments);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length) return 0;\n                    var size = Math.min(contents.length - position, length);\n                    assert(size >= 0);\n                    if (contents.slice) for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents.get(position + i);\n                    return size;\n                }\n                // use a custom read function\n                stream_ops.read = (stream, buffer, offset, length, position)=>{\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                // use a custom mmap function\n                stream_ops.mmap = (stream, length, position, prot, flags)=>{\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc();\n                    if (!ptr) throw new FS.ErrnoError(48);\n                    writeChunks(stream, HEAP8, ptr, length, position);\n                    return {\n                        ptr: ptr,\n                        allocated: true\n                    };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            },\n            absolutePath () {\n                abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\n            },\n            createFolder () {\n                abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\n            },\n            createLink () {\n                abort(\"FS.createLink has been removed; use FS.symlink instead\");\n            },\n            joinPath () {\n                abort(\"FS.joinPath has been removed; use PATH.join instead\");\n            },\n            mmapAlloc () {\n                abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\n            },\n            standardizePath () {\n                abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\n            }\n        };\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt (dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) return path;\n                // relative path\n                var dir;\n                if (dirfd === -100) dir = FS.cwd();\n                else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) throw new FS.ErrnoError(44);\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat (func, path, buf) {\n                try {\n                    var stat = func(path);\n                } catch (e) {\n                    if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) // an error occurred while trying to look up the path; we should just report ENOTDIR\n                    return -54;\n                    throw e;\n                }\n                HEAP32[buf >> 2] = stat.dev;\n                HEAP32[buf + 4 >> 2] = stat.mode;\n                HEAPU32[buf + 8 >> 2] = stat.nlink;\n                HEAP32[buf + 12 >> 2] = stat.uid;\n                HEAP32[buf + 16 >> 2] = stat.gid;\n                HEAP32[buf + 20 >> 2] = stat.rdev;\n                tempI64 = [\n                    stat.size >>> 0,\n                    (tempDouble = stat.size, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n                HEAP32[buf + 32 >> 2] = 4096;\n                HEAP32[buf + 36 >> 2] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                tempI64 = [\n                    Math.floor(atime / 1000) >>> 0,\n                    (tempDouble = Math.floor(atime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n                HEAPU32[buf + 48 >> 2] = atime % 1000 * 1000;\n                tempI64 = [\n                    Math.floor(mtime / 1000) >>> 0,\n                    (tempDouble = Math.floor(mtime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n                HEAPU32[buf + 64 >> 2] = mtime % 1000 * 1000;\n                tempI64 = [\n                    Math.floor(ctime / 1000) >>> 0,\n                    (tempDouble = Math.floor(ctime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n                HEAPU32[buf + 80 >> 2] = ctime % 1000 * 1000;\n                tempI64 = [\n                    stat.ino >>> 0,\n                    (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n                return 0;\n            },\n            doMsync (addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (flags & 2) // MAP_PRIVATE calls need not to be synced back to underlying fs\n                return 0;\n                var buffer = HEAPU8.slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            varargs: undefined,\n            get () {\n                assert(SYSCALLS.varargs != undefined);\n                // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\n                var ret = HEAP32[+SYSCALLS.varargs >> 2];\n                SYSCALLS.varargs += 4;\n                return ret;\n            },\n            getp () {\n                return SYSCALLS.get();\n            },\n            getStr (ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            },\n            getStreamFromFD (fd) {\n                var stream = FS.getStreamChecked(fd);\n                return stream;\n            }\n        };\n        var _environ_get = (__environ, environ_buf)=>{\n            var bufSize = 0;\n            getEnvStrings().forEach((string, i)=>{\n                var ptr = environ_buf + bufSize;\n                HEAPU32[__environ + i * 4 >> 2] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        };\n        var _environ_sizes_get = (penviron_count, penviron_buf_size)=>{\n            var strings = getEnvStrings();\n            HEAPU32[penviron_count >> 2] = strings.length;\n            var bufSize = 0;\n            strings.forEach((string)=>bufSize += string.length + 1);\n            HEAPU32[penviron_buf_size >> 2] = bufSize;\n            return 0;\n        };\n        var runtimeKeepaliveCounter = 0;\n        var keepRuntimeAlive = ()=>noExitRuntime || runtimeKeepaliveCounter > 0;\n        var _proc_exit = (code)=>{\n            EXITSTATUS = code;\n            if (!keepRuntimeAlive()) {\n                if (Module[\"onExit\"]) Module[\"onExit\"](code);\n                ABORT = true;\n            }\n            quit_(code, new ExitStatus(code));\n        };\n        /** @suppress {duplicate } */ /** @param {boolean|number=} implicit */ var exitJS = (status, implicit)=>{\n            EXITSTATUS = status;\n            checkUnflushedContent();\n            // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\n            if (keepRuntimeAlive() && !implicit) {\n                var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\n                readyPromiseReject(msg);\n                err(msg);\n            }\n            _proc_exit(status);\n        };\n        var _exit = exitJS;\n        function _fd_close(fd) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        /** @param {number=} offset */ var doReadv = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.read(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break; // nothing more to read\n                if (typeof offset !== \"undefined\") offset += curr;\n            }\n            return ret;\n        };\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var convertI32PairToI53Checked = (lo, hi)=>{\n            assert(lo == lo >>> 0 || lo == (lo | 0)); // lo should either be a i32 or a u32\n            assert(hi === (hi | 0)); // hi should be a i32\n            return hi + 0x200000 >>> 0 < 0x400001 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n        };\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            try {\n                if (isNaN(offset)) return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                tempI64 = [\n                    stream.position >>> 0,\n                    (tempDouble = stream.position, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)\n                ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        /** @param {number=} offset */ var doWritev = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.write(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (typeof offset !== \"undefined\") offset += curr;\n            }\n            return ret;\n        };\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var isLeapYear = (year)=>{\n            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        };\n        var arraySum = (array, index)=>{\n            var sum = 0;\n            for(var i = 0; i <= index; sum += array[i++]);\n            return sum;\n        };\n        var MONTH_DAYS_LEAP = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var MONTH_DAYS_REGULAR = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var addDays = (date, days)=>{\n            var newDate = new Date(date.getTime());\n            while(days > 0){\n                var leap = isLeapYear(newDate.getFullYear());\n                var currentMonth = newDate.getMonth();\n                var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n                if (days > daysInCurrentMonth - newDate.getDate()) {\n                    // we spill over to next month\n                    days -= daysInCurrentMonth - newDate.getDate() + 1;\n                    newDate.setDate(1);\n                    if (currentMonth < 11) newDate.setMonth(currentMonth + 1);\n                    else {\n                        newDate.setMonth(0);\n                        newDate.setFullYear(newDate.getFullYear() + 1);\n                    }\n                } else {\n                    // we stay in current month\n                    newDate.setDate(newDate.getDate() + days);\n                    return newDate;\n                }\n            }\n            return newDate;\n        };\n        var writeArrayToMemory = (array, buffer)=>{\n            assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n            HEAP8.set(array, buffer);\n        };\n        var _strftime = (s, maxsize, format, tm)=>{\n            // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\n            // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\n            var tm_zone = HEAPU32[tm + 40 >> 2];\n            var date = {\n                tm_sec: HEAP32[tm >> 2],\n                tm_min: HEAP32[tm + 4 >> 2],\n                tm_hour: HEAP32[tm + 8 >> 2],\n                tm_mday: HEAP32[tm + 12 >> 2],\n                tm_mon: HEAP32[tm + 16 >> 2],\n                tm_year: HEAP32[tm + 20 >> 2],\n                tm_wday: HEAP32[tm + 24 >> 2],\n                tm_yday: HEAP32[tm + 28 >> 2],\n                tm_isdst: HEAP32[tm + 32 >> 2],\n                tm_gmtoff: HEAP32[tm + 36 >> 2],\n                tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n            };\n            var pattern = UTF8ToString(format);\n            // expand format\n            var EXPANSION_RULES_1 = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                // Modified Conversion Specifiers\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            };\n            for(var rule in EXPANSION_RULES_1)pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n            var WEEKDAYS = [\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\"\n            ];\n            var MONTHS = [\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\"\n            ];\n            function leadingSomething(value, digits, character) {\n                var str = typeof value == \"number\" ? value.toString() : value || \"\";\n                while(str.length < digits)str = character[0] + str;\n                return str;\n            }\n            function leadingNulls(value, digits) {\n                return leadingSomething(value, digits, \"0\");\n            }\n            function compareByDay(date1, date2) {\n                function sgn(value) {\n                    return value < 0 ? -1 : value > 0 ? 1 : 0;\n                }\n                var compare;\n                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) compare = sgn(date1.getDate() - date2.getDate());\n                }\n                return compare;\n            }\n            function getFirstWeekStartDate(janFourth) {\n                switch(janFourth.getDay()){\n                    case 0:\n                        return new Date(janFourth.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return janFourth;\n                    case 2:\n                        return new Date(janFourth.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(janFourth.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(janFourth.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(janFourth.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(janFourth.getFullYear() - 1, 11, 30);\n                }\n            }\n            function getWeekBasedYear(date) {\n                var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n                    // this date is after the start of the first week of this year\n                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) return thisDate.getFullYear() + 1;\n                    return thisDate.getFullYear();\n                }\n                return thisDate.getFullYear() - 1;\n            }\n            var EXPANSION_RULES_2 = {\n                \"%a\": (date)=>WEEKDAYS[date.tm_wday].substring(0, 3),\n                \"%A\": (date)=>WEEKDAYS[date.tm_wday],\n                \"%b\": (date)=>MONTHS[date.tm_mon].substring(0, 3),\n                \"%B\": (date)=>MONTHS[date.tm_mon],\n                \"%C\": (date)=>{\n                    var year = date.tm_year + 1900;\n                    return leadingNulls(year / 100 | 0, 2);\n                },\n                \"%d\": (date)=>leadingNulls(date.tm_mday, 2),\n                \"%e\": (date)=>leadingSomething(date.tm_mday, 2, \" \"),\n                \"%g\": (date)=>{\n                    // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\n                    // In this system, weeks begin on a Monday and week 1 of the year is the week that includes\n                    // January 4th, which is also the week that includes the first Thursday of the year, and\n                    // is also the first week that contains at least four days in the year.\n                    // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\n                    // the last week of the preceding year; thus, for Saturday 2nd January 1999,\n                    // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\n                    // or 31st is a Monday, it and any following days are part of week 1 of the following year.\n                    // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\n                    return getWeekBasedYear(date).toString().substring(2);\n                },\n                \"%G\": (date)=>getWeekBasedYear(date),\n                \"%H\": (date)=>leadingNulls(date.tm_hour, 2),\n                \"%I\": (date)=>{\n                    var twelveHour = date.tm_hour;\n                    if (twelveHour == 0) twelveHour = 12;\n                    else if (twelveHour > 12) twelveHour -= 12;\n                    return leadingNulls(twelveHour, 2);\n                },\n                \"%j\": (date)=>{\n                    // Day of the year (001-366)\n                    return leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n                },\n                \"%m\": (date)=>leadingNulls(date.tm_mon + 1, 2),\n                \"%M\": (date)=>leadingNulls(date.tm_min, 2),\n                \"%n\": ()=>\"\\n\",\n                \"%p\": (date)=>{\n                    if (date.tm_hour >= 0 && date.tm_hour < 12) return \"AM\";\n                    return \"PM\";\n                },\n                \"%S\": (date)=>leadingNulls(date.tm_sec, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (date)=>date.tm_wday || 7,\n                \"%U\": (date)=>{\n                    var days = date.tm_yday + 7 - date.tm_wday;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%V\": (date)=>{\n                    // Replaced by the week number of the year (Monday as the first day of the week)\n                    // as a decimal number [01,53]. If the week containing 1 January has four\n                    // or more days in the new year, then it is considered week 1.\n                    // Otherwise, it is the last week of the previous year, and the next week is week 1.\n                    // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\n                    var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n                    // If 1 Jan is just 1-3 days past Monday, the previous week\n                    // is also in this year.\n                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) val++;\n                    if (!val) {\n                        val = 52;\n                        // If 31 December of prev year a Thursday, or Friday of a\n                        // leap year, then the prev year has 53 weeks.\n                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n                        if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) val++;\n                    } else if (val == 53) {\n                        // If 1 January is not a Thursday, and not a Wednesday of a\n                        // leap year, then this year has only 52 weeks.\n                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n                        if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n                    }\n                    return leadingNulls(val, 2);\n                },\n                \"%w\": (date)=>date.tm_wday,\n                \"%W\": (date)=>{\n                    var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%y\": (date)=>{\n                    // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\n                    return (date.tm_year + 1900).toString().substring(2);\n                },\n                // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\n                \"%Y\": (date)=>date.tm_year + 1900,\n                \"%z\": (date)=>{\n                    // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\n                    // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\n                    var off = date.tm_gmtoff;\n                    var ahead = off >= 0;\n                    off = Math.abs(off) / 60;\n                    // convert from minutes into hhmm format (which means 60 minutes = 100 units)\n                    off = off / 60 * 100 + off % 60;\n                    return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n                },\n                \"%Z\": (date)=>date.tm_zone,\n                \"%%\": ()=>\"%\"\n            };\n            // Replace %% with a pair of NULLs (which cannot occur in a C string), then\n            // re-inject them after processing.\n            pattern = pattern.replace(/%%/g, \"\\0\\0\");\n            for(var rule in EXPANSION_RULES_2)if (pattern.includes(rule)) pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n            pattern = pattern.replace(/\\0\\0/g, \"%\");\n            var bytes = intArrayFromString(pattern, false);\n            if (bytes.length > maxsize) return 0;\n            writeArrayToMemory(bytes, s);\n            return bytes.length - 1;\n        };\n        var _strftime_l = (s, maxsize, format, tm, loc)=>{\n            return _strftime(s, maxsize, format, tm); // no locale support yet\n        };\n        var handleException = (e)=>{\n            // Certain exception types we do not treat as errors since they are used for\n            // internal control flow.\n            // 1. ExitStatus, which is thrown by exit()\n            // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n            //    that wish to return to JS event loop.\n            if (e instanceof ExitStatus || e == \"unwind\") return EXITSTATUS;\n            checkStackCookie();\n            if (e instanceof WebAssembly.RuntimeError) {\n                if (_emscripten_stack_get_current() <= 0) err(\"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)\");\n            }\n            quit_(1, e);\n        };\n        InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"InternalError\";\n            }\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"BindingError\";\n            }\n        };\n        handleAllocatorInit();\n        init_emval();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        var FSNode = /** @constructor */ function(parent, name, mode, rdev) {\n            if (!parent) parent = this; // root node sets parent to itself\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n        var readMode = 365 /*73*/ ;\n        var writeMode = 146 /*146*/ ;\n        Object.defineProperties(FSNode.prototype, {\n            read: {\n                get: /** @this{FSNode} */ function() {\n                    return (this.mode & readMode) === readMode;\n                },\n                set: /** @this{FSNode} */ function(val) {\n                    val ? this.mode |= readMode : this.mode &= ~readMode;\n                }\n            },\n            write: {\n                get: /** @this{FSNode} */ function() {\n                    return (this.mode & writeMode) === writeMode;\n                },\n                set: /** @this{FSNode} */ function(val) {\n                    val ? this.mode |= writeMode : this.mode &= ~writeMode;\n                }\n            },\n            isFolder: {\n                get: /** @this{FSNode} */ function() {\n                    return FS.isDir(this.mode);\n                }\n            },\n            isDevice: {\n                get: /** @this{FSNode} */ function() {\n                    return FS.isChrdev(this.mode);\n                }\n            }\n        });\n        FS.FSNode = FSNode;\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        ERRNO_CODES = {\n            \"EPERM\": 63,\n            \"ENOENT\": 44,\n            \"ESRCH\": 71,\n            \"EINTR\": 27,\n            \"EIO\": 29,\n            \"ENXIO\": 60,\n            \"E2BIG\": 1,\n            \"ENOEXEC\": 45,\n            \"EBADF\": 8,\n            \"ECHILD\": 12,\n            \"EAGAIN\": 6,\n            \"EWOULDBLOCK\": 6,\n            \"ENOMEM\": 48,\n            \"EACCES\": 2,\n            \"EFAULT\": 21,\n            \"ENOTBLK\": 105,\n            \"EBUSY\": 10,\n            \"EEXIST\": 20,\n            \"EXDEV\": 75,\n            \"ENODEV\": 43,\n            \"ENOTDIR\": 54,\n            \"EISDIR\": 31,\n            \"EINVAL\": 28,\n            \"ENFILE\": 41,\n            \"EMFILE\": 33,\n            \"ENOTTY\": 59,\n            \"ETXTBSY\": 74,\n            \"EFBIG\": 22,\n            \"ENOSPC\": 51,\n            \"ESPIPE\": 70,\n            \"EROFS\": 69,\n            \"EMLINK\": 34,\n            \"EPIPE\": 64,\n            \"EDOM\": 18,\n            \"ERANGE\": 68,\n            \"ENOMSG\": 49,\n            \"EIDRM\": 24,\n            \"ECHRNG\": 106,\n            \"EL2NSYNC\": 156,\n            \"EL3HLT\": 107,\n            \"EL3RST\": 108,\n            \"ELNRNG\": 109,\n            \"EUNATCH\": 110,\n            \"ENOCSI\": 111,\n            \"EL2HLT\": 112,\n            \"EDEADLK\": 16,\n            \"ENOLCK\": 46,\n            \"EBADE\": 113,\n            \"EBADR\": 114,\n            \"EXFULL\": 115,\n            \"ENOANO\": 104,\n            \"EBADRQC\": 103,\n            \"EBADSLT\": 102,\n            \"EDEADLOCK\": 16,\n            \"EBFONT\": 101,\n            \"ENOSTR\": 100,\n            \"ENODATA\": 116,\n            \"ETIME\": 117,\n            \"ENOSR\": 118,\n            \"ENONET\": 119,\n            \"ENOPKG\": 120,\n            \"EREMOTE\": 121,\n            \"ENOLINK\": 47,\n            \"EADV\": 122,\n            \"ESRMNT\": 123,\n            \"ECOMM\": 124,\n            \"EPROTO\": 65,\n            \"EMULTIHOP\": 36,\n            \"EDOTDOT\": 125,\n            \"EBADMSG\": 9,\n            \"ENOTUNIQ\": 126,\n            \"EBADFD\": 127,\n            \"EREMCHG\": 128,\n            \"ELIBACC\": 129,\n            \"ELIBBAD\": 130,\n            \"ELIBSCN\": 131,\n            \"ELIBMAX\": 132,\n            \"ELIBEXEC\": 133,\n            \"ENOSYS\": 52,\n            \"ENOTEMPTY\": 55,\n            \"ENAMETOOLONG\": 37,\n            \"ELOOP\": 32,\n            \"EOPNOTSUPP\": 138,\n            \"EPFNOSUPPORT\": 139,\n            \"ECONNRESET\": 15,\n            \"ENOBUFS\": 42,\n            \"EAFNOSUPPORT\": 5,\n            \"EPROTOTYPE\": 67,\n            \"ENOTSOCK\": 57,\n            \"ENOPROTOOPT\": 50,\n            \"ESHUTDOWN\": 140,\n            \"ECONNREFUSED\": 14,\n            \"EADDRINUSE\": 3,\n            \"ECONNABORTED\": 13,\n            \"ENETUNREACH\": 40,\n            \"ENETDOWN\": 38,\n            \"ETIMEDOUT\": 73,\n            \"EHOSTDOWN\": 142,\n            \"EHOSTUNREACH\": 23,\n            \"EINPROGRESS\": 26,\n            \"EALREADY\": 7,\n            \"EDESTADDRREQ\": 17,\n            \"EMSGSIZE\": 35,\n            \"EPROTONOSUPPORT\": 66,\n            \"ESOCKTNOSUPPORT\": 137,\n            \"EADDRNOTAVAIL\": 4,\n            \"ENETRESET\": 39,\n            \"EISCONN\": 30,\n            \"ENOTCONN\": 53,\n            \"ETOOMANYREFS\": 141,\n            \"EUSERS\": 136,\n            \"EDQUOT\": 19,\n            \"ESTALE\": 72,\n            \"ENOTSUP\": 138,\n            \"ENOMEDIUM\": 148,\n            \"EILSEQ\": 25,\n            \"EOVERFLOW\": 61,\n            \"ECANCELED\": 11,\n            \"ENOTRECOVERABLE\": 56,\n            \"EOWNERDEAD\": 62,\n            \"ESTRPIPE\": 135\n        };\n        function checkIncomingModuleAPI() {\n            ignoredModuleProp(\"fetchSettings\");\n        }\n        var wasmImports = {\n            /** @export */ __cxa_throw: ___cxa_throw,\n            /** @export */ _embind_finalize_value_object: __embind_finalize_value_object,\n            /** @export */ _embind_register_bigint: __embind_register_bigint,\n            /** @export */ _embind_register_bool: __embind_register_bool,\n            /** @export */ _embind_register_emval: __embind_register_emval,\n            /** @export */ _embind_register_float: __embind_register_float,\n            /** @export */ _embind_register_function: __embind_register_function,\n            /** @export */ _embind_register_integer: __embind_register_integer,\n            /** @export */ _embind_register_memory_view: __embind_register_memory_view,\n            /** @export */ _embind_register_std_string: __embind_register_std_string,\n            /** @export */ _embind_register_std_wstring: __embind_register_std_wstring,\n            /** @export */ _embind_register_value_object: __embind_register_value_object,\n            /** @export */ _embind_register_value_object_field: __embind_register_value_object_field,\n            /** @export */ _embind_register_void: __embind_register_void,\n            /** @export */ _emscripten_throw_longjmp: __emscripten_throw_longjmp,\n            /** @export */ _emval_decref: __emval_decref,\n            /** @export */ _emval_incref: __emval_incref,\n            /** @export */ _emval_new_cstring: __emval_new_cstring,\n            /** @export */ _emval_take_value: __emval_take_value,\n            /** @export */ abort: _abort,\n            /** @export */ emscripten_memcpy_js: _emscripten_memcpy_js,\n            /** @export */ emscripten_resize_heap: _emscripten_resize_heap,\n            /** @export */ environ_get: _environ_get,\n            /** @export */ environ_sizes_get: _environ_sizes_get,\n            /** @export */ exit: _exit,\n            /** @export */ fd_close: _fd_close,\n            /** @export */ fd_read: _fd_read,\n            /** @export */ fd_seek: _fd_seek,\n            /** @export */ fd_write: _fd_write,\n            /** @export */ invoke_ii: invoke_ii,\n            /** @export */ invoke_iii: invoke_iii,\n            /** @export */ invoke_iiii: invoke_iiii,\n            /** @export */ invoke_iiiii: invoke_iiiii,\n            /** @export */ invoke_vi: invoke_vi,\n            /** @export */ invoke_viii: invoke_viii,\n            /** @export */ strftime_l: _strftime_l\n        };\n        var wasmExports = createWasm();\n        var _malloc = createExportWrapper(\"malloc\");\n        var _main = Module[\"_main\"] = createExportWrapper(\"main\");\n        var _free = createExportWrapper(\"free\");\n        var ___getTypeName = createExportWrapper(\"__getTypeName\");\n        Module[\"__embind_initialize_bindings\"] = createExportWrapper(\"_embind_initialize_bindings\");\n        var _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n        var _setThrew = createExportWrapper(\"setThrew\");\n        var _emscripten_stack_init = ()=>(_emscripten_stack_init = wasmExports[\"emscripten_stack_init\"])();\n        var _emscripten_stack_get_end = ()=>(_emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"])();\n        var stackSave = createExportWrapper(\"stackSave\");\n        var stackRestore = createExportWrapper(\"stackRestore\");\n        var _emscripten_stack_get_current = ()=>(_emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"])();\n        var ___cxa_is_pointer_type = createExportWrapper(\"__cxa_is_pointer_type\");\n        Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\n        Module[\"dynCall_viijii\"] = createExportWrapper(\"dynCall_viijii\");\n        Module[\"dynCall_iiiiij\"] = createExportWrapper(\"dynCall_iiiiij\");\n        Module[\"dynCall_iiiiijj\"] = createExportWrapper(\"dynCall_iiiiijj\");\n        Module[\"dynCall_iiiiiijj\"] = createExportWrapper(\"dynCall_iiiiiijj\");\n        function invoke_ii(index, a1) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_vi(index, a1) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_viii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                getWasmTableEntry(index)(a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiii(index, a1, a2, a3) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iii(index, a1, a2) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        function invoke_iiiii(index, a1, a2, a3, a4) {\n            var sp = stackSave();\n            try {\n                return getWasmTableEntry(index)(a1, a2, a3, a4);\n            } catch (e) {\n                stackRestore(sp);\n                if (e !== e + 0) throw e;\n                _setThrew(1, 0);\n            }\n        }\n        // include: postamble.js\n        // === Auto-generated postamble setup entry stuff ===\n        var missingLibrarySymbols = [\n            \"writeI53ToI64\",\n            \"writeI53ToI64Clamped\",\n            \"writeI53ToI64Signaling\",\n            \"writeI53ToU64Clamped\",\n            \"writeI53ToU64Signaling\",\n            \"readI53FromI64\",\n            \"readI53FromU64\",\n            \"convertI32PairToI53\",\n            \"convertU32PairToI53\",\n            \"ydayFromDate\",\n            \"setErrNo\",\n            \"inetPton4\",\n            \"inetNtop4\",\n            \"inetPton6\",\n            \"inetNtop6\",\n            \"readSockaddr\",\n            \"writeSockaddr\",\n            \"getHostByName\",\n            \"getCallstack\",\n            \"emscriptenLog\",\n            \"convertPCtoSourceLocation\",\n            \"readEmAsmArgs\",\n            \"jstoi_q\",\n            \"jstoi_s\",\n            \"listenOnce\",\n            \"autoResumeAudioContext\",\n            \"runtimeKeepalivePush\",\n            \"runtimeKeepalivePop\",\n            \"callUserCallback\",\n            \"maybeExit\",\n            \"asmjsMangle\",\n            \"getNativeTypeSize\",\n            \"STACK_SIZE\",\n            \"STACK_ALIGN\",\n            \"POINTER_SIZE\",\n            \"ASSERTIONS\",\n            \"getCFunc\",\n            \"ccall\",\n            \"cwrap\",\n            \"uleb128Encode\",\n            \"sigToWasmTypes\",\n            \"generateFuncType\",\n            \"convertJsFunctionToWasm\",\n            \"getEmptyTableSlot\",\n            \"updateTableMap\",\n            \"getFunctionAddress\",\n            \"addFunction\",\n            \"removeFunction\",\n            \"reallyNegative\",\n            \"unSign\",\n            \"strLen\",\n            \"reSign\",\n            \"formatString\",\n            \"intArrayToString\",\n            \"AsciiToString\",\n            \"stringToNewUTF8\",\n            \"stringToUTF8OnStack\",\n            \"registerKeyEventCallback\",\n            \"maybeCStringToJsString\",\n            \"findEventTarget\",\n            \"findCanvasEventTarget\",\n            \"getBoundingClientRect\",\n            \"fillMouseEventData\",\n            \"registerMouseEventCallback\",\n            \"registerWheelEventCallback\",\n            \"registerUiEventCallback\",\n            \"registerFocusEventCallback\",\n            \"fillDeviceOrientationEventData\",\n            \"registerDeviceOrientationEventCallback\",\n            \"fillDeviceMotionEventData\",\n            \"registerDeviceMotionEventCallback\",\n            \"screenOrientation\",\n            \"fillOrientationChangeEventData\",\n            \"registerOrientationChangeEventCallback\",\n            \"fillFullscreenChangeEventData\",\n            \"registerFullscreenChangeEventCallback\",\n            \"JSEvents_requestFullscreen\",\n            \"JSEvents_resizeCanvasForFullscreen\",\n            \"registerRestoreOldStyle\",\n            \"hideEverythingExceptGivenElement\",\n            \"restoreHiddenElements\",\n            \"setLetterbox\",\n            \"softFullscreenResizeWebGLRenderTarget\",\n            \"doRequestFullscreen\",\n            \"fillPointerlockChangeEventData\",\n            \"registerPointerlockChangeEventCallback\",\n            \"registerPointerlockErrorEventCallback\",\n            \"requestPointerLock\",\n            \"fillVisibilityChangeEventData\",\n            \"registerVisibilityChangeEventCallback\",\n            \"registerTouchEventCallback\",\n            \"fillGamepadEventData\",\n            \"registerGamepadEventCallback\",\n            \"registerBeforeUnloadEventCallback\",\n            \"fillBatteryEventData\",\n            \"battery\",\n            \"registerBatteryEventCallback\",\n            \"setCanvasElementSize\",\n            \"getCanvasElementSize\",\n            \"jsStackTrace\",\n            \"stackTrace\",\n            \"checkWasiClock\",\n            \"wasiRightsToMuslOFlags\",\n            \"wasiOFlagsToMuslOFlags\",\n            \"createDyncallWrapper\",\n            \"safeSetTimeout\",\n            \"setImmediateWrapped\",\n            \"clearImmediateWrapped\",\n            \"polyfillSetImmediate\",\n            \"getPromise\",\n            \"makePromise\",\n            \"idsToPromises\",\n            \"makePromiseCallback\",\n            \"findMatchingCatch\",\n            \"setMainLoop\",\n            \"getSocketFromFD\",\n            \"getSocketAddress\",\n            \"FS_unlink\",\n            \"FS_mkdirTree\",\n            \"_setNetworkCallback\",\n            \"heapObjectForWebGLType\",\n            \"heapAccessShiftForWebGLHeap\",\n            \"webgl_enable_ANGLE_instanced_arrays\",\n            \"webgl_enable_OES_vertex_array_object\",\n            \"webgl_enable_WEBGL_draw_buffers\",\n            \"webgl_enable_WEBGL_multi_draw\",\n            \"emscriptenWebGLGet\",\n            \"computeUnpackAlignedImageSize\",\n            \"colorChannelsInGlTextureFormat\",\n            \"emscriptenWebGLGetTexPixelData\",\n            \"__glGenObject\",\n            \"emscriptenWebGLGetUniform\",\n            \"webglGetUniformLocation\",\n            \"webglPrepareUniformLocationsBeforeFirstUse\",\n            \"webglGetLeftBracePos\",\n            \"emscriptenWebGLGetVertexAttrib\",\n            \"__glGetActiveAttribOrUniform\",\n            \"writeGLArray\",\n            \"registerWebGlEventCallback\",\n            \"runAndAbortIfError\",\n            \"SDL_unicode\",\n            \"SDL_ttfContext\",\n            \"SDL_audio\",\n            \"ALLOC_NORMAL\",\n            \"ALLOC_STACK\",\n            \"allocate\",\n            \"writeStringToMemory\",\n            \"writeAsciiToMemory\",\n            \"getFunctionArgsName\",\n            \"init_embind\",\n            \"getBasestPointer\",\n            \"registerInheritedInstance\",\n            \"unregisterInheritedInstance\",\n            \"getInheritedInstance\",\n            \"getInheritedInstanceCount\",\n            \"getLiveInheritedInstances\",\n            \"enumReadValueFromPointer\",\n            \"genericPointerToWireType\",\n            \"constNoSmartPtrRawPointerToWireType\",\n            \"nonConstNoSmartPtrRawPointerToWireType\",\n            \"init_RegisteredPointer\",\n            \"RegisteredPointer\",\n            \"RegisteredPointer_fromWireType\",\n            \"runDestructor\",\n            \"releaseClassHandle\",\n            \"detachFinalizer\",\n            \"attachFinalizer\",\n            \"makeClassHandle\",\n            \"init_ClassHandle\",\n            \"ClassHandle\",\n            \"throwInstanceAlreadyDeleted\",\n            \"flushPendingDeletes\",\n            \"setDelayFunction\",\n            \"RegisteredClass\",\n            \"shallowCopyInternalPointer\",\n            \"downcastPointer\",\n            \"upcastPointer\",\n            \"validateThis\",\n            \"craftEmvalAllocator\",\n            \"emval_get_global\",\n            \"emval_lookupTypes\",\n            \"emval_addMethodCaller\"\n        ];\n        missingLibrarySymbols.forEach(missingLibrarySymbol);\n        var unexportedSymbols = [\n            \"run\",\n            \"addOnPreRun\",\n            \"addOnInit\",\n            \"addOnPreMain\",\n            \"addOnExit\",\n            \"addOnPostRun\",\n            \"addRunDependency\",\n            \"removeRunDependency\",\n            \"FS_createFolder\",\n            \"FS_createPath\",\n            \"FS_createLazyFile\",\n            \"FS_createLink\",\n            \"FS_createDevice\",\n            \"FS_readFile\",\n            \"out\",\n            \"err\",\n            \"callMain\",\n            \"abort\",\n            \"wasmMemory\",\n            \"wasmExports\",\n            \"stackAlloc\",\n            \"stackSave\",\n            \"stackRestore\",\n            \"getTempRet0\",\n            \"setTempRet0\",\n            \"writeStackCookie\",\n            \"checkStackCookie\",\n            \"convertI32PairToI53Checked\",\n            \"ptrToString\",\n            \"zeroMemory\",\n            \"exitJS\",\n            \"getHeapMax\",\n            \"growMemory\",\n            \"ENV\",\n            \"MONTH_DAYS_REGULAR\",\n            \"MONTH_DAYS_LEAP\",\n            \"MONTH_DAYS_REGULAR_CUMULATIVE\",\n            \"MONTH_DAYS_LEAP_CUMULATIVE\",\n            \"isLeapYear\",\n            \"arraySum\",\n            \"addDays\",\n            \"ERRNO_CODES\",\n            \"ERRNO_MESSAGES\",\n            \"DNS\",\n            \"Protocols\",\n            \"Sockets\",\n            \"initRandomFill\",\n            \"randomFill\",\n            \"timers\",\n            \"warnOnce\",\n            \"UNWIND_CACHE\",\n            \"readEmAsmArgsArray\",\n            \"getExecutableName\",\n            \"dynCallLegacy\",\n            \"getDynCaller\",\n            \"dynCall\",\n            \"handleException\",\n            \"keepRuntimeAlive\",\n            \"asyncLoad\",\n            \"alignMemory\",\n            \"mmapAlloc\",\n            \"handleAllocatorInit\",\n            \"HandleAllocator\",\n            \"wasmTable\",\n            \"noExitRuntime\",\n            \"freeTableIndexes\",\n            \"functionsInTableMap\",\n            \"setValue\",\n            \"getValue\",\n            \"PATH\",\n            \"PATH_FS\",\n            \"UTF8Decoder\",\n            \"UTF8ArrayToString\",\n            \"UTF8ToString\",\n            \"stringToUTF8Array\",\n            \"stringToUTF8\",\n            \"lengthBytesUTF8\",\n            \"intArrayFromString\",\n            \"stringToAscii\",\n            \"UTF16Decoder\",\n            \"UTF16ToString\",\n            \"stringToUTF16\",\n            \"lengthBytesUTF16\",\n            \"UTF32ToString\",\n            \"stringToUTF32\",\n            \"lengthBytesUTF32\",\n            \"writeArrayToMemory\",\n            \"JSEvents\",\n            \"specialHTMLTargets\",\n            \"currentFullscreenStrategy\",\n            \"restoreOldWindowedStyle\",\n            \"demangle\",\n            \"demangleAll\",\n            \"ExitStatus\",\n            \"getEnvStrings\",\n            \"doReadv\",\n            \"doWritev\",\n            \"promiseMap\",\n            \"uncaughtExceptionCount\",\n            \"exceptionLast\",\n            \"exceptionCaught\",\n            \"ExceptionInfo\",\n            \"Browser\",\n            \"wget\",\n            \"SYSCALLS\",\n            \"preloadPlugins\",\n            \"FS_createPreloadedFile\",\n            \"FS_modeStringToFlags\",\n            \"FS_getMode\",\n            \"FS_stdin_getChar_buffer\",\n            \"FS_stdin_getChar\",\n            \"FS\",\n            \"FS_createDataFile\",\n            \"MEMFS\",\n            \"TTY\",\n            \"PIPEFS\",\n            \"SOCKFS\",\n            \"tempFixedLengthArray\",\n            \"miniTempWebGLFloatBuffers\",\n            \"miniTempWebGLIntBuffers\",\n            \"GL\",\n            \"emscripten_webgl_power_preferences\",\n            \"AL\",\n            \"GLUT\",\n            \"EGL\",\n            \"GLEW\",\n            \"IDBStore\",\n            \"SDL\",\n            \"SDL_gfx\",\n            \"allocateUTF8\",\n            \"allocateUTF8OnStack\",\n            \"InternalError\",\n            \"BindingError\",\n            \"throwInternalError\",\n            \"throwBindingError\",\n            \"registeredTypes\",\n            \"awaitingDependencies\",\n            \"typeDependencies\",\n            \"tupleRegistrations\",\n            \"structRegistrations\",\n            \"sharedRegisterType\",\n            \"whenDependentTypesAreResolved\",\n            \"embind_charCodes\",\n            \"embind_init_charCodes\",\n            \"readLatin1String\",\n            \"getTypeName\",\n            \"getFunctionName\",\n            \"heap32VectorToArray\",\n            \"requireRegisteredType\",\n            \"UnboundTypeError\",\n            \"PureVirtualError\",\n            \"GenericWireTypeSize\",\n            \"throwUnboundTypeError\",\n            \"ensureOverloadTable\",\n            \"exposePublicSymbol\",\n            \"replacePublicSymbol\",\n            \"extendError\",\n            \"createNamedFunction\",\n            \"embindRepr\",\n            \"registeredInstances\",\n            \"registeredPointers\",\n            \"registerType\",\n            \"integerReadValueFromPointer\",\n            \"floatReadValueFromPointer\",\n            \"simpleReadValueFromPointer\",\n            \"readPointer\",\n            \"runDestructors\",\n            \"newFunc\",\n            \"craftInvokerFunction\",\n            \"embind__requireFunction\",\n            \"finalizationRegistry\",\n            \"detachFinalizer_deps\",\n            \"deletionQueue\",\n            \"delayFunction\",\n            \"char_0\",\n            \"char_9\",\n            \"makeLegalFunctionName\",\n            \"emval_handles\",\n            \"emval_symbols\",\n            \"init_emval\",\n            \"count_emval_handles\",\n            \"getStringOrSymbol\",\n            \"Emval\",\n            \"emval_newers\",\n            \"emval_methodCallers\"\n        ];\n        unexportedSymbols.forEach(unexportedRuntimeSymbol);\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n        };\n        function callMain() {\n            assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n            assert(__ATPRERUN__.length == 0, \"cannot call main when preRun functions remain to be called\");\n            var entryFunction = _main;\n            var argc = 0;\n            var argv = 0;\n            try {\n                var ret = entryFunction(argc, argv);\n                // if we're not running an evented main loop, it's time to exit\n                exitJS(ret, /* implicit = */ true);\n                return ret;\n            } catch (e) {\n                return handleException(e);\n            }\n        }\n        function stackCheckInit() {\n            // This is normally called automatically during __wasm_call_ctors but need to\n            // get these values before even running any of the ctors so we call it redundantly\n            // here.\n            _emscripten_stack_init();\n            // TODO(sbc): Move writeStackCookie to native to to avoid this.\n            writeStackCookie();\n        }\n        function run() {\n            if (runDependencies > 0) return;\n            stackCheckInit();\n            preRun();\n            // a preRun added a dependency, run will be called later\n            if (runDependencies > 0) return;\n            function doRun() {\n                // run may have just been called through dependencies being fulfilled just in this very frame,\n                // or while the async setStatus time below was happening\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                preMain();\n                readyPromiseResolve(Module);\n                if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n                if (shouldRunNow) callMain();\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(function() {\n                    setTimeout(function() {\n                        Module[\"setStatus\"](\"\");\n                    }, 1);\n                    doRun();\n                }, 1);\n            } else doRun();\n            checkStackCookie();\n        }\n        function checkUnflushedContent() {\n            // Compiler settings do not allow exiting the runtime, so flushing\n            // the streams is not possible. but in ASSERTIONS mode we check\n            // if there was something to flush, and if so tell the user they\n            // should request that the runtime be exitable.\n            // Normally we would not even include flush() at all, but in ASSERTIONS\n            // builds we do so just for this check, and here we see if there is any\n            // content to flush, that is, we check if there would have been\n            // something a non-ASSERTIONS build would have not seen.\n            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n            // mode (which has its own special function for this; otherwise, all\n            // the code is inside libc)\n            var oldOut = out;\n            var oldErr = err;\n            var has = false;\n            out = err = (x)=>{\n                has = true;\n            };\n            try {\n                _fflush(0);\n                // also flush in the JS FS layer\n                [\n                    \"stdout\",\n                    \"stderr\"\n                ].forEach(function(name) {\n                    var info = FS.analyzePath(\"/dev/\" + name);\n                    if (!info) return;\n                    var stream = info.object;\n                    var rdev = stream.rdev;\n                    var tty = TTY.ttys[rdev];\n                    if (tty && tty.output && tty.output.length) has = true;\n                });\n            } catch (e) {}\n            out = oldOut;\n            err = oldErr;\n            if (has) warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\");\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0)Module[\"preInit\"].pop()();\n        }\n        // shouldRunNow refers to calling main(), not run().\n        var shouldRunNow = true;\n        if (Module[\"noInitialRun\"]) shouldRunNow = false;\n        run();\n        // end include: postamble.js\n        return moduleArg.ready;\n    };\n})();\n// @ts-expect-error untyped\nlet $e6803e952bdec1ea$var$library;\n/**\r\n   * Instances the WASM module and returns it, only one module will be created upon multiple calls.\r\n   * @category WASM\r\n   * @group WASM\r\n   *\r\n   * @returns\r\n   */ const $e6803e952bdec1ea$export$b80d5513bcafc6b2 = async ()=>{\n    if (!$e6803e952bdec1ea$var$library) $e6803e952bdec1ea$var$library = await $e6803e952bdec1ea$var$Module();\n    return $e6803e952bdec1ea$var$library;\n};\n/**\r\n   * @deprecated\r\n   * @param description\r\n   * @param name\r\n   * @param defaultValue\r\n   * @returns\r\n   */ /* istanbul ignore next */ const $e6803e952bdec1ea$var$getAttribute = (description, name, defaultValue)=>{\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName(\"rdf:li\");\n            if (values.length === 3) returnValue = Array.from(values).map((v)=>v.innerHTML);\n            else throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n        } else {\n            if (defaultValue) return defaultValue;\n            else throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    } else returnValue = parsedValue;\n    return returnValue;\n};\n/**\r\n   * Decodes a JPEG file with an embedded Gainmap and XMP Metadata (aka JPEG-R)\r\n   *\r\n   * @category Decoding\r\n   * @group Decoding\r\n   * @deprecated\r\n   * @example\r\n   * import { decodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\r\n   *\r\n   * // fetch a JPEG image containing a gainmap as ArrayBuffer\r\n   * const gainmap = new Uint8Array(await (await fetch('gainmap.jpeg')).arrayBuffer())\r\n   *\r\n   * // extract data from the JPEG\r\n   * const { gainMap, sdr, parsedMetadata } = await decodeJPEGMetadata(gainmap)\r\n   *\r\n   * @param file A Jpeg file Uint8Array.\r\n   * @returns The decoded data\r\n   * @throws {Error} if the provided file cannot be parsed or does not contain a valid Gainmap\r\n   */ /* istanbul ignore next */ const $e6803e952bdec1ea$export$869678655aad5f2c = async (file)=>{\n    var _a, _b;\n    const lib = await $e6803e952bdec1ea$export$b80d5513bcafc6b2();\n    const result = lib.extractJpegR(file, file.length);\n    if (!result.success) throw new Error(`${result.errorMessage}`);\n    const parser = new DOMParser();\n    const xmlDocument = parser.parseFromString(result.metadata, \"text/xml\");\n    const description = xmlDocument.getElementsByTagName(\"rdf:Description\")[0];\n    const gainMapMin = $e6803e952bdec1ea$var$getAttribute(description, \"hdrgm:GainMapMin\", \"0\");\n    const gainMapMax = $e6803e952bdec1ea$var$getAttribute(description, \"hdrgm:GainMapMax\");\n    const gamma = $e6803e952bdec1ea$var$getAttribute(description, \"hdrgm:Gamma\", \"1\");\n    const offsetSDR = $e6803e952bdec1ea$var$getAttribute(description, \"hdrgm:OffsetSDR\", \"0.015625\");\n    const offsetHDR = $e6803e952bdec1ea$var$getAttribute(description, \"hdrgm:OffsetHDR\", \"0.015625\");\n    let hdrCapacityMin = (_a = description.attributes.getNamedItem(\"hdrgm:HDRCapacityMin\")) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!hdrCapacityMin) hdrCapacityMin = \"0\";\n    const hdrCapacityMax = (_b = description.attributes.getNamedItem(\"hdrgm:HDRCapacityMax\")) === null || _b === void 0 ? void 0 : _b.nodeValue;\n    if (!hdrCapacityMax) throw new Error(\"Incomplete gainmap metadata\");\n    const parsedMetadata = {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v)=>parseFloat(v)) : [\n            parseFloat(gainMapMin),\n            parseFloat(gainMapMin),\n            parseFloat(gainMapMin)\n        ],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v)=>parseFloat(v)) : [\n            parseFloat(gainMapMax),\n            parseFloat(gainMapMax),\n            parseFloat(gainMapMax)\n        ],\n        gamma: Array.isArray(gamma) ? gamma.map((v)=>parseFloat(v)) : [\n            parseFloat(gamma),\n            parseFloat(gamma),\n            parseFloat(gamma)\n        ],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v)=>parseFloat(v)) : [\n            parseFloat(offsetSDR),\n            parseFloat(offsetSDR),\n            parseFloat(offsetSDR)\n        ],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v)=>parseFloat(v)) : [\n            parseFloat(offsetHDR),\n            parseFloat(offsetHDR),\n            parseFloat(offsetHDR)\n        ],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n    };\n    return {\n        ...result,\n        parsedMetadata: /**\r\n\t\t   * Parsed metadata\r\n\t\t   */ parsedMetadata\n    };\n};\n/**\r\n   * Encapsulates a Gainmap into a single JPEG file (aka: JPEG-R) with the base map\r\n   * as the sdr visualization and the gainMap encoded into a MPF (Multi-Picture Format) tag.\r\n   *\r\n   * @category Encoding\r\n   * @group Encoding\r\n   *\r\n   * @example\r\n   * import { compress, encode, findTextureMinMax } from '@monogrid/gainmap-js'\r\n   * import { encodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\r\n   * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\r\n   *\r\n   * // load an HDR file\r\n   * const loader = new EXRLoader()\r\n   * const image = await loader.loadAsync('image.exr')\r\n   *\r\n   * // find RAW RGB Max value of a texture\r\n   * const textureMax = await findTextureMinMax(image)\r\n   *\r\n   * // Encode the gainmap\r\n   * const encodingResult = encode({\r\n   *   image,\r\n   *   maxContentBoost: Math.max.apply(this, textureMax)\r\n   * })\r\n   *\r\n   * // obtain the RAW RGBA SDR buffer and create an ImageData\r\n   * const sdrImageData = new ImageData(\r\n   *   encodingResult.sdr.toArray(),\r\n   *   encodingResult.sdr.width,\r\n   *   encodingResult.sdr.height\r\n   * )\r\n   * // obtain the RAW RGBA Gain map buffer and create an ImageData\r\n   * const gainMapImageData = new ImageData(\r\n   *   encodingResult.gainMap.toArray(),\r\n   *   encodingResult.gainMap.width,\r\n   *   encodingResult.gainMap.height\r\n   * )\r\n   *\r\n   * // parallel compress the RAW buffers into the specified mimeType\r\n   * const mimeType = 'image/jpeg'\r\n   * const quality = 0.9\r\n   *\r\n   * const [sdr, gainMap] = await Promise.all([\r\n   *   compress({\r\n   *     source: sdrImageData,\r\n   *     mimeType,\r\n   *     quality,\r\n   *     flipY: true // output needs to be flipped\r\n   *   }),\r\n   *   compress({\r\n   *     source: gainMapImageData,\r\n   *     mimeType,\r\n   *     quality,\r\n   *     flipY: true // output needs to be flipped\r\n   *   })\r\n   * ])\r\n   *\r\n   * // obtain the metadata which will be embedded into\r\n   * // and XMP tag inside the final JPEG file\r\n   * const metadata = encodingResult.getMetadata()\r\n   *\r\n   * // embed the compressed images + metadata into a single\r\n   * // JPEG file\r\n   * const jpeg = await encodeJPEGMetadata({\r\n   *   ...encodingResult,\r\n   *   ...metadata,\r\n   *   sdr,\r\n   *   gainMap\r\n   * })\r\n   *\r\n   * // `jpeg` will be an `Uint8Array` which can be saved somewhere\r\n   *\r\n   *\r\n   * @param encodingResult\r\n   * @returns an Uint8Array representing a JPEG-R file\r\n   * @throws {Error} If `encodingResult.sdr.mimeType !== 'image/jpeg'`\r\n   * @throws {Error} If `encodingResult.gainMap.mimeType !== 'image/jpeg'`\r\n   */ const $e6803e952bdec1ea$export$9a3ecb99e8fd3ab2 = async (encodingResult)=>{\n    const lib = await $e6803e952bdec1ea$export$b80d5513bcafc6b2();\n    if (encodingResult.sdr.mimeType !== \"image/jpeg\") throw new Error(\"This function expects an SDR image compressed in jpeg\");\n    if (encodingResult.gainMap.mimeType !== \"image/jpeg\") throw new Error(\"This function expects a GainMap image compressed in jpeg\");\n    return lib.appendGainMap(encodingResult.sdr.width, encodingResult.sdr.height, encodingResult.sdr.data, encodingResult.sdr.data.length, encodingResult.gainMap.data, encodingResult.gainMap.data.length, encodingResult.gainMapMax.reduce((p, n)=>p + n, 0) / encodingResult.gainMapMax.length, encodingResult.gainMapMin.reduce((p, n)=>p + n, 0) / encodingResult.gainMapMin.length, encodingResult.gamma.reduce((p, n)=>p + n, 0) / encodingResult.gamma.length, encodingResult.offsetSdr.reduce((p, n)=>p + n, 0) / encodingResult.offsetSdr.length, encodingResult.offsetHdr.reduce((p, n)=>p + n, 0) / encodingResult.offsetHdr.length, encodingResult.hdrCapacityMin, encodingResult.hdrCapacityMax);\n};\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $81d499941e92495e$export$326afb041efbd555 {\n    get completeImage() {\n        return this._lastUrl !== null;\n    }\n    constructor(renderer, imageElement = new Image()){\n        this.renderer = renderer;\n        this.image = imageElement;\n        this.encoding = false;\n        this._lastUrl = null;\n        this._encodingId = -1;\n    }\n    async updateFrom(renderTarget) {\n        if (this.encoding) throw new Error(\"HDRImageGenerator: HDR image already being encoded.\");\n        const renderer = this.renderer;\n        const buffer = new Float32Array(renderTarget.width * renderTarget.height * 4);\n        renderer.readRenderTargetPixels(renderTarget, 0, 0, renderTarget.width, renderTarget.height, buffer);\n        const imageInformation = {\n            header: {},\n            width: renderTarget.width,\n            height: renderTarget.height,\n            data: buffer,\n            format: (0, $ilwiq.RGBAFormat),\n            colorSpace: (0, $ilwiq.LinearSRGBColorSpace),\n            type: (0, $ilwiq.FloatType)\n        };\n        this._encodingId++;\n        this.encoding = true;\n        const currentId = this._encodingId;\n        const jpegData = await $81d499941e92495e$var$encodeHDR(imageInformation);\n        if (this._encodingId === currentId) {\n            if (this._lastUrl) URL.revokeObjectURL(this._lastUrl);\n            const blob = new Blob([\n                jpegData\n            ], {\n                type: \"octet/stream\"\n            });\n            this._lastUrl = URL.createObjectURL(blob);\n            this.image.src = this._lastUrl;\n            this.encoding = false;\n        }\n    }\n    reset() {\n        if (this.encoding) {\n            this.encoding = false;\n            this._encodingId++;\n        }\n        if (this._lastUrl) {\n            URL.revokeObjectURL(this._lastUrl);\n            this.image.src = \"\";\n            this._lastUrl = null;\n        }\n    }\n}\nasync function $81d499941e92495e$var$encodeHDR(image) {\n    // find RAW RGB Max value of a texture\n    const textureMax = await (0, $581a283dd38ad8c0$export$1717a30775af005b)(image);\n    // Encode the gainmap\n    const encodingResult = (0, $581a283dd38ad8c0$export$c564cdbbe6da493)({\n        image: image,\n        // this will encode the full HDR range\n        maxContentBoost: Math.max.apply(this, textureMax) || 1\n    });\n    // obtain the RAW RGBA SDR buffer and create an ImageData\n    const sdrImageData = new ImageData(encodingResult.sdr.toArray(), encodingResult.sdr.width, encodingResult.sdr.height);\n    // obtain the RAW RGBA Gain map buffer and create an ImageData\n    const gainMapImageData = new ImageData(encodingResult.gainMap.toArray(), encodingResult.gainMap.width, encodingResult.gainMap.height);\n    // parallel compress the RAW buffers into the specified mimeType\n    const mimeType = \"image/jpeg\";\n    const quality = 0.9;\n    const [sdr, gainMap] = await Promise.all([\n        (0, $daaf2f33281be569$export$db3b6bfb95261072)({\n            source: sdrImageData,\n            mimeType: mimeType,\n            quality: quality,\n            flipY: true // output needs to be flipped\n        }),\n        (0, $daaf2f33281be569$export$db3b6bfb95261072)({\n            source: gainMapImageData,\n            mimeType: mimeType,\n            quality: quality,\n            flipY: true // output needs to be flipped\n        })\n    ]);\n    // obtain the metadata which will be embedded into\n    // and XMP tag inside the final JPEG file\n    const metadata = encodingResult.getMetadata();\n    // embed the compressed images + metadata into a single\n    // JPEG file\n    const jpegBuffer = await (0, $e6803e952bdec1ea$export$9a3ecb99e8fd3ab2)({\n        ...encodingResult,\n        ...metadata,\n        sdr: sdr,\n        gainMap: gainMap\n    });\n    return jpegBuffer;\n}\n\n\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $cE5k3 = parcelRequire(\"cE5k3\");\nconst $0eb9e8a838649cde$var$ENV_URL = \"https://raw.githubusercontent.com/disini/3d-demo-data/master/hdri/studio_small_05_1k.hdr\";\nconst $0eb9e8a838649cde$var$MODEL_URL = \"https://raw.githubusercontent.com/disini/3d-demo-data/main/models/nasa-m2020/MER_static.glb\";\nconst $0eb9e8a838649cde$var$CREDITS = \"Model courtesy of NASA/Caltech-JPL\";\nconst $0eb9e8a838649cde$var$DESCRIPTION = window.matchMedia(\"(dynamic-range: high)\").matches ? \"HDR display supported\" : \"HDR display not supported\";\nconst $0eb9e8a838649cde$var$MAX_SAMPLES = 45;\nconst $0eb9e8a838649cde$var$params = {\n    pause: false,\n    hdr: true,\n    sdrToneMapping: false,\n    environmentIntensity: 15,\n    tiles: 3,\n    bounces: 5,\n    renderScale: 1,\n    ...(0, $cE5k3.getScaledSettings)()\n};\nlet $0eb9e8a838649cde$var$pathTracer, $0eb9e8a838649cde$var$renderer, $0eb9e8a838649cde$var$controls;\nlet $0eb9e8a838649cde$var$camera, $0eb9e8a838649cde$var$scene;\nlet $0eb9e8a838649cde$var$loader, $0eb9e8a838649cde$var$hdrGenerator;\nlet $0eb9e8a838649cde$var$activeImage = false;\n$0eb9e8a838649cde$var$init();\nasync function $0eb9e8a838649cde$var$init() {\n    $0eb9e8a838649cde$var$loader = new (0, $e2Pv4.LoaderElement)();\n    $0eb9e8a838649cde$var$loader.attach(document.body);\n    // renderer\n    $0eb9e8a838649cde$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    document.body.appendChild($0eb9e8a838649cde$var$renderer.domElement);\n    // path tracer\n    $0eb9e8a838649cde$var$pathTracer = new (0, $8mHfG.WebGLPathTracer)($0eb9e8a838649cde$var$renderer);\n    $0eb9e8a838649cde$var$pathTracer.filterGlossyFactor = 0.5;\n    $0eb9e8a838649cde$var$pathTracer.bounces = $0eb9e8a838649cde$var$params.bounces;\n    $0eb9e8a838649cde$var$pathTracer.minSamples = 1;\n    $0eb9e8a838649cde$var$pathTracer.renderScale = $0eb9e8a838649cde$var$params.renderScale;\n    $0eb9e8a838649cde$var$pathTracer.tiles.set($0eb9e8a838649cde$var$params.tiles, $0eb9e8a838649cde$var$params.tiles);\n    $0eb9e8a838649cde$var$pathTracer.setBVHWorker(new (0, $kqOCM.ParallelMeshBVHWorker)());\n    // generator\n    $0eb9e8a838649cde$var$hdrGenerator = new (0, $81d499941e92495e$export$326afb041efbd555)($0eb9e8a838649cde$var$renderer, document.querySelector(\"img\"));\n    // camera\n    $0eb9e8a838649cde$var$camera = new (0, $ilwiq.PerspectiveCamera)(50, 1, 0.025, 500);\n    $0eb9e8a838649cde$var$camera.position.set(20, 24, 35).multiplyScalar(0.8);\n    // scene\n    $0eb9e8a838649cde$var$scene = new (0, $ilwiq.Scene)();\n    $0eb9e8a838649cde$var$scene.backgroundBlurriness = 0.1;\n    $0eb9e8a838649cde$var$scene.background = new (0, $ilwiq.Color)(0x111111);\n    // controls\n    $0eb9e8a838649cde$var$controls = new (0, $5Rd1x.OrbitControls)($0eb9e8a838649cde$var$camera, $0eb9e8a838649cde$var$renderer.domElement);\n    $0eb9e8a838649cde$var$controls.target.y = 6;\n    $0eb9e8a838649cde$var$controls.addEventListener(\"change\", ()=>{\n        $0eb9e8a838649cde$var$pathTracer.updateCamera();\n        $0eb9e8a838649cde$var$resetHdr();\n    });\n    $0eb9e8a838649cde$var$controls.update();\n    // load the environment map and model\n    const [gltf, envTexture] = await Promise.all([\n        new (0, $7lx9d.GLTFLoader)().setMeshoptDecoder((0, $kp7Te.MeshoptDecoder)).loadAsync($0eb9e8a838649cde$var$MODEL_URL),\n        new (0, $891vQ.RGBELoader)().loadAsync($0eb9e8a838649cde$var$ENV_URL)\n    ]);\n    envTexture.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n    $0eb9e8a838649cde$var$scene.environment = envTexture;\n    $0eb9e8a838649cde$var$scene.environmentIntensity = $0eb9e8a838649cde$var$params.environmentIntensity;\n    const model = gltf.scene;\n    model.scale.setScalar(10);\n    $0eb9e8a838649cde$var$scene.add(model);\n    const floorTex = (0, $1EdOY.generateRadialFloorTexture)(2048);\n    const floorPlane = new (0, $ilwiq.Mesh)(new (0, $ilwiq.PlaneGeometry)(), new (0, $ilwiq.MeshStandardMaterial)({\n        map: floorTex,\n        transparent: true,\n        color: 0x111111,\n        roughness: 0.1,\n        metalness: 0.1,\n        side: (0, $ilwiq.DoubleSide)\n    }));\n    floorPlane.scale.setScalar(50);\n    floorPlane.rotation.x = -Math.PI / 2;\n    $0eb9e8a838649cde$var$scene.add(floorPlane);\n    // initialize the path tracer\n    await $0eb9e8a838649cde$var$pathTracer.setSceneAsync($0eb9e8a838649cde$var$scene, $0eb9e8a838649cde$var$camera, {\n        onProgress: (v)=>$0eb9e8a838649cde$var$loader.setPercentage(v)\n    });\n    $0eb9e8a838649cde$var$loader.setCredits($0eb9e8a838649cde$var$CREDITS);\n    $0eb9e8a838649cde$var$loader.setDescription($0eb9e8a838649cde$var$DESCRIPTION);\n    const gui = new (0, $jiuw3.GUI)();\n    gui.add($0eb9e8a838649cde$var$params, \"pause\").onChange(()=>{\n        $0eb9e8a838649cde$var$resetHdr();\n    });\n    gui.add($0eb9e8a838649cde$var$params, \"hdr\");\n    gui.add($0eb9e8a838649cde$var$params, \"sdrToneMapping\").onChange((v)=>{\n        $0eb9e8a838649cde$var$renderer.toneMapping = v ? (0, $ilwiq.ACESFilmicToneMapping) : (0, $ilwiq.NoToneMapping);\n    });\n    gui.add($0eb9e8a838649cde$var$params, \"renderScale\", 0.1, 1).onChange((v)=>{\n        $0eb9e8a838649cde$var$pathTracer.renderScale = v;\n        $0eb9e8a838649cde$var$pathTracer.reset();\n        $0eb9e8a838649cde$var$resetHdr();\n    });\n    gui.add($0eb9e8a838649cde$var$params, \"bounces\", 1, 10).onChange((v)=>{\n        $0eb9e8a838649cde$var$pathTracer.bounces = v;\n        $0eb9e8a838649cde$var$pathTracer.reset();\n        $0eb9e8a838649cde$var$resetHdr();\n    });\n    gui.add($0eb9e8a838649cde$var$params, \"tiles\", 1, 6, 1).onChange((v)=>{\n        $0eb9e8a838649cde$var$pathTracer.tiles.setScalar(v);\n    });\n    gui.add($0eb9e8a838649cde$var$params, \"environmentIntensity\", 0, 30).onChange((v)=>{\n        $0eb9e8a838649cde$var$scene.environmentIntensity = v;\n        $0eb9e8a838649cde$var$pathTracer.updateEnvironment();\n        $0eb9e8a838649cde$var$resetHdr();\n    });\n    window.addEventListener(\"resize\", $0eb9e8a838649cde$var$onResize);\n    $0eb9e8a838649cde$var$onResize();\n    $0eb9e8a838649cde$var$animate();\n}\nfunction $0eb9e8a838649cde$var$onResize() {\n    // update resolution\n    $0eb9e8a838649cde$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $0eb9e8a838649cde$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $0eb9e8a838649cde$var$camera.aspect = window.innerWidth / window.innerHeight;\n    $0eb9e8a838649cde$var$camera.updateProjectionMatrix();\n    // update camera\n    $0eb9e8a838649cde$var$pathTracer.updateCamera();\n    $0eb9e8a838649cde$var$resetHdr();\n}\nfunction $0eb9e8a838649cde$var$resetHdr() {\n    $0eb9e8a838649cde$var$hdrGenerator.reset();\n    $0eb9e8a838649cde$var$activeImage = false;\n}\nfunction $0eb9e8a838649cde$var$animate() {\n    requestAnimationFrame($0eb9e8a838649cde$var$animate);\n    const doPause = $0eb9e8a838649cde$var$params.pause && $0eb9e8a838649cde$var$pathTracer.samples >= 1;\n    $0eb9e8a838649cde$var$pathTracer.pausePathTracing = $0eb9e8a838649cde$var$pathTracer.samples >= $0eb9e8a838649cde$var$MAX_SAMPLES || doPause;\n    $0eb9e8a838649cde$var$pathTracer.renderSample();\n    if (!$0eb9e8a838649cde$var$hdrGenerator.encoding && $0eb9e8a838649cde$var$params.hdr && ($0eb9e8a838649cde$var$pathTracer.samples === $0eb9e8a838649cde$var$MAX_SAMPLES || doPause) && !$0eb9e8a838649cde$var$activeImage) {\n        // NOTE: this can be called repeatedly but takes up to 200 ms\n        $0eb9e8a838649cde$var$hdrGenerator.updateFrom($0eb9e8a838649cde$var$pathTracer.target);\n        $0eb9e8a838649cde$var$activeImage = true;\n    }\n    if ($0eb9e8a838649cde$var$hdrGenerator.completeImage && $0eb9e8a838649cde$var$params.hdr) $0eb9e8a838649cde$var$hdrGenerator.image.classList.add(\"show\");\n    else $0eb9e8a838649cde$var$hdrGenerator.image.classList.remove(\"show\");\n    $0eb9e8a838649cde$var$loader.setSamples($0eb9e8a838649cde$var$pathTracer.samples, $0eb9e8a838649cde$var$pathTracer.isCompiling);\n}\n\n\n//# sourceMappingURL=hdr.37cb34b5.js.map\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\nimport { convertToBufferType, isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { GenerateMeshBVHWorker } from './GenerateMeshBVHWorker.js';\nimport { ensureIndex } from '../core/build/geometryUtils.js';\n\nconst DEFAULT_WORKER_COUNT = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4;\nclass _ParallelMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './parallelMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\n\t\tthis.name = 'ParallelMeshBVHWorker';\n\t\tthis.maxWorkerCount = Math.max( DEFAULT_WORKER_COUNT, 4 );\n\n\t\tif ( ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'ParallelMeshBVHWorker: Shared Array Buffers are not supported.' );\n\n\t\t}\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif ( ! geometry.index && ! options.indirect ) {\n\n\t\t\t\tensureIndex( geometry, options );\n\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `ParallelMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = {\n\t\t\t\t\t\tsetBoundingBox: true,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t};\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tworker.postMessage( {\n\n\t\t\t\toperation: 'BUILD_BVH',\n\t\t\t\tmaxWorkerCount: this.maxWorkerCount,\n\t\t\t\tindex: convertToBufferType( index, SharedArrayBuffer ),\n\t\t\t\tposition: convertToBufferType( position, SharedArrayBuffer ),\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\nexport class ParallelMeshBVHWorker {\n\n\tconstructor() {\n\n\t\tif ( isSharedArrayBufferSupported() ) {\n\n\t\t\treturn new _ParallelMeshBVHWorker();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.' );\n\n\t\t\tconst object = new GenerateMeshBVHWorker();\n\t\t\tobject.maxWorkerCount = DEFAULT_WORKER_COUNT;\n\t\t\treturn object;\n\n\t\t}\n\n\t}\n\n}\n","export class WorkerBase {\n\n\tconstructor( worker ) {\n\n\t\tthis.name = 'WorkerBase';\n\t\tthis.running = false;\n\t\tthis.worker = worker;\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ this.name }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\trunTask() {}\n\n\tgenerate( ...args ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Already running job.' );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( 'GenerateMeshBVHWorker: Worker has been disposed.' );\n\n\t\t}\n\n\t\tthis.running = true;\n\n\t\tconst promise = this.runTask( this.worker, ...args );\n\t\tpromise.finally( () => {\n\n\t\t\tthis.running = false;\n\n\t\t} );\n\n\t\treturn promise;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","import { Box3, BufferAttribute } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport { WorkerBase } from './utils/WorkerBase.js';\n\nexport class GenerateMeshBVHWorker extends WorkerBase {\n\n\tconstructor() {\n\n\t\tconst worker = new Worker( new URL( './generateMeshBVH.worker.js', import.meta.url ), { type: 'module' } );\n\t\tsuper( worker );\n\t\tthis.name = 'GenerateMeshBVHWorker';\n\n\t}\n\n\trunTask( worker, geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tif (\n\t\t\t\tgeometry.getAttribute( 'position' ).isInterleavedBufferAttribute ||\n\t\t\t\tgeometry.index && geometry.index.isInterleavedBufferAttribute\n\t\t\t) {\n\n\t\t\t\tthrow new Error( 'GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.' );\n\n\t\t\t}\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `GenerateMeshBVHWorker: ${ e.message }` ) );\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.serialized ) {\n\n\t\t\t\t\tconst { serialized, position } = data;\n\t\t\t\t\tconst bvh = MeshBVH.deserialize( serialized, geometry, { setIndex: false } );\n\t\t\t\t\tconst boundsOptions = Object.assign( {\n\n\t\t\t\t\t\tsetBoundingBox: true,\n\n\t\t\t\t\t}, options );\n\n\t\t\t\t\t// we need to replace the arrays because they're neutered entirely by the\n\t\t\t\t\t// webworker transfer.\n\t\t\t\t\tgeometry.attributes.position.array = position;\n\t\t\t\t\tif ( serialized.index ) {\n\n\t\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\t\tgeometry.index.array = serialized.index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst newIndex = new BufferAttribute( serialized.index, 1, false );\n\t\t\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boundsOptions.setBoundingBox ) {\n\n\t\t\t\t\t\tgeometry.boundingBox = bvh.getBoundingBox( new Box3() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( bvh );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\t\tconst position = geometry.attributes.position.array;\n\t\t\tconst transferable = [ position ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransferable.push( index );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t\tgroups: [ ... geometry.groups ],\n\t\t\t\t},\n\n\t\t\t}, transferable.map( arr => arr.buffer ).filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) ) );\n\n\t\t} );\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"generateMeshBVH.worker.373f3c58.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(\"parallelMeshBVH.worker.22cf4bb0.js\");\nmodule.exports = workerURL(url.toString(), url.origin, true);","let _styleElement;\r\nfunction initializeStyles() {\r\n\r\n\tif ( _styleElement ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t_styleElement = document.createElement( 'style' );\r\n\t_styleElement.textContent = /* css */`\r\n\r\n\t\t.loader-container, .description {\r\n\t\t\tposition: absolute;\r\n\t\t\twidth: 100%;\r\n\t\t\tfont-family: 'Courier New', Courier, monospace;\r\n\t\t\tcolor: white;\r\n\t\t\tfont-weight: light;\r\n\t\t\talign-items: flex-start;\r\n\t\t\tfont-size: 14px;\r\n\t\t\tpointer-events: none;\r\n\t\t\tuser-select: none;\r\n\t\t}\r\n\r\n\t\t.loader-container {\r\n\t\t\tdisplay: flex;\r\n\t\t\tflex-direction: column;\r\n\t\t\tbottom: 0;\r\n\t\t}\r\n\r\n\t\t.description {\r\n\t\t\ttop: 0;\r\n\t\t\twidth: 100%;\r\n\t\t\ttext-align: center;\r\n\t\t\tpadding: 5px 0;\r\n\t\t}\r\n\r\n\t\t.loader-container .bar {\r\n\t\t\theight: 2px;\r\n\t\t\tbackground: white;\r\n\t\t\twidth: 100%;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples,\r\n\t\t.loader-container .percentage {\r\n\t\t\tpadding: 5px;\r\n\t\t\tmargin: 0 0 1px 1px;\r\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\r\n\t\t\tborder-radius: 2px;\r\n\t\t\tdisplay: inline-block;\r\n\t\t}\r\n\r\n\t\t.loader-container:not(.loading) .bar,\r\n\t\t.loader-container:not(.loading) .percentage,\r\n\t\t.loader-container.loading .credits,\r\n\t\t.loader-container.loading .samples,\r\n\t\t.loader-container .credits:empty {\r\n\t\t\tdisplay: none;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits a,\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples {\r\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\r\n\t\t}\r\n\t`;\r\n\tdocument.head.appendChild( _styleElement );\r\n\r\n}\r\n\r\nexport class LoaderElement {\r\n\r\n\tconstructor() {\r\n\r\n\t\tinitializeStyles();\r\n\r\n\t\tconst container = document.createElement( 'div' );\r\n\t\tcontainer.classList.add( 'loader-container' );\r\n\r\n\t\tconst percentageEl = document.createElement( 'div' );\r\n\t\tpercentageEl.classList.add( 'percentage' );\r\n\t\tcontainer.appendChild( percentageEl );\r\n\r\n\t\tconst samplesEl = document.createElement( 'div' );\r\n\t\tsamplesEl.classList.add( 'samples' );\r\n\t\tcontainer.appendChild( samplesEl );\r\n\r\n\t\tconst creditsEl = document.createElement( 'div' );\r\n\t\tcreditsEl.classList.add( 'credits' );\r\n\t\tcontainer.appendChild( creditsEl );\r\n\r\n\t\tconst loaderBarEl = document.createElement( 'div' );\r\n\t\tloaderBarEl.classList.add( 'bar' );\r\n\t\tcontainer.appendChild( loaderBarEl );\r\n\r\n\t\tconst descriptionEl = document.createElement( 'div' );\r\n\t\tdescriptionEl.classList.add( 'description' );\r\n\t\tcontainer.appendChild( descriptionEl );\r\n\r\n\t\tthis._description = descriptionEl;\r\n\t\tthis._loaderBar = loaderBarEl;\r\n\t\tthis._percentage = percentageEl;\r\n\t\tthis._credits = creditsEl;\r\n\t\tthis._samples = samplesEl;\r\n\t\tthis._container = container;\r\n\r\n\t\tthis.setPercentage( 0 );\r\n\r\n\t}\r\n\r\n\tattach( container ) {\r\n\r\n\t\tcontainer.appendChild( this._container );\r\n\t\tcontainer.appendChild( this._description );\r\n\r\n\t}\r\n\r\n\tsetPercentage( perc ) {\r\n\r\n\t\tthis._loaderBar.style.width = `${ perc * 100 }%`;\r\n\r\n\t\tif ( perc === 0 ) {\r\n\r\n\t\t\tthis._percentage.innerText = 'Loading...';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._percentage.innerText = `${ ( perc * 100 ).toFixed( 0 ) }%`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( perc >= 1 ) {\r\n\r\n\t\t\tthis._container.classList.remove( 'loading' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._container.classList.add( 'loading' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetSamples( count, compiling = false ) {\r\n\r\n\t\tif ( compiling ) {\r\n\r\n\t\t\tthis._samples.innerText = 'compiling shader...';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._samples.innerText = `${ Math.floor( count ) } samples`;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetCredits( credits ) {\r\n\r\n\t\tthis._credits.innerHTML = credits;\r\n\r\n\t}\r\n\r\n\tsetDescription( description ) {\r\n\r\n\t\tthis._description.innerHTML = description;\r\n\r\n\t}\r\n\r\n}\r\n","import * as THREE from 'three';\r\n\r\nexport function generateRadialFloorTexture( dim ) {\r\n\r\n\tconst data = new Uint8Array( dim * dim * 4 );\r\n\r\n\tfor ( let x = 0; x < dim; x ++ ) {\r\n\r\n\t\tfor ( let y = 0; y < dim; y ++ ) {\r\n\r\n\t\t\tconst xNorm = x / ( dim - 1 );\r\n\t\t\tconst yNorm = y / ( dim - 1 );\r\n\r\n\t\t\tconst xCent = 2.0 * ( xNorm - 0.5 );\r\n\t\t\tconst yCent = 2.0 * ( yNorm - 0.5 );\r\n\t\t\tlet a = Math.max( Math.min( 1.0 - Math.sqrt( xCent ** 2 + yCent ** 2 ), 1.0 ), 0.0 );\r\n\t\t\ta = a ** 2;\r\n\t\t\ta = a * 1.5;\r\n\t\t\ta = Math.min( a, 1.0 );\r\n\r\n\t\t\tconst i = y * dim + x;\r\n\t\t\tdata[ i * 4 + 0 ] = 255;\r\n\t\t\tdata[ i * 4 + 1 ] = 255;\r\n\t\t\tdata[ i * 4 + 2 ] = 255;\r\n\t\t\tdata[ i * 4 + 3 ] = a * 255;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst tex = new THREE.DataTexture( data, dim, dim );\r\n\ttex.format = THREE.RGBAFormat;\r\n\ttex.type = THREE.UnsignedByteType;\r\n\ttex.minFilter = THREE.LinearFilter;\r\n\ttex.magFilter = THREE.LinearFilter;\r\n\ttex.wrapS = THREE.RepeatWrapping;\r\n\ttex.wrapT = THREE.RepeatWrapping;\r\n\ttex.needsUpdate = true;\r\n\treturn tex;\r\n\r\n}\r\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"cvwp9\")).then(() => parcelRequire('kjyEk'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","export function getScaledSettings() {\r\n\r\n\tlet tiles = 3;\r\n\tlet renderScale = Math.max( 1 / window.devicePixelRatio, 0.5 );\r\n\r\n\t// adjust performance parameters for mobile\r\n\tconst aspectRatio = window.innerWidth / window.innerHeight;\r\n\tif ( aspectRatio < 0.65 ) {\r\n\r\n\t\ttiles = 4;\r\n\t\trenderScale = 0.5 / window.devicePixelRatio;\r\n\r\n\t}\r\n\r\n\treturn { tiles, renderScale };\r\n\r\n}\r\n","import { ShaderMaterial } from 'three';\r\n\r\nexport class MaterialBase extends ShaderMaterial {\r\n\r\n\tset needsUpdate( v ) {\r\n\r\n\t\tsuper.needsUpdate = true;\r\n\t\tthis.dispatchEvent( {\r\n\r\n\t\t\ttype: 'recompilation',\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tconstructor( shader ) {\r\n\r\n\t\tsuper( shader );\r\n\r\n\t\tfor ( const key in this.uniforms ) {\r\n\r\n\t\t\tObject.defineProperty( this, key, {\r\n\r\n\t\t\t\tget() {\r\n\r\n\t\t\t\t\treturn this.uniforms[ key ].value;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tset( v ) {\r\n\r\n\t\t\t\t\tthis.uniforms[ key ].value = v;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\r\n\tsetDefine( name, value = undefined ) {\r\n\r\n\t\tif ( value === undefined || value === null ) {\r\n\r\n\t\t\tif ( name in this.defines ) {\r\n\r\n\t\t\t\tdelete this.defines[ name ];\r\n\t\t\t\tthis.needsUpdate = true;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this.defines[ name ] !== value ) {\r\n\r\n\t\t\t\tthis.defines[ name ] = value;\r\n\t\t\t\tthis.needsUpdate = true;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","export const math_functions = /* glsl */`\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/disini/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\r\n","export const util_functions = /* glsl */`\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\r\n","export const ggx_functions = /* glsl */`\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n\t}\r\n\r\n`;\r\n","import {\r\n\tScene,\r\n\tEquirectangularReflectionMapping,\r\n\tWebGLRenderer,\r\n\tPerspectiveCamera,\r\n\tMesh,\r\n\tPlaneGeometry,\r\n\tMeshStandardMaterial,\r\n\tDoubleSide,\r\n\tColor,\r\n\tACESFilmicToneMapping,\r\n\tNoToneMapping,\r\n} from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\r\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\r\nimport { ParallelMeshBVHWorker } from 'three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js';\r\nimport { LoaderElement } from './utils/LoaderElement.js';\r\nimport { WebGLPathTracer } from '..';\r\nimport { generateRadialFloorTexture } from './utils/generateRadialFloorTexture.js';\r\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\r\nimport { HDRImageGenerator } from './utils/HDRImageGenerator.js';\r\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\r\nimport { getScaledSettings } from './utils/getScaledSettings.js';\r\n\r\nconst ENV_URL = 'https://raw.githubusercontent.com/disini/3d-demo-data/master/hdri/studio_small_05_1k.hdr';\r\nconst MODEL_URL = 'https://raw.githubusercontent.com/disini/3d-demo-data/main/models/nasa-m2020/MER_static.glb';\r\nconst CREDITS = 'Model courtesy of NASA/Caltech-JPL';\r\nconst DESCRIPTION = window.matchMedia( '(dynamic-range: high)' ).matches ? 'HDR display supported' : 'HDR display not supported';\r\n\r\nconst MAX_SAMPLES = 45;\r\n\r\nconst params = {\r\n\tpause: false,\r\n\thdr: true,\r\n\tsdrToneMapping: false,\r\n\tenvironmentIntensity: 15,\r\n\ttiles: 3,\r\n\tbounces: 5,\r\n\trenderScale: 1,\r\n\r\n\t...getScaledSettings(),\r\n};\r\n\r\nlet pathTracer, renderer, controls;\r\nlet camera, scene;\r\nlet loader, hdrGenerator;\r\nlet activeImage = false;\r\n\r\ninit();\r\n\r\nasync function init() {\r\n\r\n\tloader = new LoaderElement();\r\n\tloader.attach( document.body );\r\n\r\n\t// renderer\r\n\trenderer = new WebGLRenderer( { antialias: true } );\r\n\tdocument.body.appendChild( renderer.domElement );\r\n\r\n\t// path tracer\r\n\tpathTracer = new WebGLPathTracer( renderer );\r\n\tpathTracer.filterGlossyFactor = 0.5;\r\n\tpathTracer.bounces = params.bounces;\r\n\tpathTracer.minSamples = 1;\r\n\tpathTracer.renderScale = params.renderScale;\r\n\tpathTracer.tiles.set( params.tiles, params.tiles );\r\n\tpathTracer.setBVHWorker( new ParallelMeshBVHWorker() );\r\n\r\n\t// generator\r\n\thdrGenerator = new HDRImageGenerator( renderer, document.querySelector( 'img' ) );\r\n\r\n\t// camera\r\n\tcamera = new PerspectiveCamera( 50, 1, 0.025, 500 );\r\n\tcamera.position.set( 20, 24, 35 ).multiplyScalar( 0.8 );\r\n\r\n\t// scene\r\n\tscene = new Scene();\r\n\tscene.backgroundBlurriness = 0.1;\r\n\tscene.background = new Color( 0x111111 );\r\n\r\n\t// controls\r\n\tcontrols = new OrbitControls( camera, renderer.domElement );\r\n\tcontrols.target.y = 6;\r\n\tcontrols.addEventListener( 'change', () => {\r\n\r\n\t\tpathTracer.updateCamera();\r\n\t\tresetHdr();\r\n\r\n\t} );\r\n\tcontrols.update();\r\n\r\n\t// load the environment map and model\r\n\tconst [ gltf, envTexture ] = await Promise.all( [\r\n\t\tnew GLTFLoader().setMeshoptDecoder( MeshoptDecoder ).loadAsync( MODEL_URL ),\r\n\t\tnew RGBELoader().loadAsync( ENV_URL ),\r\n\t] );\r\n\r\n\tenvTexture.mapping = EquirectangularReflectionMapping;\r\n\tscene.environment = envTexture;\r\n\tscene.environmentIntensity = params.environmentIntensity;\r\n\r\n\tconst model = gltf.scene;\r\n\tmodel.scale.setScalar( 10 );\r\n\tscene.add( model );\r\n\r\n\tconst floorTex = generateRadialFloorTexture( 2048 );\r\n\tconst floorPlane = new Mesh(\r\n\t\tnew PlaneGeometry(),\r\n\t\tnew MeshStandardMaterial( {\r\n\t\t\tmap: floorTex,\r\n\t\t\ttransparent: true,\r\n\t\t\tcolor: 0x111111,\r\n\t\t\troughness: 0.1,\r\n\t\t\tmetalness: 0.1,\r\n\t\t\tside: DoubleSide,\r\n\t\t} ),\r\n\t);\r\n\tfloorPlane.scale.setScalar( 50 );\r\n\tfloorPlane.rotation.x = - Math.PI / 2;\r\n\tscene.add( floorPlane );\r\n\r\n\t// initialize the path tracer\r\n\tawait pathTracer.setSceneAsync( scene, camera, {\r\n\t\tonProgress: v => loader.setPercentage( v ),\r\n\t} );\r\n\r\n\tloader.setCredits( CREDITS );\r\n\tloader.setDescription( DESCRIPTION );\r\n\r\n\tconst gui = new GUI();\r\n\tgui.add( params, 'pause' ).onChange( () => {\r\n\r\n\t\tresetHdr();\r\n\r\n\t} );\r\n\tgui.add( params, 'hdr' );\r\n\tgui.add( params, 'sdrToneMapping' ).onChange( v => {\r\n\r\n\t\trenderer.toneMapping = v ? ACESFilmicToneMapping : NoToneMapping;\r\n\r\n\t} );\r\n\tgui.add( params, 'renderScale', 0.1, 1 ).onChange( v => {\r\n\r\n\t\tpathTracer.renderScale = v;\r\n\t\tpathTracer.reset();\r\n\t\tresetHdr();\r\n\r\n\t} );\r\n\tgui.add( params, 'bounces', 1, 10 ).onChange( v => {\r\n\r\n\t\tpathTracer.bounces = v;\r\n\t\tpathTracer.reset();\r\n\t\tresetHdr();\r\n\r\n\t} );\r\n\tgui.add( params, 'tiles', 1, 6, 1 ).onChange( v => {\r\n\r\n\t\tpathTracer.tiles.setScalar( v );\r\n\r\n\t} );\r\n\tgui.add( params, 'environmentIntensity', 0, 30 ).onChange( v => {\r\n\r\n\t\tscene.environmentIntensity = v;\r\n\t\tpathTracer.updateEnvironment();\r\n\t\tresetHdr();\r\n\r\n\t} );\r\n\r\n\twindow.addEventListener( 'resize', onResize );\r\n\r\n\tonResize();\r\n\tanimate();\r\n\r\n}\r\n\r\nfunction onResize() {\r\n\r\n\t// update resolution\r\n\trenderer.setSize( window.innerWidth, window.innerHeight );\r\n\trenderer.setPixelRatio( window.devicePixelRatio );\r\n\r\n\tcamera.aspect = window.innerWidth / window.innerHeight;\r\n\tcamera.updateProjectionMatrix();\r\n\r\n\t// update camera\r\n\tpathTracer.updateCamera();\r\n\r\n\tresetHdr();\r\n\r\n}\r\n\r\nfunction resetHdr() {\r\n\r\n\thdrGenerator.reset();\r\n\tactiveImage = false;\r\n\r\n}\r\n\r\nfunction animate() {\r\n\r\n\trequestAnimationFrame( animate );\r\n\r\n\tconst doPause = params.pause && pathTracer.samples >= 1;\r\n\tpathTracer.pausePathTracing = pathTracer.samples >= MAX_SAMPLES || doPause;\r\n\tpathTracer.renderSample();\r\n\r\n\tif (\r\n\t\t! hdrGenerator.encoding &&\r\n\t\tparams.hdr &&\r\n\t\t( pathTracer.samples === MAX_SAMPLES || doPause ) &&\r\n\t\t! activeImage\r\n\t) {\r\n\r\n\t\t// NOTE: this can be called repeatedly but takes up to 200 ms\r\n\t\thdrGenerator.updateFrom( pathTracer.target );\r\n\t\tactiveImage = true;\r\n\r\n\t}\r\n\r\n\tif ( hdrGenerator.completeImage && params.hdr ) {\r\n\r\n\t\thdrGenerator.image.classList.add( 'show' );\r\n\r\n\t} else {\r\n\r\n\t\thdrGenerator.image.classList.remove( 'show' );\r\n\r\n\t}\r\n\r\n\tloader.setSamples( pathTracer.samples, pathTracer.isCompiling );\r\n\r\n}\r\n","import { compress, encode, findTextureMinMax } from '@monogrid/gainmap-js/dist/encode.js';\r\nimport { encodeJPEGMetadata } from '../libs/libultrahdr.js';\r\nimport { FloatType, LinearSRGBColorSpace, RGBAFormat } from 'three';\r\n\r\nexport class HDRImageGenerator {\r\n\r\n\tget completeImage() {\r\n\r\n\t\treturn this._lastUrl !== null;\r\n\r\n\t}\r\n\r\n\tconstructor( renderer, imageElement = new Image() ) {\r\n\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.image = imageElement;\r\n\t\tthis.encoding = false;\r\n\t\tthis._lastUrl = null;\r\n\t\tthis._encodingId = - 1;\r\n\r\n\t}\r\n\r\n\tasync updateFrom( renderTarget ) {\r\n\r\n\t\tif ( this.encoding ) {\r\n\r\n\t\t\tthrow new Error( 'HDRImageGenerator: HDR image already being encoded.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst renderer = this.renderer;\r\n\t\tconst buffer = new Float32Array( renderTarget.width * renderTarget.height * 4 );\r\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, renderTarget.width, renderTarget.height, buffer );\r\n\r\n\t\tconst imageInformation = {\r\n\t\t\theader: {},\r\n\t\t\twidth: renderTarget.width,\r\n\t\t\theight: renderTarget.height,\r\n\t\t\tdata: buffer,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tcolorSpace: LinearSRGBColorSpace,\r\n\t\t\ttype: FloatType,\r\n\r\n\t\t};\r\n\r\n\r\n\t\tthis._encodingId ++;\r\n\t\tthis.encoding = true;\r\n\r\n\t\tconst currentId = this._encodingId;\r\n\t\tconst jpegData = await encodeHDR( imageInformation );\r\n\r\n\t\tif ( this._encodingId === currentId ) {\r\n\r\n\t\t\tif ( this._lastUrl ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( this._lastUrl );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst blob = new Blob( [ jpegData ], { type: 'octet/stream' } );\r\n\t\t\tthis._lastUrl = URL.createObjectURL( blob );\r\n\t\t\tthis.image.src = this._lastUrl;\r\n\t\t\tthis.encoding = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tif ( this.encoding ) {\r\n\r\n\t\t\tthis.encoding = false;\r\n\t\t\tthis._encodingId ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this._lastUrl ) {\r\n\r\n\t\t\tURL.revokeObjectURL( this._lastUrl );\r\n\t\t\tthis.image.src = '';\r\n\t\t\tthis._lastUrl = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nasync function encodeHDR( image ) {\r\n\r\n\t// find RAW RGB Max value of a texture\r\n\tconst textureMax = await findTextureMinMax( image );\r\n\r\n\t// Encode the gainmap\r\n\tconst encodingResult = encode( {\r\n\t\timage,\r\n\t\t// this will encode the full HDR range\r\n\t\tmaxContentBoost: Math.max.apply( this, textureMax ) || 1\r\n\t} );\r\n\r\n\t// obtain the RAW RGBA SDR buffer and create an ImageData\r\n\tconst sdrImageData = new ImageData(\r\n\t\tencodingResult.sdr.toArray(),\r\n\t\tencodingResult.sdr.width,\r\n\t\tencodingResult.sdr.height\r\n\t);\r\n\t// obtain the RAW RGBA Gain map buffer and create an ImageData\r\n\tconst gainMapImageData = new ImageData(\r\n\t\tencodingResult.gainMap.toArray(),\r\n\t\tencodingResult.gainMap.width,\r\n\t\tencodingResult.gainMap.height\r\n\t);\r\n\r\n\t// parallel compress the RAW buffers into the specified mimeType\r\n\tconst mimeType = 'image/jpeg';\r\n\tconst quality = 0.9;\r\n\r\n\tconst [ sdr, gainMap ] = await Promise.all( [\r\n\t\tcompress( {\r\n\t\t\tsource: sdrImageData,\r\n\t\t\tmimeType,\r\n\t\t\tquality,\r\n\t\t\tflipY: true // output needs to be flipped\r\n\t\t} ),\r\n\t\tcompress( {\r\n\t\t\tsource: gainMapImageData,\r\n\t\t\tmimeType,\r\n\t\t\tquality,\r\n\t\t\tflipY: true // output needs to be flipped\r\n\t\t} )\r\n\t] );\r\n\r\n\t// obtain the metadata which will be embedded into\r\n\t// and XMP tag inside the final JPEG file\r\n\tconst metadata = encodingResult.getMetadata();\r\n\r\n\t// embed the compressed images + metadata into a single\r\n\t// JPEG file\r\n\tconst jpegBuffer = await encodeJPEGMetadata( {\r\n\t\t...encodingResult,\r\n\t\t...metadata,\r\n\t\tsdr,\r\n\t\tgainMap\r\n\t} );\r\n\r\n\treturn jpegBuffer;\r\n\r\n}\r\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { c as compress } from './compress-D7K92XO0.js';\nimport { DataTexture, RGBAFormat, UVMapping, RepeatWrapping, LinearFilter, LinearSRGBColorSpace, ShaderMaterial, Vector3, NoBlending, UnsignedByteType, ACESFilmicToneMapping, LinearToneMapping, CineonToneMapping, ReinhardToneMapping, SRGBColorSpace, Vector2, WebGLRenderTarget, NearestFilter, ClampToEdgeWrapping, FloatType, DataUtils } from 'three';\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\n\n/**\n * Utility function to obtain a `DataTexture` from various input formats\n *\n * @category Utility\n * @group Utility\n *\n * @param image\n * @returns\n */\nconst getDataTexture = (image) => {\n    let dataTexture;\n    if (image instanceof DataTexture) {\n        if (!(image.image.data instanceof Uint16Array) && !(image.image.data instanceof Float32Array)) {\n            throw new Error('Provided image is not HDR');\n        }\n        dataTexture = image;\n    }\n    else {\n        dataTexture = new DataTexture(image.data, image.width, image.height, 'format' in image ? image.format : RGBAFormat, image.type, UVMapping, RepeatWrapping, RepeatWrapping, LinearFilter, LinearFilter, 1, 'colorSpace' in image && image.colorSpace === 'srgb' ? image.colorSpace : LinearSRGBColorSpace);\n        // TODO: This tries to detect a raw RGBE and applies flipY\n        // see if there's a better way to detect it?\n        if ('header' in image && 'gamma' in image) {\n            dataTexture.flipY = true;\n        }\n        dataTexture.needsUpdate = true;\n    }\n    return dataTexture;\n};\n\nconst vertexShader$2 = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader$2 = /* glsl */ `\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform sampler2D sdr;\nuniform sampler2D hdr;\nuniform vec3 gamma;\nuniform vec3 offsetSdr;\nuniform vec3 offsetHdr;\nuniform float minLog2;\nuniform float maxLog2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 sdrColor = texture2D(sdr, vUv).rgb;\n  vec3 hdrColor = texture2D(hdr, vUv).rgb;\n\n  vec3 pixelGain = (hdrColor + offsetHdr) / (sdrColor + offsetSdr);\n  vec3 logRecovery = (log2(pixelGain) - minLog2) / (maxLog2 - minLog2);\n  vec3 clampedRecovery = saturate(logRecovery);\n  gl_FragColor = vec4(pow(clampedRecovery, gamma), 1.0);\n}\n`;\n/**\n * A Material which is able to encode a gainmap\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapEncoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ sdr, hdr, offsetSdr, offsetHdr, maxContentBoost, minContentBoost, gamma }) {\n        if (!maxContentBoost)\n            throw new Error('maxContentBoost is required');\n        if (!sdr)\n            throw new Error('sdr is required');\n        if (!hdr)\n            throw new Error('hdr is required');\n        const _gamma = gamma || [1, 1, 1];\n        const _offsetSdr = offsetSdr || [1 / 64, 1 / 64, 1 / 64];\n        const _offsetHdr = offsetHdr || [1 / 64, 1 / 64, 1 / 64];\n        const _minContentBoost = minContentBoost || 1;\n        const _maxContentBoost = Math.max(maxContentBoost, 1.0001);\n        super({\n            name: 'GainMapEncoderMaterial',\n            vertexShader: vertexShader$2,\n            fragmentShader: fragmentShader$2,\n            uniforms: {\n                sdr: { value: sdr },\n                hdr: { value: hdr },\n                gamma: { value: new Vector3().fromArray(_gamma) },\n                offsetSdr: { value: new Vector3().fromArray(_offsetSdr) },\n                offsetHdr: { value: new Vector3().fromArray(_offsetHdr) },\n                minLog2: { value: Math.log2(_minContentBoost) },\n                maxLog2: { value: Math.log2(_maxContentBoost) }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._minContentBoost = _minContentBoost;\n        this._maxContentBoost = _maxContentBoost;\n        this._offsetSdr = _offsetSdr;\n        this._offsetHdr = _offsetHdr;\n        this._gamma = _gamma;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.gamma}\n     */\n    get gamma() { return this._gamma; }\n    set gamma(value) {\n        this._gamma = value;\n        this.uniforms.gamma.value = new Vector3().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.offsetHdr}\n     */\n    get offsetHdr() { return this._offsetHdr; }\n    set offsetHdr(value) {\n        this._offsetHdr = value;\n        this.uniforms.offsetHdr.value = new Vector3().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.offsetSdr}\n     */\n    get offsetSdr() { return this._offsetSdr; }\n    set offsetSdr(value) {\n        this._offsetSdr = value;\n        this.uniforms.offsetSdr.value = new Vector3().fromArray(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.minContentBoost}\n     * @remarks Non logarithmic space\n     */\n    get minContentBoost() { return this._minContentBoost; }\n    set minContentBoost(value) {\n        this._minContentBoost = value;\n        this.uniforms.minLog2.value = Math.log2(value);\n    }\n    /**\n     * @see {@link GainmapEncodingParameters.maxContentBoost}\n     * @remarks Non logarithmic space\n     */\n    get maxContentBoost() { return this._maxContentBoost; }\n    set maxContentBoost(value) {\n        this._maxContentBoost = value;\n        this.uniforms.maxLog2.value = Math.log2(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     * @remarks Logarithmic space\n     */\n    get gainMapMin() { return [Math.log2(this._minContentBoost), Math.log2(this._minContentBoost), Math.log2(this._minContentBoost)]; }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     * @remarks Logarithmic space\n     */\n    get gainMapMax() { return [Math.log2(this._maxContentBoost), Math.log2(this._maxContentBoost), Math.log2(this._maxContentBoost)]; }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return Math.min(Math.max(0, this.gainMapMin[0]), Math.max(0, this.gainMapMin[1]), Math.max(0, this.gainMapMin[2])); }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMax}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return Math.max(Math.max(0, this.gainMapMax[0]), Math.max(0, this.gainMapMax[1]), Math.max(0, this.gainMapMax[2])); }\n}\n\n/**\n *\n * @param params\n * @returns\n * @category Encoding Functions\n * @group Encoding Functions\n */\nconst getGainMap = (params) => {\n    const { image, sdr, renderer } = params;\n    const dataTexture = getDataTexture(image);\n    const material = new GainMapEncoderMaterial({\n        ...params,\n        sdr: sdr.renderTarget.texture,\n        hdr: dataTexture\n    });\n    const quadRenderer = new QuadRenderer({\n        width: dataTexture.image.width,\n        height: dataTexture.image.height,\n        type: UnsignedByteType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nconst vertexShader$1 = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader$1 = /* glsl */ `\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform sampler2D map;\nuniform float brightness;\nuniform float contrast;\nuniform float saturation;\nuniform float exposure;\n\nvarying vec2 vUv;\n\nmat4 brightnessMatrix( float brightness ) {\n  return mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    brightness, brightness, brightness, 1\n  );\n}\n\nmat4 contrastMatrix( float contrast ) {\n  float t = ( 1.0 - contrast ) / 2.0;\n  return mat4(\n    contrast, 0, 0, 0,\n    0, contrast, 0, 0,\n    0, 0, contrast, 0,\n    t, t, t, 1\n  );\n}\n\nmat4 saturationMatrix( float saturation ) {\n  vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n  float oneMinusSat = 1.0 - saturation;\n  vec3 red = vec3( luminance.x * oneMinusSat );\n  red+= vec3( saturation, 0, 0 );\n  vec3 green = vec3( luminance.y * oneMinusSat );\n  green += vec3( 0, saturation, 0 );\n  vec3 blue = vec3( luminance.z * oneMinusSat );\n  blue += vec3( 0, 0, saturation );\n  return mat4(\n    red,     0,\n    green,   0,\n    blue,    0,\n    0, 0, 0, 1\n  );\n}\n\nvec3 RRTAndODTFit( vec3 v ) {\n  vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n  vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n  return a / b;\n}\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const mat3 ACESInputMat = mat3(\n    vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n    vec3( 0.35458, 0.90834, 0.13383 ),\n    vec3( 0.04823, 0.01566, 0.83777 )\n  );\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const mat3 ACESOutputMat = mat3(\n    vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n    vec3( -0.53108,  1.10813, -0.07276 ),\n    vec3( -0.07367, -0.00605,  1.07602 )\n  );\n  color = ACESInputMat * color;\n  // Apply RRT and ODT\n  color = RRTAndODTFit( color );\n  color = ACESOutputMat * color;\n  // Clamp to [0, 1]\n  return saturate( color );\n}\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\nvec3 ReinhardToneMapping( vec3 color ) {\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 CineonToneMapping( vec3 color ) {\n  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n\n// nothing\nvec3 LinearToneMapping ( vec3 color ) {\n  return color;\n}\n\n\nvoid main() {\n  vec4 color = texture2D(map, vUv);\n\n  vec4 exposed = vec4(exposure * color.rgb, color.a);\n\n  vec4 tonemapped = vec4(TONEMAPPING_FUNCTION(exposed.rgb), color.a);\n\n  vec4 adjusted =\n    brightnessMatrix( brightness ) *\n    contrastMatrix( contrast ) *\n    saturationMatrix( saturation ) *\n    tonemapped;\n\n  gl_FragColor = adjusted;\n}\n`;\n/**\n * A Material used to adjust the SDR representation of an HDR image\n *\n * @category Materials\n * @group Materials\n */\nclass SDRMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ map, toneMapping }) {\n        super({\n            name: 'SDRMaterial',\n            vertexShader: vertexShader$1,\n            fragmentShader: fragmentShader$1,\n            uniforms: {\n                map: { value: map },\n                brightness: { value: 0 },\n                contrast: { value: 1 },\n                saturation: { value: 1 },\n                exposure: { value: 1 }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._brightness = 0;\n        this._contrast = 1;\n        this._saturation = 1;\n        this._exposure = 1;\n        this._map = map;\n        this.toneMapping = this._toneMapping = toneMapping || ACESFilmicToneMapping;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get toneMapping() { return this._toneMapping; }\n    set toneMapping(value) {\n        let valid = false;\n        switch (value) {\n            case ACESFilmicToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = 'ACESFilmicToneMapping';\n                valid = true;\n                break;\n            case ReinhardToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = 'ReinhardToneMapping';\n                valid = true;\n                break;\n            case CineonToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = 'CineonToneMapping';\n                valid = true;\n                break;\n            case LinearToneMapping:\n                this.defines.TONEMAPPING_FUNCTION = 'LinearToneMapping';\n                valid = true;\n                break;\n            default:\n                console.error(`Unsupported toneMapping: ${value}. Using LinearToneMapping.`);\n                this.defines.TONEMAPPING_FUNCTION = 'LinearToneMapping';\n                this._toneMapping = LinearToneMapping;\n        }\n        if (valid) {\n            this._toneMapping = value;\n        }\n        this.needsUpdate = true;\n    }\n    get brightness() { return this._brightness; }\n    set brightness(value) {\n        this._brightness = value;\n        this.uniforms.brightness.value = value;\n    }\n    get contrast() { return this._contrast; }\n    set contrast(value) {\n        this._contrast = value;\n        this.uniforms.contrast.value = value;\n    }\n    get saturation() { return this._saturation; }\n    set saturation(value) {\n        this._saturation = value;\n        this.uniforms.saturation.value = value;\n    }\n    get exposure() { return this._exposure; }\n    set exposure(value) {\n        this._exposure = value;\n        this.uniforms.exposure.value = value;\n    }\n    get map() { return this._map; }\n    set map(value) {\n        this._map = value;\n        this.uniforms.map.value = value;\n    }\n}\n\n/**\n * Renders an SDR Representation of an HDR Image\n *\n * @category Encoding Functions\n * @group Encoding Functions\n *\n * @param hdrTexture The HDR image to be rendered\n * @param renderer (optional) WebGLRenderer to use during the rendering, a disposable renderer will be create and destroyed if this is not provided.\n * @param toneMapping (optional) Tone mapping to be applied to the SDR Rendition\n * @param renderTargetOptions (optional) Options to use when creating the output renderTarget\n * @throws {Error} if the WebGLRenderer fails to render the SDR image\n */\nconst getSDRRendition = (hdrTexture, renderer, toneMapping, renderTargetOptions) => {\n    hdrTexture.needsUpdate = true;\n    const quadRenderer = new QuadRenderer({\n        width: hdrTexture.image.width,\n        height: hdrTexture.image.height,\n        type: UnsignedByteType,\n        colorSpace: SRGBColorSpace,\n        material: new SDRMaterial({ map: hdrTexture, toneMapping }),\n        renderer,\n        renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\n/**\n * Encodes a Gainmap starting from an HDR file.\n *\n * @remarks\n * if you do not pass a `renderer` parameter\n * you must manually dispose the result\n * ```js\n * const encodingResult = await encode({ ... })\n * // do something with the buffers\n * const sdr = encodingResult.sdr.getArray()\n * const gainMap = encodingResult.gainMap.getArray()\n * // after that\n * encodingResult.sdr.dispose()\n * encodingResult.gainMap.dispose()\n * ```\n *\n * @category Encoding Functions\n * @group Encoding Functions\n *\n * @example\n * import { encode, findTextureMinMax } from '@monogrid/gainmap-js'\n * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\n *\n * // load an HDR file\n * const loader = new EXRLoader()\n * const image = await loader.loadAsync('image.exr')\n *\n * // find RAW RGB Max value of a texture\n * const textureMax = await findTextureMinMax(image)\n *\n * // Encode the gainmap\n * const encodingResult = encode({\n *   image,\n *   // this will encode the full HDR range\n *   maxContentBoost: Math.max.apply(this, textureMax)\n * })\n * // can be re-encoded after changing parameters\n * encodingResult.sdr.material.exposure = 0.9\n * encodingResult.sdr.render()\n * // or\n * encodingResult.gainMap.material.gamma = [1.1, 1.1, 1.1]\n * encodingResult.gainMap.render()\n *\n * // do something with encodingResult.gainMap.toArray()\n * // and encodingResult.sdr.toArray()\n *\n * // renderers must be manually disposed\n * encodingResult.sdr.dispose()\n * encodingResult.gainMap.dispose()\n *\n * @param params Encoding Parameters\n * @returns\n */\nconst encode = (params) => {\n    const { image, renderer } = params;\n    const dataTexture = getDataTexture(image);\n    const sdr = getSDRRendition(dataTexture, renderer, params.toneMapping, params.renderTargetOptions);\n    const gainMapRenderer = getGainMap({\n        ...params,\n        image: dataTexture,\n        sdr,\n        renderer: sdr.renderer // reuse the same (maybe disposable?) renderer\n    });\n    return {\n        sdr,\n        gainMap: gainMapRenderer,\n        hdr: dataTexture,\n        getMetadata: () => {\n            return {\n                gainMapMax: gainMapRenderer.material.gainMapMax,\n                gainMapMin: gainMapRenderer.material.gainMapMin,\n                gamma: gainMapRenderer.material.gamma,\n                hdrCapacityMax: gainMapRenderer.material.hdrCapacityMax,\n                hdrCapacityMin: gainMapRenderer.material.hdrCapacityMin,\n                offsetHdr: gainMapRenderer.material.offsetHdr,\n                offsetSdr: gainMapRenderer.material.offsetSdr\n            };\n        }\n    };\n};\n\n/**\n * Encodes a Gainmap starting from an HDR file into compressed file formats (`image/jpeg`, `image/webp` or `image/png`).\n *\n * Uses {@link encode} internally, then pipes the results to {@link compress}.\n *\n * @remarks\n * if a `renderer` parameter is not provided\n * This function will automatically dispose its \"disposable\"\n * renderer, no need to dispose it manually later\n *\n * @category Encoding Functions\n * @group Encoding Functions\n * @example\n * import { encodeAndCompress, findTextureMinMax } from '@monogrid/gainmap-js'\n * import { encodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\n * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\n *\n * // load an HDR file\n * const loader = new EXRLoader()\n * const image = await loader.loadAsync('image.exr')\n *\n * // find RAW RGB Max value of a texture\n * const textureMax = await findTextureMinMax(image)\n *\n * // Encode the gainmap\n * const encodingResult = await encodeAndCompress({\n *   image,\n *   maxContentBoost: Math.max.apply(this, textureMax),\n *   mimeType: 'image/jpeg'\n * })\n *\n * // embed the compressed images + metadata into a single\n * // JPEG file\n * const jpeg = await encodeJPEGMetadata({\n *   ...encodingResult,\n *   sdr: encodingResult.sdr,\n *   gainMap: encodingResult.gainMap\n * })\n *\n * // `jpeg` will be an `Uint8Array` which can be saved somewhere\n *\n *\n * @param params Encoding Parameters\n * @throws {Error} if the browser does not support [createImageBitmap](https://caniuse.com/createimagebitmap)\n */\nconst encodeAndCompress = async (params) => {\n    const encodingResult = encode(params);\n    const { mimeType, quality, flipY, withWorker } = params;\n    let compressResult;\n    let rawSDR;\n    let rawGainMap;\n    const sdrImageData = new ImageData(encodingResult.sdr.toArray(), encodingResult.sdr.width, encodingResult.sdr.height);\n    const gainMapImageData = new ImageData(encodingResult.gainMap.toArray(), encodingResult.gainMap.width, encodingResult.gainMap.height);\n    if (withWorker) {\n        const workerResult = await Promise.all([\n            withWorker.compress({\n                source: sdrImageData,\n                mimeType,\n                quality,\n                flipY\n            }),\n            withWorker.compress({\n                source: gainMapImageData,\n                mimeType,\n                quality,\n                flipY\n            })\n        ]);\n        compressResult = workerResult;\n        rawSDR = workerResult[0].source;\n        rawGainMap = workerResult[1].source;\n    }\n    else {\n        compressResult = await Promise.all([\n            compress({\n                source: sdrImageData,\n                mimeType,\n                quality,\n                flipY\n            }),\n            compress({\n                source: gainMapImageData,\n                mimeType,\n                quality,\n                flipY\n            })\n        ]);\n        rawSDR = sdrImageData.data;\n        rawGainMap = gainMapImageData.data;\n    }\n    encodingResult.sdr.dispose();\n    encodingResult.gainMap.dispose();\n    return {\n        ...encodingResult,\n        ...encodingResult.getMetadata(),\n        sdr: compressResult[0],\n        gainMap: compressResult[1],\n        rawSDR,\n        rawGainMap\n    };\n};\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\nprecision mediump float;\n\n#ifndef CELL_SIZE\n  #define CELL_SIZE 2\n#endif\n\n#ifndef COMPARE_FUNCTION\n  #define COMPARE_FUNCTION max\n#endif\n\n#ifndef INITIAL_VALUE\n  #define INITIAL_VALUE 0\n#endif\n\nuniform sampler2D map;\nuniform vec2 u_srcResolution;\n\nvarying vec2 vUv;\n\nvoid main() {\n  // compute the first pixel the source cell\n  vec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\n\n  // one pixel in source\n  vec2 onePixel = vec2(1) / u_srcResolution;\n\n  // uv for first pixel in cell. +0.5 for center of pixel\n  vec2 uv = (srcPixel + 0.5) * onePixel;\n\n  vec4 resultColor = vec4(INITIAL_VALUE);\n\n  for (int y = 0; y < CELL_SIZE; ++y) {\n    for (int x = 0; x < CELL_SIZE; ++x) {\n      resultColor = COMPARE_FUNCTION(resultColor, texture2D(map, uv + vec2(x, y) * onePixel));\n    }\n  }\n\n  gl_FragColor = resultColor;\n}\n`;\n/**\n *\n * @category Utility\n * @group Utility\n *\n * @param srcTex\n * @param mode\n * @param renderer\n * @returns\n */\nconst findTextureMinMax = (image, mode = 'max', renderer) => {\n    const srcTex = getDataTexture(image);\n    const cellSize = 2;\n    const mat = new ShaderMaterial({\n        vertexShader,\n        fragmentShader,\n        uniforms: {\n            u_srcResolution: { value: new Vector2(srcTex.image.width, srcTex.image.height) },\n            map: { value: srcTex }\n        },\n        defines: {\n            CELL_SIZE: cellSize,\n            COMPARE_FUNCTION: mode,\n            INITIAL_VALUE: mode === 'max' ? 0 : 65504 // max half float value\n        }\n    });\n    srcTex.needsUpdate = true;\n    mat.needsUpdate = true;\n    let w = srcTex.image.width;\n    let h = srcTex.image.height;\n    const quadRenderer = new QuadRenderer({\n        width: w,\n        height: h,\n        type: srcTex.type,\n        colorSpace: srcTex.colorSpace,\n        material: mat,\n        renderer\n    });\n    const frameBuffers = [];\n    while (w > 1 || h > 1) {\n        w = Math.max(1, (w + cellSize - 1) / cellSize | 0);\n        h = Math.max(1, (h + cellSize - 1) / cellSize | 0);\n        const fb = new WebGLRenderTarget(w, h, {\n            type: quadRenderer.type,\n            format: srcTex.format,\n            colorSpace: quadRenderer.colorSpace,\n            minFilter: NearestFilter,\n            magFilter: NearestFilter,\n            wrapS: ClampToEdgeWrapping,\n            wrapT: ClampToEdgeWrapping,\n            generateMipmaps: false,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n        frameBuffers.push(fb);\n    }\n    w = srcTex.image.width;\n    h = srcTex.image.height;\n    frameBuffers.forEach((fbi) => {\n        w = Math.max(1, (w + cellSize - 1) / cellSize | 0);\n        h = Math.max(1, (h + cellSize - 1) / cellSize | 0);\n        quadRenderer.renderTarget = fbi;\n        quadRenderer.render();\n        mat.uniforms.map.value = fbi.texture;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        mat.uniforms.u_srcResolution.value.x = w;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        mat.uniforms.u_srcResolution.value.y = h;\n    });\n    const out = quadRenderer.toArray();\n    quadRenderer.dispose();\n    frameBuffers.forEach(fb => fb.dispose());\n    return [\n        quadRenderer.type === FloatType ? out[0] : DataUtils.fromHalfFloat(out[0]),\n        quadRenderer.type === FloatType ? out[1] : DataUtils.fromHalfFloat(out[1]),\n        quadRenderer.type === FloatType ? out[2] : DataUtils.fromHalfFloat(out[2])\n    ];\n};\n\nexport { GainMapEncoderMaterial, SDRMaterial, compress, encode, encodeAndCompress, findTextureMinMax, getGainMap, getSDRRendition };\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\n/**\n * Used internally\n *\n * @internal\n * @param canvas\n * @param mimeType\n * @param quality\n * @returns\n */\nconst canvasToBlob = async (canvas, mimeType, quality) => {\n    if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return canvas.convertToBlob({ type: mimeType, quality: quality || 0.9 });\n    }\n    else if (canvas instanceof HTMLCanvasElement) {\n        return new Promise((resolve, reject) => {\n            canvas.toBlob((res) => {\n                if (res)\n                    resolve(res);\n                else\n                    reject(new Error('Failed to convert canvas to blob'));\n            }, mimeType, quality || 0.9);\n        });\n    }\n    /* istanbul ignore next\n      as long as this function is not exported this is only here\n      to satisfy TS strict mode internally\n    */\n    throw new Error('Unsupported canvas element');\n};\n/**\n * Converts a RAW RGBA image buffer into the provided `mimeType` using the provided `quality`\n *\n * @category Compression\n * @group Compression\n * @param params\n * @throws {Error} if the browser does not support [createImageBitmap](https://caniuse.com/createimagebitmap)\n * @throws {Error} if the provided source image cannot be decoded\n * @throws {Error} if the function fails to create a canvas context\n */\nconst compress = async (params) => {\n    if (typeof createImageBitmap === 'undefined')\n        throw new Error('createImageBitmap() not supported.');\n    const { source, mimeType, quality, flipY } = params;\n    // eslint-disable-next-line no-undef\n    let imageBitmapSource;\n    if ((source instanceof Uint8Array || source instanceof Uint8ClampedArray) && 'sourceMimeType' in params) {\n        imageBitmapSource = new Blob([source], { type: params.sourceMimeType });\n    }\n    else if (source instanceof ImageData) {\n        imageBitmapSource = source;\n    }\n    else {\n        throw new Error('Invalid source image');\n    }\n    const img = await createImageBitmap(imageBitmapSource);\n    const width = img.width;\n    const height = img.height;\n    let canvas;\n    if (typeof OffscreenCanvas !== 'undefined') {\n        canvas = new OffscreenCanvas(width, height);\n    }\n    else {\n        canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n    }\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        throw new Error('Failed to create canvas Context');\n    // flip Y\n    if (flipY === true) {\n        ctx.translate(0, height);\n        ctx.scale(1, -1);\n    }\n    ctx.drawImage(img, 0, 0, width, height);\n    const blob = await canvasToBlob(canvas, mimeType, quality || 0.9);\n    const data = new Uint8Array(await blob.arrayBuffer());\n    return {\n        data,\n        mimeType,\n        width,\n        height\n    };\n};\n\nexport { compress as c };\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n","/* eslint-disable */\r\n// NOTE: modified version of monogrid source file to patch it\r\n// so it works with parcel\r\n\r\n/**\r\n * @monogrid/gainmap-js v3.0.5\r\n * With , by MONOGRID <rnd@monogrid.com>\r\n */\r\n\r\nvar Module = (() => {\r\n\tvar _scriptDir = import.meta.url;\r\n\r\n\treturn (\r\n  async function(moduleArg = {}) {\r\n\r\n  // include: shell.js\r\n  // The Module object: Our interface to the outside world. We import\r\n  // and export values on it. There are various ways Module can be used:\r\n  // 1. Not defined. We create it here\r\n  // 2. A function parameter, function(Module) { ..generated code.. }\r\n  // 3. pre-run appended it, var Module = {}; ..generated code..\r\n  // 4. External script tag defines var Module.\r\n  // We need to check if Module already exists (e.g. case 3 above).\r\n  // Substitution will be replaced with actual code on later stage of the build,\r\n  // this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n  // Note that if you want to run closure, and also to use Module\r\n  // after the generated code, you will need to define   var Module = {};\r\n  // before the code. Then that object will be used in the code, and you\r\n  // can continue to use Module afterwards as well.\r\n  var Module = moduleArg;\r\n\r\n  // Set up the promise that indicates the Module is initialized\r\n  var readyPromiseResolve, readyPromiseReject;\r\n  Module['ready'] = new Promise((resolve, reject) => {\r\n\treadyPromiseResolve = resolve;\r\n\treadyPromiseReject = reject;\r\n  });\r\n  [\"_main\",\"_memory\",\"___indirect_function_table\",\"__embind_initialize_bindings\",\"_fflush\",\"onRuntimeInitialized\"].forEach((prop) => {\r\n\tif (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {\r\n\t  Object.defineProperty(Module['ready'], prop, {\r\n\t\tget: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n\t\tset: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n\t  });\r\n\t}\r\n  });\r\n\r\n  // --pre-jses are emitted after the Module integration code, so that they can\r\n  // refer to Module (if they choose; they can also define Module)\r\n\r\n\r\n  // Sometimes an existing Module object exists with properties\r\n  // meant to overwrite the default module functionality. Here\r\n  // we collect those properties and reapply _after_ we configure\r\n  // the current environment's defaults to avoid having to be so\r\n  // defensive during initialization.\r\n  var moduleOverrides = Object.assign({}, Module);\r\n  var thisProgram = './this.program';\r\n  var quit_ = (status, toThrow) => {\r\n\tthrow toThrow;\r\n  };\r\n\r\n  // Determine the runtime environment we are in. You can customize this by\r\n  // setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\n  // Attempt to auto-detect the environment\r\n  var ENVIRONMENT_IS_WEB = typeof window == 'object';\r\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\r\n  // N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n  // also a web environment.\r\n  var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\r\n  var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\n  if (Module['ENVIRONMENT']) {\r\n\tthrow new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\r\n  }\r\n\r\n  // `/` should be present at the end if `scriptDirectory` is not empty\r\n  var scriptDirectory = '';\r\n  function locateFile(path) {\r\n\tif (Module['locateFile']) {\r\n\t  return Module['locateFile'](path, scriptDirectory);\r\n\t}\r\n\treturn scriptDirectory + path;\r\n  }\r\n\r\n  // Hooks that are implemented differently in different runtime environments.\r\n  var read_,\r\n\t  readAsync,\r\n\t  readBinary;\r\n\r\n  if (ENVIRONMENT_IS_NODE) {\r\n\tif (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n\tvar nodeVersion = process.versions.node;\r\n\tvar numericVersion = nodeVersion.split('.').slice(0, 3);\r\n\tnumericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);\r\n\tif (numericVersion < 160000) {\r\n\t  throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');\r\n\t}\r\n\r\n\t// `require()` is no-op in an ESM module, use `createRequire()` to construct\r\n\t// the require()` function.  This is only necessary for multi-environment\r\n\t// builds, `-sENVIRONMENT=node` emits a static import declaration instead.\r\n\t// TODO: Swap all `require()`'s with `import()`'s?\r\n\tconst { createRequire } = await import('module');\r\n\t/** @suppress{duplicate} */\r\n\tvar require = createRequire(import.meta.url);\r\n\t// These modules will usually be used on Node.js. Load them eagerly to avoid\r\n\t// the complexity of lazy-loading.\r\n\tvar fs = require('fs');\r\n\tvar nodePath = require('path');\r\n\r\n\tif (ENVIRONMENT_IS_WORKER) {\r\n\t  scriptDirectory = nodePath.dirname(scriptDirectory) + '/';\r\n\t} else {\r\n\t  // EXPORT_ES6 + ENVIRONMENT_IS_NODE always requires use of import.meta.url,\r\n\t  // since there's no way getting the current absolute path of the module when\r\n\t  // support for that is not available.\r\n\t//   scriptDirectory = require('url').fileURLToPath(new URL('./', import.meta.url)); // includes trailing slash\r\n\t}\r\n\r\n  // include: node_shell_read.js\r\n  read_ = (filename, binary) => {\r\n\t// We need to re-wrap `file://` strings to URLs. Normalizing isn't\r\n\t// necessary in that case, the path should already be absolute.\r\n\tfilename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n\treturn fs.readFileSync(filename, binary ? undefined : 'utf8');\r\n  };\r\n\r\n  readBinary = (filename) => {\r\n\tvar ret = read_(filename, true);\r\n\tif (!ret.buffer) {\r\n\t  ret = new Uint8Array(ret);\r\n\t}\r\n\tassert(ret.buffer);\r\n\treturn ret;\r\n  };\r\n\r\n  readAsync = (filename, onload, onerror, binary = true) => {\r\n\t// See the comment in the `read_` function.\r\n\tfilename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n\tfs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\r\n\t  if (err) onerror(err);\r\n\t  else onload(binary ? data.buffer : data);\r\n\t});\r\n  };\r\n  // end include: node_shell_read.js\r\n\tif (!Module['thisProgram'] && process.argv.length > 1) {\r\n\t  thisProgram = process.argv[1].replace(/\\\\/g, '/');\r\n\t}\r\n\r\n\tprocess.argv.slice(2);\r\n\r\n\t// MODULARIZE will export the module in the proper place outside, we don't need to export here\r\n\r\n\tquit_ = (status, toThrow) => {\r\n\t  process.exitCode = status;\r\n\t  throw toThrow;\r\n\t};\r\n\r\n\tModule['inspect'] = () => '[Emscripten Module object]';\r\n\r\n  } else\r\n  if (ENVIRONMENT_IS_SHELL) {\r\n\r\n\tif ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n\tif (typeof read != 'undefined') {\r\n\t  read_ = read;\r\n\t}\r\n\r\n\treadBinary = (f) => {\r\n\t  if (typeof readbuffer == 'function') {\r\n\t\treturn new Uint8Array(readbuffer(f));\r\n\t  }\r\n\t  let data = read(f, 'binary');\r\n\t  assert(typeof data == 'object');\r\n\t  return data;\r\n\t};\r\n\r\n\treadAsync = (f, onload, onerror) => {\r\n\t  setTimeout(() => onload(readBinary(f)));\r\n\t};\r\n\r\n\tif (typeof clearTimeout == 'undefined') {\r\n\t  globalThis.clearTimeout = (id) => {};\r\n\t}\r\n\r\n\tif (typeof setTimeout == 'undefined') {\r\n\t  // spidermonkey lacks setTimeout but we use it above in readAsync.\r\n\t  globalThis.setTimeout = (f) => (typeof f == 'function') ? f() : abort();\r\n\t}\r\n\r\n\tif (typeof scriptArgs != 'undefined') {\r\n\t  scriptArgs;\r\n\t}\r\n\r\n\tif (typeof quit == 'function') {\r\n\t  quit_ = (status, toThrow) => {\r\n\t\t// Unlike node which has process.exitCode, d8 has no such mechanism. So we\r\n\t\t// have no way to set the exit code and then let the program exit with\r\n\t\t// that code when it naturally stops running (say, when all setTimeouts\r\n\t\t// have completed). For that reason, we must call `quit` - the only way to\r\n\t\t// set the exit code - but quit also halts immediately.  To increase\r\n\t\t// consistency with node (and the web) we schedule the actual quit call\r\n\t\t// using a setTimeout to give the current stack and any exception handlers\r\n\t\t// a chance to run.  This enables features such as addOnPostRun (which\r\n\t\t// expected to be able to run code after main returns).\r\n\t\tsetTimeout(() => {\r\n\t\t  if (!(toThrow instanceof ExitStatus)) {\r\n\t\t\tlet toLog = toThrow;\r\n\t\t\tif (toThrow && typeof toThrow == 'object' && toThrow.stack) {\r\n\t\t\t  toLog = [toThrow, toThrow.stack];\r\n\t\t\t}\r\n\t\t\terr(`exiting due to exception: ${toLog}`);\r\n\t\t  }\r\n\t\t  quit(status);\r\n\t\t});\r\n\t\tthrow toThrow;\r\n\t  };\r\n\t}\r\n\r\n\tif (typeof print != 'undefined') {\r\n\t  // Prefer to use print/printErr where they exist, as they usually work better.\r\n\t  if (typeof console == 'undefined') console = /** @type{!Console} */({});\r\n\t  console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\r\n\t  console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);\r\n\t}\r\n\r\n  } else\r\n\r\n  // Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n  // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n  // ENVIRONMENT_IS_NODE.\r\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n\tif (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n\t  scriptDirectory = self.location.href;\r\n\t} else if (typeof document != 'undefined' && document.currentScript) { // web\r\n\t  scriptDirectory = document.currentScript.src;\r\n\t}\r\n\t// When MODULARIZE, this JS may be executed later, after document.currentScript\r\n\t// is gone, so we saved it, and we use it here instead of any other info.\r\n\tif (_scriptDir) {\r\n\t  scriptDirectory = _scriptDir;\r\n\t}\r\n\t// blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n\t// otherwise, slice off the final part of the url to find the script directory.\r\n\t// if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n\t// and scriptDirectory will correctly be replaced with an empty string.\r\n\t// If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n\t// they are removed because they could contain a slash.\r\n\tif (scriptDirectory.indexOf('blob:') !== 0) {\r\n\t  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\r\n\t} else {\r\n\t  scriptDirectory = '';\r\n\t}\r\n\r\n\tif (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n\t// Differentiate the Web Worker from the Node Worker case, as reading must\r\n\t// be done differently.\r\n\t{\r\n  // include: web_or_worker_shell_read.js\r\n  read_ = (url) => {\r\n\t  var xhr = new XMLHttpRequest();\r\n\t  xhr.open('GET', url, false);\r\n\t  xhr.send(null);\r\n\t  return xhr.responseText;\r\n\t};\r\n\r\n\tif (ENVIRONMENT_IS_WORKER) {\r\n\t  readBinary = (url) => {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\txhr.open('GET', url, false);\r\n\t\txhr.responseType = 'arraybuffer';\r\n\t\txhr.send(null);\r\n\t\treturn new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n\t  };\r\n\t}\r\n\r\n\treadAsync = (url, onload, onerror) => {\r\n\t  var xhr = new XMLHttpRequest();\r\n\t  xhr.open('GET', url, true);\r\n\t  xhr.responseType = 'arraybuffer';\r\n\t  xhr.onload = () => {\r\n\t\tif (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n\t\t  onload(xhr.response);\r\n\t\t  return;\r\n\t\t}\r\n\t\tonerror();\r\n\t  };\r\n\t  xhr.onerror = onerror;\r\n\t  xhr.send(null);\r\n\t};\r\n\r\n  // end include: web_or_worker_shell_read.js\r\n\t}\r\n  } else\r\n  {\r\n\tthrow new Error('environment detection error');\r\n  }\r\n\r\n  var out = Module['print'] || console.log.bind(console);\r\n  var err = Module['printErr'] || console.error.bind(console);\r\n\r\n  // Merge back in the overrides\r\n  Object.assign(Module, moduleOverrides);\r\n  // Free the object hierarchy contained in the overrides, this lets the GC\r\n  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\n  moduleOverrides = null;\r\n  checkIncomingModuleAPI();\r\n\r\n  // Emit code to handle expected values on the Module object. This applies Module.x\r\n  // to the proper local x. This has two benefits: first, we only emit it if it is\r\n  // expected to arrive, and second, by using a local everywhere else that can be\r\n  // minified.\r\n\r\n  if (Module['arguments']) Module['arguments'];legacyModuleProp('arguments', 'arguments_');\r\n\r\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\r\n\r\n  if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');\r\n\r\n  // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n  // Assertions on removed incoming Module JS APIs.\r\n  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\r\n  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\r\n  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\r\n  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\r\n  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');\r\n  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\r\n  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\r\n  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\r\n  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\r\n  legacyModuleProp('asm', 'wasmExports');\r\n  legacyModuleProp('read', 'read_');\r\n  legacyModuleProp('readAsync', 'readAsync');\r\n  legacyModuleProp('readBinary', 'readBinary');\r\n  legacyModuleProp('setWindowTitle', 'setWindowTitle');\r\n\r\n  assert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\r\n\r\n\r\n  // end include: shell.js\r\n  // include: preamble.js\r\n  // === Preamble library stuff ===\r\n\r\n  // Documentation for the public APIs defined in this file must be updated in:\r\n  //    site/source/docs/api_reference/preamble.js.rst\r\n  // A prebuilt local version of the documentation is available at:\r\n  //    site/build/text/docs/api_reference/preamble.js.txt\r\n  // You can also build docs locally as HTML or other formats in site/\r\n  // An online HTML version (which may be of a different version of Emscripten)\r\n  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\n  var wasmBinary;\r\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\r\n\r\n  if (typeof WebAssembly != 'object') {\r\n\tabort('no native wasm support detected');\r\n  }\r\n\r\n  // Wasm globals\r\n\r\n  var wasmMemory;\r\n\r\n  //========================================\r\n  // Runtime essentials\r\n  //========================================\r\n\r\n  // whether we are quitting the application. no code should run after this.\r\n  // set in exit() and abort()\r\n  var ABORT = false;\r\n\r\n  // set by exit() and abort().  Passed to 'onExit' handler.\r\n  // NOTE: This is also used as the process return code code in shell environments\r\n  // but only when noExitRuntime is false.\r\n  var EXITSTATUS;\r\n\r\n  /** @type {function(*, string=)} */\r\n  function assert(condition, text) {\r\n\tif (!condition) {\r\n\t  abort('Assertion failed' + (text ? ': ' + text : ''));\r\n\t}\r\n  }\r\n\r\n  // We used to include malloc/free by default in the past. Show a helpful error in\r\n  // builds with assertions.\r\n\r\n  // Memory management\r\n\r\n  var /** @type {!Int8Array} */\r\n\tHEAP8,\r\n  /** @type {!Uint8Array} */\r\n\tHEAPU8,\r\n  /** @type {!Int16Array} */\r\n\tHEAP16,\r\n  /** @type {!Uint16Array} */\r\n\tHEAPU16,\r\n  /** @type {!Int32Array} */\r\n\tHEAP32,\r\n  /** @type {!Uint32Array} */\r\n\tHEAPU32,\r\n  /** @type {!Float32Array} */\r\n\tHEAPF32,\r\n  /** @type {!Float64Array} */\r\n\tHEAPF64;\r\n\r\n  function updateMemoryViews() {\r\n\tvar b = wasmMemory.buffer;\r\n\tModule['HEAP8'] = HEAP8 = new Int8Array(b);\r\n\tModule['HEAP16'] = HEAP16 = new Int16Array(b);\r\n\tModule['HEAPU8'] = HEAPU8 = new Uint8Array(b);\r\n\tModule['HEAPU16'] = HEAPU16 = new Uint16Array(b);\r\n\tModule['HEAP32'] = HEAP32 = new Int32Array(b);\r\n\tModule['HEAPU32'] = HEAPU32 = new Uint32Array(b);\r\n\tModule['HEAPF32'] = HEAPF32 = new Float32Array(b);\r\n\tModule['HEAPF64'] = HEAPF64 = new Float64Array(b);\r\n  }\r\n\r\n  assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');\r\n\r\n  assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\r\n\t\t 'JS engine does not provide full typed array support');\r\n\r\n  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\r\n  assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\r\n  assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\r\n\r\n  // include: runtime_stack_check.js\r\n  // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\n  function writeStackCookie() {\r\n\tvar max = _emscripten_stack_get_end();\r\n\tassert((max & 3) == 0);\r\n\t// If the stack ends at address zero we write our cookies 4 bytes into the\r\n\t// stack.  This prevents interference with SAFE_HEAP and ASAN which also\r\n\t// monitor writes to address zero.\r\n\tif (max == 0) {\r\n\t  max += 4;\r\n\t}\r\n\t// The stack grow downwards towards _emscripten_stack_get_end.\r\n\t// We write cookies to the final two words in the stack and detect if they are\r\n\t// ever overwritten.\r\n\tHEAPU32[((max)>>2)] = 0x02135467;\r\n\tHEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\r\n\t// Also test the global address 0 for integrity.\r\n\tHEAPU32[((0)>>2)] = 1668509029;\r\n  }\r\n\r\n  function checkStackCookie() {\r\n\tif (ABORT) return;\r\n\tvar max = _emscripten_stack_get_end();\r\n\t// See writeStackCookie().\r\n\tif (max == 0) {\r\n\t  max += 4;\r\n\t}\r\n\tvar cookie1 = HEAPU32[((max)>>2)];\r\n\tvar cookie2 = HEAPU32[(((max)+(4))>>2)];\r\n\tif (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\r\n\t  abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\r\n\t}\r\n\t// Also test the global address 0 for integrity.\r\n\tif (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\r\n\t  abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\r\n\t}\r\n  }\r\n  // end include: runtime_stack_check.js\r\n  // include: runtime_assertions.js\r\n  // Endianness check\r\n  (function() {\r\n\tvar h16 = new Int16Array(1);\r\n\tvar h8 = new Int8Array(h16.buffer);\r\n\th16[0] = 0x6373;\r\n\tif (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\r\n  })();\r\n\r\n  // end include: runtime_assertions.js\r\n  var __ATPRERUN__  = []; // functions called before the runtime is initialized\r\n  var __ATINIT__    = []; // functions called during startup\r\n  var __ATMAIN__    = []; // functions called when main() is to be run\r\n  var __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\n  var runtimeInitialized = false;\r\n\r\n  function preRun() {\r\n\tif (Module['preRun']) {\r\n\t  if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n\t  while (Module['preRun'].length) {\r\n\t\taddOnPreRun(Module['preRun'].shift());\r\n\t  }\r\n\t}\r\n\tcallRuntimeCallbacks(__ATPRERUN__);\r\n  }\r\n\r\n  function initRuntime() {\r\n\tassert(!runtimeInitialized);\r\n\truntimeInitialized = true;\r\n\r\n\tcheckStackCookie();\r\n\r\n\r\n  if (!Module[\"noFSInit\"] && !FS.init.initialized)\r\n\tFS.init();\r\n  FS.ignorePermissions = false;\r\n\tcallRuntimeCallbacks(__ATINIT__);\r\n  }\r\n\r\n  function preMain() {\r\n\tcheckStackCookie();\r\n\r\n\tcallRuntimeCallbacks(__ATMAIN__);\r\n  }\r\n\r\n  function postRun() {\r\n\tcheckStackCookie();\r\n\r\n\tif (Module['postRun']) {\r\n\t  if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n\t  while (Module['postRun'].length) {\r\n\t\taddOnPostRun(Module['postRun'].shift());\r\n\t  }\r\n\t}\r\n\r\n\tcallRuntimeCallbacks(__ATPOSTRUN__);\r\n  }\r\n\r\n  function addOnPreRun(cb) {\r\n\t__ATPRERUN__.unshift(cb);\r\n  }\r\n\r\n  function addOnInit(cb) {\r\n\t__ATINIT__.unshift(cb);\r\n  }\r\n\r\n  function addOnPostRun(cb) {\r\n\t__ATPOSTRUN__.unshift(cb);\r\n  }\r\n\r\n  // include: runtime_math.js\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\n  assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n  assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n  assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n  assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n  // end include: runtime_math.js\r\n  // A counter of dependencies for calling run(). If we need to\r\n  // do asynchronous work before running, increment this and\r\n  // decrement it. Incrementing must happen in a place like\r\n  // Module.preRun (used by emcc to add file preloading).\r\n  // Note that you can add dependencies in preRun, even though\r\n  // it happens right before run - run will be postponed until\r\n  // the dependencies are met.\r\n  var runDependencies = 0;\r\n  var runDependencyWatcher = null;\r\n  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\n  var runDependencyTracking = {};\r\n\r\n  function getUniqueRunDependency(id) {\r\n\tvar orig = id;\r\n\twhile (1) {\r\n\t  if (!runDependencyTracking[id]) return id;\r\n\t  id = orig + Math.random();\r\n\t}\r\n  }\r\n\r\n  function addRunDependency(id) {\r\n\trunDependencies++;\r\n\r\n\tif (Module['monitorRunDependencies']) {\r\n\t  Module['monitorRunDependencies'](runDependencies);\r\n\t}\r\n\r\n\tif (id) {\r\n\t  assert(!runDependencyTracking[id]);\r\n\t  runDependencyTracking[id] = 1;\r\n\t  if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\r\n\t\t// Check for missing dependencies every few seconds\r\n\t\trunDependencyWatcher = setInterval(() => {\r\n\t\t  if (ABORT) {\r\n\t\t\tclearInterval(runDependencyWatcher);\r\n\t\t\trunDependencyWatcher = null;\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  var shown = false;\r\n\t\t  for (var dep in runDependencyTracking) {\r\n\t\t\tif (!shown) {\r\n\t\t\t  shown = true;\r\n\t\t\t  err('still waiting on run dependencies:');\r\n\t\t\t}\r\n\t\t\terr(`dependency: ${dep}`);\r\n\t\t  }\r\n\t\t  if (shown) {\r\n\t\t\terr('(end of list)');\r\n\t\t  }\r\n\t\t}, 10000);\r\n\t  }\r\n\t} else {\r\n\t  err('warning: run dependency added without ID');\r\n\t}\r\n  }\r\n\r\n  function removeRunDependency(id) {\r\n\trunDependencies--;\r\n\r\n\tif (Module['monitorRunDependencies']) {\r\n\t  Module['monitorRunDependencies'](runDependencies);\r\n\t}\r\n\r\n\tif (id) {\r\n\t  assert(runDependencyTracking[id]);\r\n\t  delete runDependencyTracking[id];\r\n\t} else {\r\n\t  err('warning: run dependency removed without ID');\r\n\t}\r\n\tif (runDependencies == 0) {\r\n\t  if (runDependencyWatcher !== null) {\r\n\t\tclearInterval(runDependencyWatcher);\r\n\t\trunDependencyWatcher = null;\r\n\t  }\r\n\t  if (dependenciesFulfilled) {\r\n\t\tvar callback = dependenciesFulfilled;\r\n\t\tdependenciesFulfilled = null;\r\n\t\tcallback(); // can add another dependenciesFulfilled\r\n\t  }\r\n\t}\r\n  }\r\n\r\n  /** @param {string|number=} what */\r\n  function abort(what) {\r\n\tif (Module['onAbort']) {\r\n\t  Module['onAbort'](what);\r\n\t}\r\n\r\n\twhat = 'Aborted(' + what + ')';\r\n\t// TODO(sbc): Should we remove printing and leave it up to whoever\r\n\t// catches the exception?\r\n\terr(what);\r\n\r\n\tABORT = true;\r\n\tEXITSTATUS = 1;\r\n\r\n\t// Use a wasm runtime error, because a JS error might be seen as a foreign\r\n\t// exception, which means we'd run destructors on it. We need the error to\r\n\t// simply make the program stop.\r\n\t// FIXME This approach does not work in Wasm EH because it currently does not assume\r\n\t// all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n\t// a trap or not based on a hidden field within the object. So at the moment\r\n\t// we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n\t// allows this in the wasm spec.\r\n\r\n\t// Suppress closure compiler warning here. Closure compiler's builtin extern\r\n\t// defintion for WebAssembly.RuntimeError claims it takes no arguments even\r\n\t// though it can.\r\n\t// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n\t/** @suppress {checkTypes} */\r\n\tvar e = new WebAssembly.RuntimeError(what);\r\n\r\n\treadyPromiseReject(e);\r\n\t// Throw the error whether or not MODULARIZE is set because abort is used\r\n\t// in code paths apart from instantiation where an exception is expected\r\n\t// to be thrown when abort is called.\r\n\tthrow e;\r\n  }\r\n\r\n  // include: memoryprofiler.js\r\n  // end include: memoryprofiler.js\r\n  // include: URIUtils.js\r\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\r\n  var dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n  /**\r\n   * Indicates whether filename is a base64 data URI.\r\n   * @noinline\r\n   */\r\n  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\r\n\r\n  /**\r\n   * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n   * @noinline\r\n   */\r\n  var isFileURI = (filename) => filename.startsWith('file://');\r\n  // end include: URIUtils.js\r\n  function createExportWrapper(name) {\r\n\treturn function() {\r\n\t  assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\r\n\t  var f = wasmExports[name];\r\n\t  assert(f, `exported native function \\`${name}\\` not found`);\r\n\t  return f.apply(null, arguments);\r\n\t};\r\n  }\r\n\r\n  // include: runtime_exceptions.js\r\n  // end include: runtime_exceptions.js\r\n  var wasmBinaryFile;\r\n  if (Module['locateFile']) {\r\n\twasmBinaryFile = 'libultrahdr-esm.wasm';\r\n\tif (!isDataURI(wasmBinaryFile)) {\r\n\t  wasmBinaryFile = locateFile(wasmBinaryFile);\r\n\t}\r\n  } else {\r\n\t// Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n\twasmBinaryFile = new URL('../../node_modules/@monogrid/gainmap-js/dist/libultrahdr-esm.wasm', import.meta.url).href;\r\n  }\r\n\r\n  function getBinarySync(file) {\r\n\tif (file == wasmBinaryFile && wasmBinary) {\r\n\t  return new Uint8Array(wasmBinary);\r\n\t}\r\n\tif (readBinary) {\r\n\t  return readBinary(file);\r\n\t}\r\n\tthrow \"both async and sync fetching of the wasm failed\";\r\n  }\r\n\r\n  function getBinaryPromise(binaryFile) {\r\n\t// If we don't have the binary yet, try to load it asynchronously.\r\n\t// Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n\t// See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n\t// Cordova or Electron apps are typically loaded from a file:// url.\r\n\t// So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\r\n\tif (!wasmBinary\r\n\t\t&& (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n\t  if (typeof fetch == 'function'\r\n\t\t&& !isFileURI(binaryFile)\r\n\t  ) {\r\n\t\treturn fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\r\n\t\t  if (!response['ok']) {\r\n\t\t\tthrow \"failed to load wasm binary file at '\" + binaryFile + \"'\";\r\n\t\t  }\r\n\t\t  return response['arrayBuffer']();\r\n\t\t}).catch(() => getBinarySync(binaryFile));\r\n\t  }\r\n\t  else if (readAsync) {\r\n\t\t// fetch is not available or url is file => try XHR (readAsync uses XHR internally)\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t  readAsync(binaryFile, (response) => resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))), reject);\r\n\t\t});\r\n\t  }\r\n\t}\r\n\r\n\t// Otherwise, getBinarySync should be able to get it synchronously\r\n\treturn Promise.resolve().then(() => getBinarySync(binaryFile));\r\n  }\r\n\r\n  function instantiateArrayBuffer(binaryFile, imports, receiver) {\r\n\treturn getBinaryPromise(binaryFile).then((binary) => {\r\n\t  return WebAssembly.instantiate(binary, imports);\r\n\t}).then((instance) => {\r\n\t  return instance;\r\n\t}).then(receiver, (reason) => {\r\n\t  err(`failed to asynchronously prepare wasm: ${reason}`);\r\n\r\n\t  // Warn on some common problems.\r\n\t  if (isFileURI(wasmBinaryFile)) {\r\n\t\terr(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\r\n\t  }\r\n\t  abort(reason);\r\n\t});\r\n  }\r\n\r\n  function instantiateAsync(binary, binaryFile, imports, callback) {\r\n\tif (!binary &&\r\n\t\ttypeof WebAssembly.instantiateStreaming == 'function' &&\r\n\t\t!isDataURI(binaryFile) &&\r\n\t\t// Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\r\n\t\t!isFileURI(binaryFile) &&\r\n\t\t// Avoid instantiateStreaming() on Node.js environment for now, as while\r\n\t\t// Node.js v18.1.0 implements it, it does not have a full fetch()\r\n\t\t// implementation yet.\r\n\t\t//\r\n\t\t// Reference:\r\n\t\t//   https://github.com/emscripten-core/emscripten/pull/16917\r\n\t\t!ENVIRONMENT_IS_NODE &&\r\n\t\ttypeof fetch == 'function') {\r\n\t  return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\r\n\t\t// Suppress closure warning here since the upstream definition for\r\n\t\t// instantiateStreaming only allows Promise<Repsponse> rather than\r\n\t\t// an actual Response.\r\n\t\t// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n\t\t/** @suppress {checkTypes} */\r\n\t\tvar result = WebAssembly.instantiateStreaming(response, imports);\r\n\r\n\t\treturn result.then(\r\n\t\t  callback,\r\n\t\t  function(reason) {\r\n\t\t\t// We expect the most common failure cause to be a bad MIME type for the binary,\r\n\t\t\t// in which case falling back to ArrayBuffer instantiation should work.\r\n\t\t\terr(`wasm streaming compile failed: ${reason}`);\r\n\t\t\terr('falling back to ArrayBuffer instantiation');\r\n\t\t\treturn instantiateArrayBuffer(binaryFile, imports, callback);\r\n\t\t  });\r\n\t  });\r\n\t}\r\n\treturn instantiateArrayBuffer(binaryFile, imports, callback);\r\n  }\r\n\r\n  // Create the wasm instance.\r\n  // Receives the wasm imports, returns the exports.\r\n  function createWasm() {\r\n\t// prepare imports\r\n\tvar info = {\r\n\t  'env': wasmImports,\r\n\t  'wasi_snapshot_preview1': wasmImports,\r\n\t};\r\n\t// Load the wasm module and create an instance of using native support in the JS engine.\r\n\t// handle a generated wasm instance, receiving its exports and\r\n\t// performing other necessary setup\r\n\t/** @param {WebAssembly.Module=} module*/\r\n\tfunction receiveInstance(instance, module) {\r\n\t  wasmExports = instance.exports;\r\n\r\n\r\n\r\n\t  wasmMemory = wasmExports['memory'];\r\n\r\n\t  assert(wasmMemory, \"memory not found in wasm exports\");\r\n\t  // This assertion doesn't hold when emscripten is run in --post-link\r\n\t  // mode.\r\n\t  // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\r\n\t  //assert(wasmMemory.buffer.byteLength === 16777216);\r\n\t  updateMemoryViews();\r\n\r\n\t  wasmTable = wasmExports['__indirect_function_table'];\r\n\r\n\t  assert(wasmTable, \"table not found in wasm exports\");\r\n\r\n\t  addOnInit(wasmExports['__wasm_call_ctors']);\r\n\r\n\t  removeRunDependency('wasm-instantiate');\r\n\t  return wasmExports;\r\n\t}\r\n\t// wait for the pthread pool (if any)\r\n\taddRunDependency('wasm-instantiate');\r\n\r\n\t// Prefer streaming instantiation if available.\r\n\t// Async compilation can be confusing when an error on the page overwrites Module\r\n\t// (for example, if the order of elements is wrong, and the one defining Module is\r\n\t// later), so we save Module and check it later.\r\n\tvar trueModule = Module;\r\n\tfunction receiveInstantiationResult(result) {\r\n\t  // 'result' is a ResultObject object which has both the module and instance.\r\n\t  // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n\t  assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n\t  trueModule = null;\r\n\t  // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n\t  // When the regression is fixed, can restore the above PTHREADS-enabled path.\r\n\t  receiveInstance(result['instance']);\r\n\t}\r\n\r\n\t// User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n\t// to manually instantiate the Wasm module themselves. This allows pages to\r\n\t// run the instantiation parallel to any other async startup actions they are\r\n\t// performing.\r\n\t// Also pthreads and wasm workers initialize the wasm instance through this\r\n\t// path.\r\n\tif (Module['instantiateWasm']) {\r\n\r\n\t  try {\r\n\t\treturn Module['instantiateWasm'](info, receiveInstance);\r\n\t  } catch(e) {\r\n\t\terr(`Module.instantiateWasm callback failed with error: ${e}`);\r\n\t\t  // If instantiation fails, reject the module ready promise.\r\n\t\t  readyPromiseReject(e);\r\n\t  }\r\n\t}\r\n\r\n\t// If instantiation fails, reject the module ready promise.\r\n\tinstantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\r\n\treturn {}; // no exports yet; we'll fill them in later\r\n  }\r\n\r\n  // Globals used by JS i64 conversions (see makeSetValue)\r\n  var tempDouble;\r\n  var tempI64;\r\n\r\n  // include: runtime_debug.js\r\n  function legacyModuleProp(prop, newName, incomming=true) {\r\n\tif (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n\t  Object.defineProperty(Module, prop, {\r\n\t\tconfigurable: true,\r\n\t\tget() {\r\n\t\t  let extra = incomming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\r\n\t\t  abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\r\n\r\n\t\t}\r\n\t  });\r\n\t}\r\n  }\r\n\r\n  function ignoredModuleProp(prop) {\r\n\tif (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n\t  abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\r\n\t}\r\n  }\r\n\r\n  // forcing the filesystem exports a few things by default\r\n  function isExportedByForceFilesystem(name) {\r\n\treturn name === 'FS_createPath' ||\r\n\t\t   name === 'FS_createDataFile' ||\r\n\t\t   name === 'FS_createPreloadedFile' ||\r\n\t\t   name === 'FS_unlink' ||\r\n\t\t   name === 'addRunDependency' ||\r\n\t\t   // The old FS has some functionality that WasmFS lacks.\r\n\t\t   name === 'FS_createLazyFile' ||\r\n\t\t   name === 'FS_createDevice' ||\r\n\t\t   name === 'removeRunDependency';\r\n  }\r\n\r\n  function missingGlobal(sym, msg) {\r\n\tif (typeof globalThis !== 'undefined') {\r\n\t  Object.defineProperty(globalThis, sym, {\r\n\t\tconfigurable: true,\r\n\t\tget() {\r\n\t\t  warnOnce('`' + sym + '` is not longer defined by emscripten. ' + msg);\r\n\t\t  return undefined;\r\n\t\t}\r\n\t  });\r\n\t}\r\n  }\r\n\r\n  missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\r\n  missingGlobal('asm', 'Please use wasmExports instead');\r\n\r\n  function missingLibrarySymbol(sym) {\r\n\tif (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\r\n\t  Object.defineProperty(globalThis, sym, {\r\n\t\tconfigurable: true,\r\n\t\tget() {\r\n\t\t  // Can't `abort()` here because it would break code that does runtime\r\n\t\t  // checks.  e.g. `if (typeof SDL === 'undefined')`.\r\n\t\t  var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';\r\n\t\t  // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\r\n\t\t  // library.js, which means $name for a JS name with no prefix, or name\r\n\t\t  // for a JS name like _name.\r\n\t\t  var librarySymbol = sym;\r\n\t\t  if (!librarySymbol.startsWith('_')) {\r\n\t\t\tlibrarySymbol = '$' + sym;\r\n\t\t  }\r\n\t\t  msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" + librarySymbol + \"')\";\r\n\t\t  if (isExportedByForceFilesystem(sym)) {\r\n\t\t\tmsg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n\t\t  }\r\n\t\t  warnOnce(msg);\r\n\t\t  return undefined;\r\n\t\t}\r\n\t  });\r\n\t}\r\n\t// Any symbol that is not included from the JS libary is also (by definition)\r\n\t// not exported on the Module object.\r\n\tunexportedRuntimeSymbol(sym);\r\n  }\r\n\r\n  function unexportedRuntimeSymbol(sym) {\r\n\tif (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n\t  Object.defineProperty(Module, sym, {\r\n\t\tconfigurable: true,\r\n\t\tget() {\r\n\t\t  var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\r\n\t\t  if (isExportedByForceFilesystem(sym)) {\r\n\t\t\tmsg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n\t\t  }\r\n\t\t  abort(msg);\r\n\t\t}\r\n\t  });\r\n\t}\r\n  }\r\n  // end include: runtime_debug.js\r\n  // === Body ===\r\n\r\n  // end include: preamble.js\r\n\r\n\t/** @constructor */\r\n\tfunction ExitStatus(status) {\r\n\t\tthis.name = 'ExitStatus';\r\n\t\tthis.message = `Program terminated with exit(${status})`;\r\n\t\tthis.status = status;\r\n\t  }\r\n\r\n\tvar callRuntimeCallbacks = (callbacks) => {\r\n\t\twhile (callbacks.length > 0) {\r\n\t\t  // Pass the module as the first argument.\r\n\t\t  callbacks.shift()(Module);\r\n\t\t}\r\n\t  };\r\n\r\n\tvar noExitRuntime = Module['noExitRuntime'] || true;\r\n\r\n\tvar ptrToString = (ptr) => {\r\n\t\tassert(typeof ptr === 'number');\r\n\t\t// With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n\t\tptr >>>= 0;\r\n\t\treturn '0x' + ptr.toString(16).padStart(8, '0');\r\n\t  };\r\n\r\n\tvar warnOnce = (text) => {\r\n\t\tif (!warnOnce.shown) warnOnce.shown = {};\r\n\t\tif (!warnOnce.shown[text]) {\r\n\t\t  warnOnce.shown[text] = 1;\r\n\t\t  if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\r\n\t\t  err(text);\r\n\t\t}\r\n\t  };\r\n\r\n\t/** @constructor */\r\n\tfunction ExceptionInfo(excPtr) {\r\n\t\tthis.excPtr = excPtr;\r\n\t\tthis.ptr = excPtr - 24;\r\n\r\n\t\tthis.set_type = function(type) {\r\n\t\t  HEAPU32[(((this.ptr)+(4))>>2)] = type;\r\n\t\t};\r\n\r\n\t\tthis.get_type = function() {\r\n\t\t  return HEAPU32[(((this.ptr)+(4))>>2)];\r\n\t\t};\r\n\r\n\t\tthis.set_destructor = function(destructor) {\r\n\t\t  HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\r\n\t\t};\r\n\r\n\t\tthis.get_destructor = function() {\r\n\t\t  return HEAPU32[(((this.ptr)+(8))>>2)];\r\n\t\t};\r\n\r\n\t\tthis.set_caught = function(caught) {\r\n\t\t  caught = caught ? 1 : 0;\r\n\t\t  HEAP8[(((this.ptr)+(12))>>0)] = caught;\r\n\t\t};\r\n\r\n\t\tthis.get_caught = function() {\r\n\t\t  return HEAP8[(((this.ptr)+(12))>>0)] != 0;\r\n\t\t};\r\n\r\n\t\tthis.set_rethrown = function(rethrown) {\r\n\t\t  rethrown = rethrown ? 1 : 0;\r\n\t\t  HEAP8[(((this.ptr)+(13))>>0)] = rethrown;\r\n\t\t};\r\n\r\n\t\tthis.get_rethrown = function() {\r\n\t\t  return HEAP8[(((this.ptr)+(13))>>0)] != 0;\r\n\t\t};\r\n\r\n\t\t// Initialize native structure fields. Should be called once after allocated.\r\n\t\tthis.init = function(type, destructor) {\r\n\t\t  this.set_adjusted_ptr(0);\r\n\t\t  this.set_type(type);\r\n\t\t  this.set_destructor(destructor);\r\n\t\t};\r\n\r\n\t\tthis.set_adjusted_ptr = function(adjustedPtr) {\r\n\t\t  HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\r\n\t\t};\r\n\r\n\t\tthis.get_adjusted_ptr = function() {\r\n\t\t  return HEAPU32[(((this.ptr)+(16))>>2)];\r\n\t\t};\r\n\r\n\t\t// Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\r\n\t\t// when the pointer is casted to some of the exception object base classes (e.g. when virtual\r\n\t\t// inheritance is used). When a pointer is thrown this method should return the thrown pointer\r\n\t\t// itself.\r\n\t\tthis.get_exception_ptr = function() {\r\n\t\t  // Work around a fastcomp bug, this code is still included for some reason in a build without\r\n\t\t  // exceptions support.\r\n\t\t  var isPointer = ___cxa_is_pointer_type(this.get_type());\r\n\t\t  if (isPointer) {\r\n\t\t\treturn HEAPU32[((this.excPtr)>>2)];\r\n\t\t  }\r\n\t\t  var adjusted = this.get_adjusted_ptr();\r\n\t\t  if (adjusted !== 0) return adjusted;\r\n\t\t  return this.excPtr;\r\n\t\t};\r\n\t  }\r\n\tvar ___cxa_throw = (ptr, type, destructor) => {\r\n\t\tvar info = new ExceptionInfo(ptr);\r\n\t\t// Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\r\n\t\tinfo.init(type, destructor);\r\n\t\tassert(false, 'Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.');\r\n\t  };\r\n\r\n\tvar structRegistrations = {\r\n\t};\r\n\r\n\tvar runDestructors = (destructors) => {\r\n\t\twhile (destructors.length) {\r\n\t\t  var ptr = destructors.pop();\r\n\t\t  var del = destructors.pop();\r\n\t\t  del(ptr);\r\n\t\t}\r\n\t  };\r\n\r\n\t/** @suppress {globalThis} */\r\n\tfunction simpleReadValueFromPointer(pointer) {\r\n\t\treturn this['fromWireType'](HEAP32[((pointer)>>2)]);\r\n\t  }\r\n\r\n\tvar awaitingDependencies = {\r\n\t};\r\n\r\n\tvar registeredTypes = {\r\n\t};\r\n\r\n\tvar typeDependencies = {\r\n\t};\r\n\r\n\tvar InternalError;\r\n\tvar throwInternalError = (message) => { throw new InternalError(message); };\r\n\tvar whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\r\n\t\tmyTypes.forEach(function(type) {\r\n\t\t\ttypeDependencies[type] = dependentTypes;\r\n\t\t});\r\n\r\n\t\tfunction onComplete(typeConverters) {\r\n\t\t\tvar myTypeConverters = getTypeConverters(typeConverters);\r\n\t\t\tif (myTypeConverters.length !== myTypes.length) {\r\n\t\t\t\tthrowInternalError('Mismatched type converter count');\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < myTypes.length; ++i) {\r\n\t\t\t\tregisterType(myTypes[i], myTypeConverters[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar typeConverters = new Array(dependentTypes.length);\r\n\t\tvar unregisteredTypes = [];\r\n\t\tvar registered = 0;\r\n\t\tdependentTypes.forEach((dt, i) => {\r\n\t\t  if (registeredTypes.hasOwnProperty(dt)) {\r\n\t\t\ttypeConverters[i] = registeredTypes[dt];\r\n\t\t  } else {\r\n\t\t\tunregisteredTypes.push(dt);\r\n\t\t\tif (!awaitingDependencies.hasOwnProperty(dt)) {\r\n\t\t\t  awaitingDependencies[dt] = [];\r\n\t\t\t}\r\n\t\t\tawaitingDependencies[dt].push(() => {\r\n\t\t\t  typeConverters[i] = registeredTypes[dt];\r\n\t\t\t  ++registered;\r\n\t\t\t  if (registered === unregisteredTypes.length) {\r\n\t\t\t\tonComplete(typeConverters);\r\n\t\t\t  }\r\n\t\t\t});\r\n\t\t  }\r\n\t\t});\r\n\t\tif (0 === unregisteredTypes.length) {\r\n\t\t  onComplete(typeConverters);\r\n\t\t}\r\n\t  };\r\n\tvar __embind_finalize_value_object = (structType) => {\r\n\t\tvar reg = structRegistrations[structType];\r\n\t\tdelete structRegistrations[structType];\r\n\r\n\t\tvar rawConstructor = reg.rawConstructor;\r\n\t\tvar rawDestructor = reg.rawDestructor;\r\n\t\tvar fieldRecords = reg.fields;\r\n\t\tvar fieldTypes = fieldRecords.map((field) => field.getterReturnType).\r\n\t\t\t\t  concat(fieldRecords.map((field) => field.setterArgumentType));\r\n\t\twhenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\r\n\t\t  var fields = {};\r\n\t\t  fieldRecords.forEach((field, i) => {\r\n\t\t\tvar fieldName = field.fieldName;\r\n\t\t\tvar getterReturnType = fieldTypes[i];\r\n\t\t\tvar getter = field.getter;\r\n\t\t\tvar getterContext = field.getterContext;\r\n\t\t\tvar setterArgumentType = fieldTypes[i + fieldRecords.length];\r\n\t\t\tvar setter = field.setter;\r\n\t\t\tvar setterContext = field.setterContext;\r\n\t\t\tfields[fieldName] = {\r\n\t\t\t  read: (ptr) => {\r\n\t\t\t\treturn getterReturnType['fromWireType'](\r\n\t\t\t\t\tgetter(getterContext, ptr));\r\n\t\t\t  },\r\n\t\t\t  write: (ptr, o) => {\r\n\t\t\t\tvar destructors = [];\r\n\t\t\t\tsetter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\r\n\t\t\t\trunDestructors(destructors);\r\n\t\t\t  }\r\n\t\t\t};\r\n\t\t  });\r\n\r\n\t\t  return [{\r\n\t\t\tname: reg.name,\r\n\t\t\t'fromWireType': (ptr) => {\r\n\t\t\t  var rv = {};\r\n\t\t\t  for (var i in fields) {\r\n\t\t\t\trv[i] = fields[i].read(ptr);\r\n\t\t\t  }\r\n\t\t\t  rawDestructor(ptr);\r\n\t\t\t  return rv;\r\n\t\t\t},\r\n\t\t\t'toWireType': (destructors, o) => {\r\n\t\t\t  // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\r\n\t\t\t  // assume all fields are present without checking.\r\n\t\t\t  for (var fieldName in fields) {\r\n\t\t\t\tif (!(fieldName in o)) {\r\n\t\t\t\t  throw new TypeError(`Missing field: \"${fieldName}\"`);\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t  var ptr = rawConstructor();\r\n\t\t\t  for (fieldName in fields) {\r\n\t\t\t\tfields[fieldName].write(ptr, o[fieldName]);\r\n\t\t\t  }\r\n\t\t\t  if (destructors !== null) {\r\n\t\t\t\tdestructors.push(rawDestructor, ptr);\r\n\t\t\t  }\r\n\t\t\t  return ptr;\r\n\t\t\t},\r\n\t\t\t'argPackAdvance': GenericWireTypeSize,\r\n\t\t\t'readValueFromPointer': simpleReadValueFromPointer,\r\n\t\t\tdestructorFunction: rawDestructor,\r\n\t\t  }];\r\n\t\t});\r\n\t  };\r\n\r\n\tvar __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {};\r\n\r\n\tvar embind_init_charCodes = () => {\r\n\t\tvar codes = new Array(256);\r\n\t\tfor (var i = 0; i < 256; ++i) {\r\n\t\t\tcodes[i] = String.fromCharCode(i);\r\n\t\t}\r\n\t\tembind_charCodes = codes;\r\n\t  };\r\n\tvar embind_charCodes;\r\n\tvar readLatin1String = (ptr) => {\r\n\t\tvar ret = \"\";\r\n\t\tvar c = ptr;\r\n\t\twhile (HEAPU8[c]) {\r\n\t\t\tret += embind_charCodes[HEAPU8[c++]];\r\n\t\t}\r\n\t\treturn ret;\r\n\t  };\r\n\r\n\r\n\r\n\r\n\tvar BindingError;\r\n\tvar throwBindingError = (message) => { throw new BindingError(message); };\r\n\r\n\t/** @param {Object=} options */\r\n\tfunction sharedRegisterType(rawType, registeredInstance, options = {}) {\r\n\t\tvar name = registeredInstance.name;\r\n\t\tif (!rawType) {\r\n\t\t  throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\r\n\t\t}\r\n\t\tif (registeredTypes.hasOwnProperty(rawType)) {\r\n\t\t  if (options.ignoreDuplicateRegistrations) {\r\n\t\t\treturn;\r\n\t\t  } else {\r\n\t\t\tthrowBindingError(`Cannot register type '${name}' twice`);\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\tregisteredTypes[rawType] = registeredInstance;\r\n\t\tdelete typeDependencies[rawType];\r\n\r\n\t\tif (awaitingDependencies.hasOwnProperty(rawType)) {\r\n\t\t  var callbacks = awaitingDependencies[rawType];\r\n\t\t  delete awaitingDependencies[rawType];\r\n\t\t  callbacks.forEach((cb) => cb());\r\n\t\t}\r\n\t  }\r\n\t/** @param {Object=} options */\r\n\tfunction registerType(rawType, registeredInstance, options = {}) {\r\n\t\tif (!('argPackAdvance' in registeredInstance)) {\r\n\t\t  throw new TypeError('registerType registeredInstance requires argPackAdvance');\r\n\t\t}\r\n\t\treturn sharedRegisterType(rawType, registeredInstance, options);\r\n\t  }\r\n\r\n\tvar GenericWireTypeSize = 8;\r\n\t/** @suppress {globalThis} */\r\n\tvar __embind_register_bool = (rawType, name, trueValue, falseValue) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tregisterType(rawType, {\r\n\t\t\tname,\r\n\t\t\t'fromWireType': function(wt) {\r\n\t\t\t\t// ambiguous emscripten ABI: sometimes return values are\r\n\t\t\t\t// true or false, and sometimes integers (0 or 1)\r\n\t\t\t\treturn !!wt;\r\n\t\t\t},\r\n\t\t\t'toWireType': function(destructors, o) {\r\n\t\t\t\treturn o ? trueValue : falseValue;\r\n\t\t\t},\r\n\t\t\t'argPackAdvance': GenericWireTypeSize,\r\n\t\t\t'readValueFromPointer': function(pointer) {\r\n\t\t\t\treturn this['fromWireType'](HEAPU8[pointer]);\r\n\t\t\t},\r\n\t\t\tdestructorFunction: null, // This type does not need a destructor\r\n\t\t});\r\n\t  };\r\n\r\n\tfunction handleAllocatorInit() {\r\n\t\tObject.assign(HandleAllocator.prototype, /** @lends {HandleAllocator.prototype} */ {\r\n\t\t  get(id) {\r\n\t\t\tassert(this.allocated[id] !== undefined, `invalid handle: ${id}`);\r\n\t\t\treturn this.allocated[id];\r\n\t\t  },\r\n\t\t  has(id) {\r\n\t\t\treturn this.allocated[id] !== undefined;\r\n\t\t  },\r\n\t\t  allocate(handle) {\r\n\t\t\tvar id = this.freelist.pop() || this.allocated.length;\r\n\t\t\tthis.allocated[id] = handle;\r\n\t\t\treturn id;\r\n\t\t  },\r\n\t\t  free(id) {\r\n\t\t\tassert(this.allocated[id] !== undefined);\r\n\t\t\t// Set the slot to `undefined` rather than using `delete` here since\r\n\t\t\t// apparently arrays with holes in them can be less efficient.\r\n\t\t\tthis.allocated[id] = undefined;\r\n\t\t\tthis.freelist.push(id);\r\n\t\t  }\r\n\t\t});\r\n\t  }\r\n\t/** @constructor */\r\n\tfunction HandleAllocator() {\r\n\t\t// Reserve slot 0 so that 0 is always an invalid handle\r\n\t\tthis.allocated = [undefined];\r\n\t\tthis.freelist = [];\r\n\t  }\r\n\tvar emval_handles = new HandleAllocator();  var __emval_decref = (handle) => {\r\n\t\tif (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\r\n\t\t  emval_handles.free(handle);\r\n\t\t}\r\n\t  };\r\n\r\n\r\n\r\n\tvar count_emval_handles = () => {\r\n\t\tvar count = 0;\r\n\t\tfor (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\r\n\t\t  if (emval_handles.allocated[i] !== undefined) {\r\n\t\t\t++count;\r\n\t\t  }\r\n\t\t}\r\n\t\treturn count;\r\n\t  };\r\n\r\n\tvar init_emval = () => {\r\n\t\t// reserve some special values. These never get de-allocated.\r\n\t\t// The HandleAllocator takes care of reserving zero.\r\n\t\temval_handles.allocated.push(\r\n\t\t  {value: undefined},\r\n\t\t  {value: null},\r\n\t\t  {value: true},\r\n\t\t  {value: false},\r\n\t\t);\r\n\t\temval_handles.reserved = emval_handles.allocated.length;\r\n\t\tModule['count_emval_handles'] = count_emval_handles;\r\n\t  };\r\n\tvar Emval = {\r\n\ttoValue:(handle) => {\r\n\t\t  if (!handle) {\r\n\t\t\t  throwBindingError('Cannot use deleted val. handle = ' + handle);\r\n\t\t  }\r\n\t\t  return emval_handles.get(handle).value;\r\n\t\t},\r\n\ttoHandle:(value) => {\r\n\t\t  switch (value) {\r\n\t\t\tcase undefined: return 1;\r\n\t\t\tcase null: return 2;\r\n\t\t\tcase true: return 3;\r\n\t\t\tcase false: return 4;\r\n\t\t\tdefault:{\r\n\t\t\t  return emval_handles.allocate({refcount: 1, value: value});\r\n\t\t\t}\r\n\t\t  }\r\n\t\t},\r\n\t};\r\n\r\n\r\n\r\n\tvar __embind_register_emval = (rawType, name) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tregisterType(rawType, {\r\n\t\t  name,\r\n\t\t  'fromWireType': (handle) => {\r\n\t\t\tvar rv = Emval.toValue(handle);\r\n\t\t\t__emval_decref(handle);\r\n\t\t\treturn rv;\r\n\t\t  },\r\n\t\t  'toWireType': (destructors, value) => Emval.toHandle(value),\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': simpleReadValueFromPointer,\r\n\t\t  destructorFunction: null, // This type does not need a destructor\r\n\r\n\t\t  // TODO: do we need a deleteObject here?  write a test where\r\n\t\t  // emval is passed into JS via an interface\r\n\t\t});\r\n\t  };\r\n\r\n\tvar embindRepr = (v) => {\r\n\t\tif (v === null) {\r\n\t\t\treturn 'null';\r\n\t\t}\r\n\t\tvar t = typeof v;\r\n\t\tif (t === 'object' || t === 'array' || t === 'function') {\r\n\t\t\treturn v.toString();\r\n\t\t} else {\r\n\t\t\treturn '' + v;\r\n\t\t}\r\n\t  };\r\n\r\n\tvar floatReadValueFromPointer = (name, width) => {\r\n\t\tswitch (width) {\r\n\t\t\tcase 4: return function(pointer) {\r\n\t\t\t\treturn this['fromWireType'](HEAPF32[((pointer)>>2)]);\r\n\t\t\t};\r\n\t\t\tcase 8: return function(pointer) {\r\n\t\t\t\treturn this['fromWireType'](HEAPF64[((pointer)>>3)]);\r\n\t\t\t};\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new TypeError(`invalid float width (${width}): ${name}`);\r\n\t\t}\r\n\t  };\r\n\r\n\r\n\tvar __embind_register_float = (rawType, name, size) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tregisterType(rawType, {\r\n\t\t  name,\r\n\t\t  'fromWireType': (value) => value,\r\n\t\t  'toWireType': (destructors, value) => {\r\n\t\t\tif (typeof value != \"number\" && typeof value != \"boolean\") {\r\n\t\t\t  throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\r\n\t\t\t}\r\n\t\t\t// The VM will perform JS to Wasm value conversion, according to the spec:\r\n\t\t\t// https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n\t\t\treturn value;\r\n\t\t  },\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': floatReadValueFromPointer(name, size),\r\n\t\t  destructorFunction: null, // This type does not need a destructor\r\n\t\t});\r\n\t  };\r\n\r\n\tvar char_0 = 48;\r\n\r\n\tvar char_9 = 57;\r\n\tvar makeLegalFunctionName = (name) => {\r\n\t\tif (undefined === name) {\r\n\t\t  return '_unknown';\r\n\t\t}\r\n\t\tname = name.replace(/[^a-zA-Z0-9_]/g, '$');\r\n\t\tvar f = name.charCodeAt(0);\r\n\t\tif (f >= char_0 && f <= char_9) {\r\n\t\t  return `_${name}`;\r\n\t\t}\r\n\t\treturn name;\r\n\t  };\r\n\r\n\r\n\r\n\tfunction createNamedFunction(name, body) {\r\n\t\tname = makeLegalFunctionName(name);\r\n\t\t// Use an abject with a computed property name to create a new function with\r\n\t\t// a name specified at runtime, but without using `new Function` or `eval`.\r\n\t\treturn {\r\n\t\t  [name]: function() {\r\n\t\t\treturn body.apply(this, arguments);\r\n\t\t  }\r\n\t\t}[name];\r\n\t  }\r\n\tfunction newFunc(constructor, argumentList) {\r\n\t\tif (!(constructor instanceof Function)) {\r\n\t\t  throw new TypeError(`new_ called with constructor type ${typeof(constructor)} which is not a function`);\r\n\t\t}\r\n\t\t/*\r\n\t\t * Previously, the following line was just:\r\n\t\t *   function dummy() {};\r\n\t\t * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\r\n\t\t * though at creation, the 'dummy' has the correct constructor name.  Thus,\r\n\t\t * objects created with IMVU.new would show up in the debugger as 'dummy',\r\n\t\t * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\r\n\t\t * issue.  Doublely-unfortunately, there's no way to write a test for this\r\n\t\t * behavior.  -NRD 2013.02.22\r\n\t\t */\r\n\t\tvar dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\r\n\t\tdummy.prototype = constructor.prototype;\r\n\t\tvar obj = new dummy;\r\n\r\n\t\tvar r = constructor.apply(obj, argumentList);\r\n\t\treturn (r instanceof Object) ? r : obj;\r\n\t  }\r\n\tfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\r\n\t\t// humanName: a human-readable string name for the function to be generated.\r\n\t\t// argTypes: An array that contains the embind type objects for all types in the function signature.\r\n\t\t//    argTypes[0] is the type object for the function return value.\r\n\t\t//    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\r\n\t\t//    argTypes[2...] are the actual function parameters.\r\n\t\t// classType: The embind type object for the class to be bound, or null if this is not a method of a class.\r\n\t\t// cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\r\n\t\t// cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\r\n\t\t// isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\r\n\t\tvar argCount = argTypes.length;\r\n\r\n\t\tif (argCount < 2) {\r\n\t\t  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n\t\t}\r\n\r\n\t\tassert(!isAsync, 'Async bindings are only supported with JSPI.');\r\n\r\n\t\tvar isClassMethodFunc = (argTypes[1] !== null && classType !== null);\r\n\r\n\t\t// Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\r\n\t// TODO: This omits argument count check - enable only at -O3 or similar.\r\n\t//    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\r\n\t//       return FUNCTION_TABLE[fn];\r\n\t//    }\r\n\r\n\t\t// Determine if we need to use a dynamic stack to store the destructors for the function parameters.\r\n\t\t// TODO: Remove this completely once all function invokers are being dynamically generated.\r\n\t\tvar needsDestructorStack = false;\r\n\r\n\t\tfor (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\r\n\t\t  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\r\n\t\t\tneedsDestructorStack = true;\r\n\t\t\tbreak;\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\tvar returns = (argTypes[0].name !== \"void\");\r\n\r\n\t\tvar argsList = \"\";\r\n\t\tvar argsListWired = \"\";\r\n\t\tfor (var i = 0; i < argCount - 2; ++i) {\r\n\t\t  argsList += (i!==0?\", \":\"\")+\"arg\"+i;\r\n\t\t  argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\r\n\t\t}\r\n\r\n\t\tvar invokerFnBody = `\r\n\t\t  return function ${makeLegalFunctionName(humanName)}(${argsList}) {\r\n\t\t  if (arguments.length !== ${argCount - 2}) {\r\n\t\t\tthrowBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\r\n\t\t  }`;\r\n\r\n\t\tif (needsDestructorStack) {\r\n\t\t  invokerFnBody += \"var destructors = [];\\n\";\r\n\t\t}\r\n\r\n\t\tvar dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n\t\tvar args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\r\n\t\tvar args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\r\n\r\n\t\tif (isClassMethodFunc) {\r\n\t\t  invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < argCount - 2; ++i) {\r\n\t\t  invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\r\n\t\t  args1.push(\"argType\"+i);\r\n\t\t  args2.push(argTypes[i+2]);\r\n\t\t}\r\n\r\n\t\tif (isClassMethodFunc) {\r\n\t\t  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\r\n\t\t}\r\n\r\n\t\tinvokerFnBody +=\r\n\t\t\t(returns || isAsync ? \"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\r\n\r\n\t\tif (needsDestructorStack) {\r\n\t\t  invokerFnBody += \"runDestructors(destructors);\\n\";\r\n\t\t} else {\r\n\t\t  for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n\t\t\tvar paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\r\n\t\t\tif (argTypes[i].destructorFunction !== null) {\r\n\t\t\t  invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\r\n\t\t\t  args1.push(paramName+\"_dtor\");\r\n\t\t\t  args2.push(argTypes[i].destructorFunction);\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\tif (returns) {\r\n\t\t  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\r\n\t\t\t\t\t\t   \"return ret;\\n\";\r\n\t\t}\r\n\r\n\t\tinvokerFnBody += \"}\\n\";\r\n\r\n\t\targs1.push(invokerFnBody);\r\n\r\n\t\treturn newFunc(Function, args1).apply(null, args2);\r\n\t  }\r\n\r\n\tvar ensureOverloadTable = (proto, methodName, humanName) => {\r\n\t\tif (undefined === proto[methodName].overloadTable) {\r\n\t\t  var prevFunc = proto[methodName];\r\n\t\t  // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\r\n\t\t  proto[methodName] = function() {\r\n\t\t\t// TODO This check can be removed in -O3 level \"unsafe\" optimizations.\r\n\t\t\tif (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\r\n\t\t\t\tthrowBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`);\r\n\t\t\t}\r\n\t\t\treturn proto[methodName].overloadTable[arguments.length].apply(this, arguments);\r\n\t\t  };\r\n\t\t  // Move the previous function into the overload table.\r\n\t\t  proto[methodName].overloadTable = [];\r\n\t\t  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n\t\t}\r\n\t  };\r\n\r\n\t/** @param {number=} numArguments */\r\n\tvar exposePublicSymbol = (name, value, numArguments) => {\r\n\t\tif (Module.hasOwnProperty(name)) {\r\n\t\t  if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\r\n\t\t\tthrowBindingError(`Cannot register public name '${name}' twice`);\r\n\t\t  }\r\n\r\n\t\t  // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\r\n\t\t  // that routes between the two.\r\n\t\t  ensureOverloadTable(Module, name, name);\r\n\t\t  if (Module.hasOwnProperty(numArguments)) {\r\n\t\t\tthrowBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\r\n\t\t  }\r\n\t\t  // Add the new function into the overload table.\r\n\t\t  Module[name].overloadTable[numArguments] = value;\r\n\t\t}\r\n\t\telse {\r\n\t\t  Module[name] = value;\r\n\t\t  if (undefined !== numArguments) {\r\n\t\t\tModule[name].numArguments = numArguments;\r\n\t\t  }\r\n\t\t}\r\n\t  };\r\n\r\n\tvar heap32VectorToArray = (count, firstElement) => {\r\n\t\tvar array = [];\r\n\t\tfor (var i = 0; i < count; i++) {\r\n\t\t\t// TODO(https://github.com/emscripten-core/emscripten/issues/17310):\r\n\t\t\t// Find a way to hoist the `>> 2` or `>> 3` out of this loop.\r\n\t\t\tarray.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);\r\n\t\t}\r\n\t\treturn array;\r\n\t  };\r\n\r\n\r\n\t/** @param {number=} numArguments */\r\n\tvar replacePublicSymbol = (name, value, numArguments) => {\r\n\t\tif (!Module.hasOwnProperty(name)) {\r\n\t\t  throwInternalError('Replacing nonexistant public symbol');\r\n\t\t}\r\n\t\t// If there's an overload table for this symbol, replace the symbol in the overload table instead.\r\n\t\tif (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n\t\t  Module[name].overloadTable[numArguments] = value;\r\n\t\t}\r\n\t\telse {\r\n\t\t  Module[name] = value;\r\n\t\t  Module[name].argCount = numArguments;\r\n\t\t}\r\n\t  };\r\n\r\n\r\n\r\n\tvar dynCallLegacy = (sig, ptr, args) => {\r\n\t\tassert(('dynCall_' + sig) in Module, `bad function pointer type - dynCall function not found for sig '${sig}'`);\r\n\t\tif (args && args.length) {\r\n\t\t  // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\r\n\t\t  assert(args.length === sig.substring(1).replace(/j/g, '--').length);\r\n\t\t} else {\r\n\t\t  assert(sig.length == 1);\r\n\t\t}\r\n\t\tvar f = Module['dynCall_' + sig];\r\n\t\treturn args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\r\n\t  };\r\n\r\n\tvar wasmTableMirror = [];\r\n\r\n\tvar wasmTable;\r\n\tvar getWasmTableEntry = (funcPtr) => {\r\n\t\tvar func = wasmTableMirror[funcPtr];\r\n\t\tif (!func) {\r\n\t\t  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n\t\t  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n\t\t}\r\n\t\tassert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\r\n\t\treturn func;\r\n\t  };\r\n\r\n\t/** @param {Object=} args */\r\n\tvar dynCall = (sig, ptr, args) => {\r\n\t\t// Without WASM_BIGINT support we cannot directly call function with i64 as\r\n\t\t// part of thier signature, so we rely the dynCall functions generated by\r\n\t\t// wasm-emscripten-finalize\r\n\t\tif (sig.includes('j')) {\r\n\t\t  return dynCallLegacy(sig, ptr, args);\r\n\t\t}\r\n\t\tassert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);\r\n\t\tvar rtn = getWasmTableEntry(ptr).apply(null, args);\r\n\t\treturn rtn;\r\n\t  };\r\n\tvar getDynCaller = (sig, ptr) => {\r\n\t\tassert(sig.includes('j') || sig.includes('p'), 'getDynCaller should only be called with i64 sigs');\r\n\t\tvar argCache = [];\r\n\t\treturn function() {\r\n\t\t  argCache.length = 0;\r\n\t\t  Object.assign(argCache, arguments);\r\n\t\t  return dynCall(sig, ptr, argCache);\r\n\t\t};\r\n\t  };\r\n\r\n\r\n\tvar embind__requireFunction = (signature, rawFunction) => {\r\n\t\tsignature = readLatin1String(signature);\r\n\r\n\t\tfunction makeDynCaller() {\r\n\t\t  if (signature.includes('j')) {\r\n\t\t\treturn getDynCaller(signature, rawFunction);\r\n\t\t  }\r\n\t\t  return getWasmTableEntry(rawFunction);\r\n\t\t}\r\n\r\n\t\tvar fp = makeDynCaller();\r\n\t\tif (typeof fp != \"function\") {\r\n\t\t\tthrowBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\r\n\t\t}\r\n\t\treturn fp;\r\n\t  };\r\n\r\n\r\n\r\n\tvar extendError = (baseErrorType, errorName) => {\r\n\t\tvar errorClass = createNamedFunction(errorName, function(message) {\r\n\t\t  this.name = errorName;\r\n\t\t  this.message = message;\r\n\r\n\t\t  var stack = (new Error(message)).stack;\r\n\t\t  if (stack !== undefined) {\r\n\t\t\tthis.stack = this.toString() + '\\n' +\r\n\t\t\t\tstack.replace(/^Error(:[^\\n]*)?\\n/, '');\r\n\t\t  }\r\n\t\t});\r\n\t\terrorClass.prototype = Object.create(baseErrorType.prototype);\r\n\t\terrorClass.prototype.constructor = errorClass;\r\n\t\terrorClass.prototype.toString = function() {\r\n\t\t  if (this.message === undefined) {\r\n\t\t\treturn this.name;\r\n\t\t  } else {\r\n\t\t\treturn `${this.name}: ${this.message}`;\r\n\t\t  }\r\n\t\t};\r\n\r\n\t\treturn errorClass;\r\n\t  };\r\n\tvar UnboundTypeError;\r\n\r\n\r\n\r\n\tvar getTypeName = (type) => {\r\n\t\tvar ptr = ___getTypeName(type);\r\n\t\tvar rv = readLatin1String(ptr);\r\n\t\t_free(ptr);\r\n\t\treturn rv;\r\n\t  };\r\n\tvar throwUnboundTypeError = (message, types) => {\r\n\t\tvar unboundTypes = [];\r\n\t\tvar seen = {};\r\n\t\tfunction visit(type) {\r\n\t\t  if (seen[type]) {\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  if (registeredTypes[type]) {\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  if (typeDependencies[type]) {\r\n\t\t\ttypeDependencies[type].forEach(visit);\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  unboundTypes.push(type);\r\n\t\t  seen[type] = true;\r\n\t\t}\r\n\t\ttypes.forEach(visit);\r\n\r\n\t\tthrow new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));\r\n\t  };\r\n\r\n\r\n\tvar getFunctionName = (signature) => {\r\n\t\tsignature = signature.trim();\r\n\t\tconst argsIndex = signature.indexOf(\"(\");\r\n\t\tif (argsIndex !== -1) {\r\n\t\t  assert(signature[signature.length - 1] == \")\", \"Parentheses for argument names should match.\");\r\n\t\t  return signature.substr(0, argsIndex);\r\n\t\t} else {\r\n\t\t  return signature;\r\n\t\t}\r\n\t  };\r\n\tvar __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) => {\r\n\t\tvar argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n\t\tname = readLatin1String(name);\r\n\t\tname = getFunctionName(name);\r\n\r\n\t\trawInvoker = embind__requireFunction(signature, rawInvoker);\r\n\r\n\t\texposePublicSymbol(name, function() {\r\n\t\t  throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\r\n\t\t}, argCount - 1);\r\n\r\n\t\twhenDependentTypesAreResolved([], argTypes, function(argTypes) {\r\n\t\t  var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\r\n\t\t  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);\r\n\t\t  return [];\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\tvar integerReadValueFromPointer = (name, width, signed) => {\r\n\t\t// integers are quite common, so generate very specialized functions\r\n\t\tswitch (width) {\r\n\t\t\tcase 1: return signed ?\r\n\t\t\t\t(pointer) => HEAP8[((pointer)>>0)] :\r\n\t\t\t\t(pointer) => HEAPU8[((pointer)>>0)];\r\n\t\t\tcase 2: return signed ?\r\n\t\t\t\t(pointer) => HEAP16[((pointer)>>1)] :\r\n\t\t\t\t(pointer) => HEAPU16[((pointer)>>1)]\r\n\t\t\tcase 4: return signed ?\r\n\t\t\t\t(pointer) => HEAP32[((pointer)>>2)] :\r\n\t\t\t\t(pointer) => HEAPU32[((pointer)>>2)]\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new TypeError(`invalid integer width (${width}): ${name}`);\r\n\t\t}\r\n\t  };\r\n\r\n\r\n\t/** @suppress {globalThis} */\r\n\tvar __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\r\n\t\tname = readLatin1String(name);\r\n\t\t// LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\r\n\t\t// out as 'i32 -1'. Always treat those as max u32.\r\n\t\tif (maxRange === -1) {\r\n\t\t  maxRange = 4294967295;\r\n\t\t}\r\n\r\n\t\tvar fromWireType = (value) => value;\r\n\r\n\t\tif (minRange === 0) {\r\n\t\t  var bitshift = 32 - 8*size;\r\n\t\t  fromWireType = (value) => (value << bitshift) >>> bitshift;\r\n\t\t}\r\n\r\n\t\tvar isUnsignedType = (name.includes('unsigned'));\r\n\t\tvar checkAssertions = (value, toTypeName) => {\r\n\t\t  if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n\t\t\tthrow new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${toTypeName}`);\r\n\t\t  }\r\n\t\t  if (value < minRange || value > maxRange) {\r\n\t\t\tthrow new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n\t\t  }\r\n\t\t};\r\n\t\tvar toWireType;\r\n\t\tif (isUnsignedType) {\r\n\t\t  toWireType = function(destructors, value) {\r\n\t\t\tcheckAssertions(value, this.name);\r\n\t\t\treturn value >>> 0;\r\n\t\t  };\r\n\t\t} else {\r\n\t\t  toWireType = function(destructors, value) {\r\n\t\t\tcheckAssertions(value, this.name);\r\n\t\t\t// The VM will perform JS to Wasm value conversion, according to the spec:\r\n\t\t\t// https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n\t\t\treturn value;\r\n\t\t  };\r\n\t\t}\r\n\t\tregisterType(primitiveType, {\r\n\t\t  name,\r\n\t\t  'fromWireType': fromWireType,\r\n\t\t  'toWireType': toWireType,\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': integerReadValueFromPointer(name, size, minRange !== 0),\r\n\t\t  destructorFunction: null, // This type does not need a destructor\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\tvar __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\r\n\t\tvar typeMapping = [\r\n\t\t  Int8Array,\r\n\t\t  Uint8Array,\r\n\t\t  Int16Array,\r\n\t\t  Uint16Array,\r\n\t\t  Int32Array,\r\n\t\t  Uint32Array,\r\n\t\t  Float32Array,\r\n\t\t  Float64Array,\r\n\t\t];\r\n\r\n\t\tvar TA = typeMapping[dataTypeIndex];\r\n\r\n\t\tfunction decodeMemoryView(handle) {\r\n\t\t  var size = HEAPU32[((handle)>>2)];\r\n\t\t  var data = HEAPU32[(((handle)+(4))>>2)];\r\n\t\t  return new TA(HEAP8.buffer, data, size);\r\n\t\t}\r\n\r\n\t\tname = readLatin1String(name);\r\n\t\tregisterType(rawType, {\r\n\t\t  name,\r\n\t\t  'fromWireType': decodeMemoryView,\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': decodeMemoryView,\r\n\t\t}, {\r\n\t\t  ignoreDuplicateRegistrations: true,\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\r\n\t/** @suppress {globalThis} */\r\n\tfunction readPointer(pointer) {\r\n\t\treturn this['fromWireType'](HEAPU32[((pointer)>>2)]);\r\n\t  }\r\n\r\n\r\n\tvar stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\r\n\t\tassert(typeof str === 'string');\r\n\t\t// Parameter maxBytesToWrite is not optional. Negative values, 0, null,\r\n\t\t// undefined and false each don't write out any bytes.\r\n\t\tif (!(maxBytesToWrite > 0))\r\n\t\t  return 0;\r\n\r\n\t\tvar startIdx = outIdx;\r\n\t\tvar endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n\t\tfor (var i = 0; i < str.length; ++i) {\r\n\t\t  // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n\t\t  // unit, not a Unicode code point of the character! So decode\r\n\t\t  // UTF16->UTF32->UTF8.\r\n\t\t  // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n\t\t  // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\r\n\t\t  // and https://www.ietf.org/rfc/rfc2279.txt\r\n\t\t  // and https://tools.ietf.org/html/rfc3629\r\n\t\t  var u = str.charCodeAt(i); // possibly a lead surrogate\r\n\t\t  if (u >= 0xD800 && u <= 0xDFFF) {\r\n\t\t\tvar u1 = str.charCodeAt(++i);\r\n\t\t\tu = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n\t\t  }\r\n\t\t  if (u <= 0x7F) {\r\n\t\t\tif (outIdx >= endIdx) break;\r\n\t\t\theap[outIdx++] = u;\r\n\t\t  } else if (u <= 0x7FF) {\r\n\t\t\tif (outIdx + 1 >= endIdx) break;\r\n\t\t\theap[outIdx++] = 0xC0 | (u >> 6);\r\n\t\t\theap[outIdx++] = 0x80 | (u & 63);\r\n\t\t  } else if (u <= 0xFFFF) {\r\n\t\t\tif (outIdx + 2 >= endIdx) break;\r\n\t\t\theap[outIdx++] = 0xE0 | (u >> 12);\r\n\t\t\theap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n\t\t\theap[outIdx++] = 0x80 | (u & 63);\r\n\t\t  } else {\r\n\t\t\tif (outIdx + 3 >= endIdx) break;\r\n\t\t\tif (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\r\n\t\t\theap[outIdx++] = 0xF0 | (u >> 18);\r\n\t\t\theap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n\t\t\theap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n\t\t\theap[outIdx++] = 0x80 | (u & 63);\r\n\t\t  }\r\n\t\t}\r\n\t\t// Null-terminate the pointer to the buffer.\r\n\t\theap[outIdx] = 0;\r\n\t\treturn outIdx - startIdx;\r\n\t  };\r\n\tvar stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\r\n\t\tassert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n\t\treturn stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\r\n\t  };\r\n\r\n\tvar lengthBytesUTF8 = (str) => {\r\n\t\tvar len = 0;\r\n\t\tfor (var i = 0; i < str.length; ++i) {\r\n\t\t  // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n\t\t  // unit, not a Unicode code point of the character! So decode\r\n\t\t  // UTF16->UTF32->UTF8.\r\n\t\t  // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n\t\t  var c = str.charCodeAt(i); // possibly a lead surrogate\r\n\t\t  if (c <= 0x7F) {\r\n\t\t\tlen++;\r\n\t\t  } else if (c <= 0x7FF) {\r\n\t\t\tlen += 2;\r\n\t\t  } else if (c >= 0xD800 && c <= 0xDFFF) {\r\n\t\t\tlen += 4; ++i;\r\n\t\t  } else {\r\n\t\t\tlen += 3;\r\n\t\t  }\r\n\t\t}\r\n\t\treturn len;\r\n\t  };\r\n\r\n\r\n\r\n\tvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\r\n\r\n\t  /**\r\n\t   * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n\t   * array that contains uint8 values, returns a copy of that string as a\r\n\t   * Javascript String object.\r\n\t   * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n\t   * @param {number} idx\r\n\t   * @param {number=} maxBytesToRead\r\n\t   * @return {string}\r\n\t   */\r\n\tvar UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\r\n\t\tvar endIdx = idx + maxBytesToRead;\r\n\t\tvar endPtr = idx;\r\n\t\t// TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n\t\t// null terminator by itself.  Also, use the length info to avoid running tiny\r\n\t\t// strings through TextDecoder, since .subarray() allocates garbage.\r\n\t\t// (As a tiny code save trick, compare endPtr against endIdx using a negation,\r\n\t\t// so that undefined means Infinity)\r\n\t\twhile (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n\r\n\t\tif (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n\t\t  return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n\t\t}\r\n\t\tvar str = '';\r\n\t\t// If building with TextDecoder, we have already computed the string length\r\n\t\t// above, so test loop end condition against that\r\n\t\twhile (idx < endPtr) {\r\n\t\t  // For UTF8 byte structure, see:\r\n\t\t  // http://en.wikipedia.org/wiki/UTF-8#Description\r\n\t\t  // https://www.ietf.org/rfc/rfc2279.txt\r\n\t\t  // https://tools.ietf.org/html/rfc3629\r\n\t\t  var u0 = heapOrArray[idx++];\r\n\t\t  if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n\t\t  var u1 = heapOrArray[idx++] & 63;\r\n\t\t  if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n\t\t  var u2 = heapOrArray[idx++] & 63;\r\n\t\t  if ((u0 & 0xF0) == 0xE0) {\r\n\t\t\tu0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n\t\t  } else {\r\n\t\t\tif ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\r\n\t\t\tu0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n\t\t  }\r\n\r\n\t\t  if (u0 < 0x10000) {\r\n\t\t\tstr += String.fromCharCode(u0);\r\n\t\t  } else {\r\n\t\t\tvar ch = u0 - 0x10000;\r\n\t\t\tstr += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n\t\t  }\r\n\t\t}\r\n\t\treturn str;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n\t   * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n\t   *\r\n\t   * @param {number} ptr\r\n\t   * @param {number=} maxBytesToRead - An optional length that specifies the\r\n\t   *   maximum number of bytes to read. You can omit this parameter to scan the\r\n\t   *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n\t   *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n\t   *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n\t   *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n\t   *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n\t   *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n\t   * @return {string}\r\n\t   */\r\n\tvar UTF8ToString = (ptr, maxBytesToRead) => {\r\n\t\tassert(typeof ptr == 'number');\r\n\t\treturn ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n\t  };\r\n\tvar __embind_register_std_string = (rawType, name) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tvar stdStringIsUTF8\r\n\t\t//process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\r\n\t\t= (name === \"std::string\");\r\n\r\n\t\tregisterType(rawType, {\r\n\t\t  name,\r\n\t\t  // For some method names we use string keys here since they are part of\r\n\t\t  // the public/external API and/or used by the runtime-generated code.\r\n\t\t  'fromWireType'(value) {\r\n\t\t\tvar length = HEAPU32[((value)>>2)];\r\n\t\t\tvar payload = value + 4;\r\n\r\n\t\t\tvar str;\r\n\t\t\tif (stdStringIsUTF8) {\r\n\t\t\t  var decodeStartPtr = payload;\r\n\t\t\t  // Looping here to support possible embedded '0' bytes\r\n\t\t\t  for (var i = 0; i <= length; ++i) {\r\n\t\t\t\tvar currentBytePtr = payload + i;\r\n\t\t\t\tif (i == length || HEAPU8[currentBytePtr] == 0) {\r\n\t\t\t\t  var maxRead = currentBytePtr - decodeStartPtr;\r\n\t\t\t\t  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n\t\t\t\t  if (str === undefined) {\r\n\t\t\t\t\tstr = stringSegment;\r\n\t\t\t\t  } else {\r\n\t\t\t\t\tstr += String.fromCharCode(0);\r\n\t\t\t\t\tstr += stringSegment;\r\n\t\t\t\t  }\r\n\t\t\t\t  decodeStartPtr = currentBytePtr + 1;\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t} else {\r\n\t\t\t  var a = new Array(length);\r\n\t\t\t  for (var i = 0; i < length; ++i) {\r\n\t\t\t\ta[i] = String.fromCharCode(HEAPU8[payload + i]);\r\n\t\t\t  }\r\n\t\t\t  str = a.join('');\r\n\t\t\t}\r\n\r\n\t\t\t_free(value);\r\n\r\n\t\t\treturn str;\r\n\t\t  },\r\n\t\t  'toWireType'(destructors, value) {\r\n\t\t\tif (value instanceof ArrayBuffer) {\r\n\t\t\t  value = new Uint8Array(value);\r\n\t\t\t}\r\n\r\n\t\t\tvar length;\r\n\t\t\tvar valueIsOfTypeString = (typeof value == 'string');\r\n\r\n\t\t\tif (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n\t\t\t  throwBindingError('Cannot pass non-string to std::string');\r\n\t\t\t}\r\n\t\t\tif (stdStringIsUTF8 && valueIsOfTypeString) {\r\n\t\t\t  length = lengthBytesUTF8(value);\r\n\t\t\t} else {\r\n\t\t\t  length = value.length;\r\n\t\t\t}\r\n\r\n\t\t\t// assumes 4-byte alignment\r\n\t\t\tvar base = _malloc(4 + length + 1);\r\n\t\t\tvar ptr = base + 4;\r\n\t\t\tHEAPU32[((base)>>2)] = length;\r\n\t\t\tif (stdStringIsUTF8 && valueIsOfTypeString) {\r\n\t\t\t  stringToUTF8(value, ptr, length + 1);\r\n\t\t\t} else {\r\n\t\t\t  if (valueIsOfTypeString) {\r\n\t\t\t\tfor (var i = 0; i < length; ++i) {\r\n\t\t\t\t  var charCode = value.charCodeAt(i);\r\n\t\t\t\t  if (charCode > 255) {\r\n\t\t\t\t\t_free(ptr);\r\n\t\t\t\t\tthrowBindingError('String has UTF-16 code units that do not fit in 8 bits');\r\n\t\t\t\t  }\r\n\t\t\t\t  HEAPU8[ptr + i] = charCode;\r\n\t\t\t\t}\r\n\t\t\t  } else {\r\n\t\t\t\tfor (var i = 0; i < length; ++i) {\r\n\t\t\t\t  HEAPU8[ptr + i] = value[i];\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t}\r\n\r\n\t\t\tif (destructors !== null) {\r\n\t\t\t  destructors.push(_free, base);\r\n\t\t\t}\r\n\t\t\treturn base;\r\n\t\t  },\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': readPointer,\r\n\t\t  destructorFunction(ptr) {\r\n\t\t\t_free(ptr);\r\n\t\t  },\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\r\n\r\n\tvar UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;  var UTF16ToString = (ptr, maxBytesToRead) => {\r\n\t\tassert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\r\n\t\tvar endPtr = ptr;\r\n\t\t// TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n\t\t// null terminator by itself.\r\n\t\t// Also, use the length info to avoid running tiny strings through\r\n\t\t// TextDecoder, since .subarray() allocates garbage.\r\n\t\tvar idx = endPtr >> 1;\r\n\t\tvar maxIdx = idx + maxBytesToRead / 2;\r\n\t\t// If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n\t\t// will always evaluate to true. This saves on code size.\r\n\t\twhile (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n\t\tendPtr = idx << 1;\r\n\r\n\t\tif (endPtr - ptr > 32 && UTF16Decoder)\r\n\t\t  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n\r\n\t\t// Fallback: decode without UTF16Decoder\r\n\t\tvar str = '';\r\n\r\n\t\t// If maxBytesToRead is not passed explicitly, it will be undefined, and the\r\n\t\t// for-loop's condition will always evaluate to true. The loop is then\r\n\t\t// terminated on the first null char.\r\n\t\tfor (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n\t\t  var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n\t\t  if (codeUnit == 0) break;\r\n\t\t  // fromCharCode constructs a character from a UTF-16 code unit, so we can\r\n\t\t  // pass the UTF16 string right through.\r\n\t\t  str += String.fromCharCode(codeUnit);\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t  };\r\n\r\n\tvar stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\r\n\t\tassert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\r\n\t\tassert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n\t\t// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n\t\tif (maxBytesToWrite === undefined) {\r\n\t\t  maxBytesToWrite = 0x7FFFFFFF;\r\n\t\t}\r\n\t\tif (maxBytesToWrite < 2) return 0;\r\n\t\tmaxBytesToWrite -= 2; // Null terminator.\r\n\t\tvar startPtr = outPtr;\r\n\t\tvar numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n\t\tfor (var i = 0; i < numCharsToWrite; ++i) {\r\n\t\t  // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n\t\t  var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n\t\t  HEAP16[((outPtr)>>1)] = codeUnit;\r\n\t\t  outPtr += 2;\r\n\t\t}\r\n\t\t// Null-terminate the pointer to the HEAP.\r\n\t\tHEAP16[((outPtr)>>1)] = 0;\r\n\t\treturn outPtr - startPtr;\r\n\t  };\r\n\r\n\tvar lengthBytesUTF16 = (str) => {\r\n\t\treturn str.length*2;\r\n\t  };\r\n\r\n\tvar UTF32ToString = (ptr, maxBytesToRead) => {\r\n\t\tassert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\r\n\t\tvar i = 0;\r\n\r\n\t\tvar str = '';\r\n\t\t// If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n\t\t// will always evaluate to true. This saves on code size.\r\n\t\twhile (!(i >= maxBytesToRead / 4)) {\r\n\t\t  var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n\t\t  if (utf32 == 0) break;\r\n\t\t  ++i;\r\n\t\t  // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n\t\t  // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n\t\t  if (utf32 >= 0x10000) {\r\n\t\t\tvar ch = utf32 - 0x10000;\r\n\t\t\tstr += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n\t\t  } else {\r\n\t\t\tstr += String.fromCharCode(utf32);\r\n\t\t  }\r\n\t\t}\r\n\t\treturn str;\r\n\t  };\r\n\r\n\tvar stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\r\n\t\tassert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\r\n\t\tassert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n\t\t// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n\t\tif (maxBytesToWrite === undefined) {\r\n\t\t  maxBytesToWrite = 0x7FFFFFFF;\r\n\t\t}\r\n\t\tif (maxBytesToWrite < 4) return 0;\r\n\t\tvar startPtr = outPtr;\r\n\t\tvar endPtr = startPtr + maxBytesToWrite - 4;\r\n\t\tfor (var i = 0; i < str.length; ++i) {\r\n\t\t  // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n\t\t  // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n\t\t  var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n\t\t  if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n\t\t\tvar trailSurrogate = str.charCodeAt(++i);\r\n\t\t\tcodeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n\t\t  }\r\n\t\t  HEAP32[((outPtr)>>2)] = codeUnit;\r\n\t\t  outPtr += 4;\r\n\t\t  if (outPtr + 4 > endPtr) break;\r\n\t\t}\r\n\t\t// Null-terminate the pointer to the HEAP.\r\n\t\tHEAP32[((outPtr)>>2)] = 0;\r\n\t\treturn outPtr - startPtr;\r\n\t  };\r\n\r\n\tvar lengthBytesUTF32 = (str) => {\r\n\t\tvar len = 0;\r\n\t\tfor (var i = 0; i < str.length; ++i) {\r\n\t\t  // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n\t\t  // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n\t\t  var codeUnit = str.charCodeAt(i);\r\n\t\t  if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n\t\t  len += 4;\r\n\t\t}\r\n\r\n\t\treturn len;\r\n\t  };\r\n\tvar __embind_register_std_wstring = (rawType, charSize, name) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tvar decodeString, encodeString, getHeap, lengthBytesUTF, shift;\r\n\t\tif (charSize === 2) {\r\n\t\t  decodeString = UTF16ToString;\r\n\t\t  encodeString = stringToUTF16;\r\n\t\t  lengthBytesUTF = lengthBytesUTF16;\r\n\t\t  getHeap = () => HEAPU16;\r\n\t\t  shift = 1;\r\n\t\t} else if (charSize === 4) {\r\n\t\t  decodeString = UTF32ToString;\r\n\t\t  encodeString = stringToUTF32;\r\n\t\t  lengthBytesUTF = lengthBytesUTF32;\r\n\t\t  getHeap = () => HEAPU32;\r\n\t\t  shift = 2;\r\n\t\t}\r\n\t\tregisterType(rawType, {\r\n\t\t  name,\r\n\t\t  'fromWireType': (value) => {\r\n\t\t\t// Code mostly taken from _embind_register_std_string fromWireType\r\n\t\t\tvar length = HEAPU32[((value)>>2)];\r\n\t\t\tvar HEAP = getHeap();\r\n\t\t\tvar str;\r\n\r\n\t\t\tvar decodeStartPtr = value + 4;\r\n\t\t\t// Looping here to support possible embedded '0' bytes\r\n\t\t\tfor (var i = 0; i <= length; ++i) {\r\n\t\t\t  var currentBytePtr = value + 4 + i * charSize;\r\n\t\t\t  if (i == length || HEAP[currentBytePtr >> shift] == 0) {\r\n\t\t\t\tvar maxReadBytes = currentBytePtr - decodeStartPtr;\r\n\t\t\t\tvar stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n\t\t\t\tif (str === undefined) {\r\n\t\t\t\t  str = stringSegment;\r\n\t\t\t\t} else {\r\n\t\t\t\t  str += String.fromCharCode(0);\r\n\t\t\t\t  str += stringSegment;\r\n\t\t\t\t}\r\n\t\t\t\tdecodeStartPtr = currentBytePtr + charSize;\r\n\t\t\t  }\r\n\t\t\t}\r\n\r\n\t\t\t_free(value);\r\n\r\n\t\t\treturn str;\r\n\t\t  },\r\n\t\t  'toWireType': (destructors, value) => {\r\n\t\t\tif (!(typeof value == 'string')) {\r\n\t\t\t  throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\r\n\t\t\t}\r\n\r\n\t\t\t// assumes 4-byte alignment\r\n\t\t\tvar length = lengthBytesUTF(value);\r\n\t\t\tvar ptr = _malloc(4 + length + charSize);\r\n\t\t\tHEAPU32[ptr >> 2] = length >> shift;\r\n\r\n\t\t\tencodeString(value, ptr + 4, length + charSize);\r\n\r\n\t\t\tif (destructors !== null) {\r\n\t\t\t  destructors.push(_free, ptr);\r\n\t\t\t}\r\n\t\t\treturn ptr;\r\n\t\t  },\r\n\t\t  'argPackAdvance': GenericWireTypeSize,\r\n\t\t  'readValueFromPointer': simpleReadValueFromPointer,\r\n\t\t  destructorFunction(ptr) {\r\n\t\t\t_free(ptr);\r\n\t\t  }\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\r\n\tvar __embind_register_value_object = (\r\n\t\trawType,\r\n\t\tname,\r\n\t\tconstructorSignature,\r\n\t\trawConstructor,\r\n\t\tdestructorSignature,\r\n\t\trawDestructor\r\n\t  ) => {\r\n\t\tstructRegistrations[rawType] = {\r\n\t\t  name: readLatin1String(name),\r\n\t\t  rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n\t\t  rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n\t\t  fields: [],\r\n\t\t};\r\n\t  };\r\n\r\n\r\n\r\n\tvar __embind_register_value_object_field = (\r\n\t\tstructType,\r\n\t\tfieldName,\r\n\t\tgetterReturnType,\r\n\t\tgetterSignature,\r\n\t\tgetter,\r\n\t\tgetterContext,\r\n\t\tsetterArgumentType,\r\n\t\tsetterSignature,\r\n\t\tsetter,\r\n\t\tsetterContext\r\n\t  ) => {\r\n\t\tstructRegistrations[structType].fields.push({\r\n\t\t  fieldName: readLatin1String(fieldName),\r\n\t\t  getterReturnType,\r\n\t\t  getter: embind__requireFunction(getterSignature, getter),\r\n\t\t  getterContext,\r\n\t\t  setterArgumentType,\r\n\t\t  setter: embind__requireFunction(setterSignature, setter),\r\n\t\t  setterContext,\r\n\t\t});\r\n\t  };\r\n\r\n\r\n\tvar __embind_register_void = (rawType, name) => {\r\n\t\tname = readLatin1String(name);\r\n\t\tregisterType(rawType, {\r\n\t\t  isVoid: true, // void return values can be optimized out sometimes\r\n\t\t  name,\r\n\t\t  'argPackAdvance': 0,\r\n\t\t  'fromWireType': () => undefined,\r\n\t\t  // TODO: assert if anything else is given?\r\n\t\t  'toWireType': (destructors, o) => undefined,\r\n\t\t});\r\n\t  };\r\n\r\n\tvar __emscripten_throw_longjmp = () => {\r\n\t\tthrow Infinity;\r\n\t  };\r\n\r\n\r\n\tvar __emval_incref = (handle) => {\r\n\t\tif (handle > 4) {\r\n\t\t  emval_handles.get(handle).refcount += 1;\r\n\t\t}\r\n\t  };\r\n\r\n\tvar emval_symbols = {\r\n\t};\r\n\r\n\tvar getStringOrSymbol = (address) => {\r\n\t\tvar symbol = emval_symbols[address];\r\n\t\tif (symbol === undefined) {\r\n\t\t  return readLatin1String(address);\r\n\t\t}\r\n\t\treturn symbol;\r\n\t  };\r\n\r\n\tvar __emval_new_cstring = (v) => {\r\n\t\treturn Emval.toHandle(getStringOrSymbol(v));\r\n\t  };\r\n\r\n\r\n\r\n\r\n\tvar requireRegisteredType = (rawType, humanName) => {\r\n\t\tvar impl = registeredTypes[rawType];\r\n\t\tif (undefined === impl) {\r\n\t\t\tthrowBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\r\n\t\t}\r\n\t\treturn impl;\r\n\t  };\r\n\tvar __emval_take_value = (type, arg) => {\r\n\t\ttype = requireRegisteredType(type, '_emval_take_value');\r\n\t\tvar v = type['readValueFromPointer'](arg);\r\n\t\treturn Emval.toHandle(v);\r\n\t  };\r\n\r\n\tvar _abort = () => {\r\n\t\tabort('native code called abort()');\r\n\t  };\r\n\r\n\tvar _emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\r\n\r\n\tvar getHeapMax = () =>\r\n\t\t// Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\r\n\t\t// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\r\n\t\t// for any code that deals with heap sizes, which would require special\r\n\t\t// casing all heap size related code to treat 0 specially.\r\n\t\t2147483648;\r\n\r\n\tvar growMemory = (size) => {\r\n\t\tvar b = wasmMemory.buffer;\r\n\t\tvar pages = (size - b.byteLength + 65535) / 65536;\r\n\t\ttry {\r\n\t\t  // round size grow request up to wasm page size (fixed 64KB per spec)\r\n\t\t  wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size\r\n\t\t  updateMemoryViews();\r\n\t\t  return 1 /*success*/;\r\n\t\t} catch(e) {\r\n\t\t  err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\r\n\t\t}\r\n\t\t// implicit 0 return to save code size (caller will cast \"undefined\" into 0\r\n\t\t// anyhow)\r\n\t  };\r\n\tvar _emscripten_resize_heap = (requestedSize) => {\r\n\t\tvar oldSize = HEAPU8.length;\r\n\t\t// With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n\t\trequestedSize >>>= 0;\r\n\t\t// With multithreaded builds, races can happen (another thread might increase the size\r\n\t\t// in between), so return a failure, and let the caller retry.\r\n\t\tassert(requestedSize > oldSize);\r\n\r\n\t\t// Memory resize rules:\r\n\t\t// 1.  Always increase heap size to at least the requested size, rounded up\r\n\t\t//     to next page multiple.\r\n\t\t// 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\r\n\t\t//     geometrically: increase the heap size according to\r\n\t\t//     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\r\n\t\t//     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\r\n\t\t// 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\r\n\t\t//     linearly: increase the heap size by at least\r\n\t\t//     MEMORY_GROWTH_LINEAR_STEP bytes.\r\n\t\t// 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\r\n\t\t//     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\r\n\t\t// 4.  If we were unable to allocate as much memory, it may be due to\r\n\t\t//     over-eager decision to excessively reserve due to (3) above.\r\n\t\t//     Hence if an allocation fails, cut down on the amount of excess\r\n\t\t//     growth, in an attempt to succeed to perform a smaller allocation.\r\n\r\n\t\t// A limit is set for how much we can grow. We should not exceed that\r\n\t\t// (the wasm binary specifies it, so if we tried, we'd fail anyhow).\r\n\t\tvar maxHeapSize = getHeapMax();\r\n\t\tif (requestedSize > maxHeapSize) {\r\n\t\t  err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\r\n\t\t  return false;\r\n\t\t}\r\n\r\n\t\tvar alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\r\n\r\n\t\t// Loop through potential heap size increases. If we attempt a too eager\r\n\t\t// reservation that fails, cut down on the attempted size and reserve a\r\n\t\t// smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\r\n\t\tfor (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\r\n\t\t  var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\r\n\t\t  // but limit overreserving (default to capping at +96MB overgrowth at most)\r\n\t\t  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\r\n\r\n\t\t  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\r\n\r\n\t\t  var replacement = growMemory(newSize);\r\n\t\t  if (replacement) {\r\n\r\n\t\t\treturn true;\r\n\t\t  }\r\n\t\t}\r\n\t\terr(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\r\n\t\treturn false;\r\n\t  };\r\n\r\n\tvar ENV = {\r\n\t};\r\n\r\n\tvar getExecutableName = () => {\r\n\t\treturn thisProgram || './this.program';\r\n\t  };\r\n\tvar getEnvStrings = () => {\r\n\t\tif (!getEnvStrings.strings) {\r\n\t\t  // Default values.\r\n\t\t  // Browser language detection #8751\r\n\t\t  var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\r\n\t\t  var env = {\r\n\t\t\t'USER': 'web_user',\r\n\t\t\t'LOGNAME': 'web_user',\r\n\t\t\t'PATH': '/',\r\n\t\t\t'PWD': '/',\r\n\t\t\t'HOME': '/home/web_user',\r\n\t\t\t'LANG': lang,\r\n\t\t\t'_': getExecutableName()\r\n\t\t  };\r\n\t\t  // Apply the user-provided values, if any.\r\n\t\t  for (var x in ENV) {\r\n\t\t\t// x is a key in ENV; if ENV[x] is undefined, that means it was\r\n\t\t\t// explicitly set to be so. We allow user code to do that to\r\n\t\t\t// force variables with default values to remain unset.\r\n\t\t\tif (ENV[x] === undefined) delete env[x];\r\n\t\t\telse env[x] = ENV[x];\r\n\t\t  }\r\n\t\t  var strings = [];\r\n\t\t  for (var x in env) {\r\n\t\t\tstrings.push(`${x}=${env[x]}`);\r\n\t\t  }\r\n\t\t  getEnvStrings.strings = strings;\r\n\t\t}\r\n\t\treturn getEnvStrings.strings;\r\n\t  };\r\n\r\n\tvar stringToAscii = (str, buffer) => {\r\n\t\tfor (var i = 0; i < str.length; ++i) {\r\n\t\t  assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\r\n\t\t  HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\r\n\t\t}\r\n\t\t// Null-terminate the string\r\n\t\tHEAP8[((buffer)>>0)] = 0;\r\n\t  };\r\n\r\n\tvar PATH = {\r\n\tisAbs:(path) => path.charAt(0) === '/',\r\n\tsplitPath:(filename) => {\r\n\t\t  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\t\t  return splitPathRe.exec(filename).slice(1);\r\n\t\t},\r\n\tnormalizeArray:(parts, allowAboveRoot) => {\r\n\t\t  // if the path tries to go above the root, `up` ends up > 0\r\n\t\t  var up = 0;\r\n\t\t  for (var i = parts.length - 1; i >= 0; i--) {\r\n\t\t\tvar last = parts[i];\r\n\t\t\tif (last === '.') {\r\n\t\t\t  parts.splice(i, 1);\r\n\t\t\t} else if (last === '..') {\r\n\t\t\t  parts.splice(i, 1);\r\n\t\t\t  up++;\r\n\t\t\t} else if (up) {\r\n\t\t\t  parts.splice(i, 1);\r\n\t\t\t  up--;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // if the path is allowed to go above the root, restore leading ..s\r\n\t\t  if (allowAboveRoot) {\r\n\t\t\tfor (; up; up--) {\r\n\t\t\t  parts.unshift('..');\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  return parts;\r\n\t\t},\r\n\tnormalize:(path) => {\r\n\t\t  var isAbsolute = PATH.isAbs(path),\r\n\t\t\t  trailingSlash = path.substr(-1) === '/';\r\n\t\t  // Normalize the path\r\n\t\t  path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\r\n\t\t  if (!path && !isAbsolute) {\r\n\t\t\tpath = '.';\r\n\t\t  }\r\n\t\t  if (path && trailingSlash) {\r\n\t\t\tpath += '/';\r\n\t\t  }\r\n\t\t  return (isAbsolute ? '/' : '') + path;\r\n\t\t},\r\n\tdirname:(path) => {\r\n\t\t  var result = PATH.splitPath(path),\r\n\t\t\t  root = result[0],\r\n\t\t\t  dir = result[1];\r\n\t\t  if (!root && !dir) {\r\n\t\t\t// No dirname whatsoever\r\n\t\t\treturn '.';\r\n\t\t  }\r\n\t\t  if (dir) {\r\n\t\t\t// It has a dirname, strip trailing slash\r\n\t\t\tdir = dir.substr(0, dir.length - 1);\r\n\t\t  }\r\n\t\t  return root + dir;\r\n\t\t},\r\n\tbasename:(path) => {\r\n\t\t  // EMSCRIPTEN return '/'' for '/', not an empty string\r\n\t\t  if (path === '/') return '/';\r\n\t\t  path = PATH.normalize(path);\r\n\t\t  path = path.replace(/\\/$/, \"\");\r\n\t\t  var lastSlash = path.lastIndexOf('/');\r\n\t\t  if (lastSlash === -1) return path;\r\n\t\t  return path.substr(lastSlash+1);\r\n\t\t},\r\n\tjoin:function() {\r\n\t\t  var paths = Array.prototype.slice.call(arguments);\r\n\t\t  return PATH.normalize(paths.join('/'));\r\n\t\t},\r\n\tjoin2:(l, r) => {\r\n\t\t  return PATH.normalize(l + '/' + r);\r\n\t\t},\r\n\t};\r\n\r\n\tvar initRandomFill = () => {\r\n\t\tif (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\r\n\t\t  // for modern web browsers\r\n\t\t  return (view) => crypto.getRandomValues(view);\r\n\t\t} else\r\n\t\tif (ENVIRONMENT_IS_NODE) {\r\n\t\t  // for nodejs with or without crypto support included\r\n\t\t  try {\r\n\t\t\tvar crypto_module = require('crypto');\r\n\t\t\tvar randomFillSync = crypto_module['randomFillSync'];\r\n\t\t\tif (randomFillSync) {\r\n\t\t\t  // nodejs with LTS crypto support\r\n\t\t\t  return (view) => crypto_module['randomFillSync'](view);\r\n\t\t\t}\r\n\t\t\t// very old nodejs with the original crypto API\r\n\t\t\tvar randomBytes = crypto_module['randomBytes'];\r\n\t\t\treturn (view) => (\r\n\t\t\t  view.set(randomBytes(view.byteLength)),\r\n\t\t\t  // Return the original view to match modern native implementations.\r\n\t\t\t  view\r\n\t\t\t);\r\n\t\t  } catch (e) {\r\n\t\t\t// nodejs doesn't have crypto support\r\n\t\t  }\r\n\t\t}\r\n\t\t// we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\r\n\t\tabort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\r\n\t  };\r\n\tvar randomFill = (view) => {\r\n\t\t// Lazily init on the first invocation.\r\n\t\treturn (randomFill = initRandomFill())(view);\r\n\t  };\r\n\r\n\r\n\r\n\tvar PATH_FS = {\r\n\tresolve:function() {\r\n\t\t  var resolvedPath = '',\r\n\t\t\tresolvedAbsolute = false;\r\n\t\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n\t\t\tvar path = (i >= 0) ? arguments[i] : FS.cwd();\r\n\t\t\t// Skip empty and invalid entries\r\n\t\t\tif (typeof path != 'string') {\r\n\t\t\t  throw new TypeError('Arguments to path.resolve must be strings');\r\n\t\t\t} else if (!path) {\r\n\t\t\t  return ''; // an invalid portion invalidates the whole thing\r\n\t\t\t}\r\n\t\t\tresolvedPath = path + '/' + resolvedPath;\r\n\t\t\tresolvedAbsolute = PATH.isAbs(path);\r\n\t\t  }\r\n\t\t  // At this point the path should be resolved to a full absolute path, but\r\n\t\t  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\t\t  resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\r\n\t\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n\t\t},\r\n\trelative:(from, to) => {\r\n\t\t  from = PATH_FS.resolve(from).substr(1);\r\n\t\t  to = PATH_FS.resolve(to).substr(1);\r\n\t\t  function trim(arr) {\r\n\t\t\tvar start = 0;\r\n\t\t\tfor (; start < arr.length; start++) {\r\n\t\t\t  if (arr[start] !== '') break;\r\n\t\t\t}\r\n\t\t\tvar end = arr.length - 1;\r\n\t\t\tfor (; end >= 0; end--) {\r\n\t\t\t  if (arr[end] !== '') break;\r\n\t\t\t}\r\n\t\t\tif (start > end) return [];\r\n\t\t\treturn arr.slice(start, end - start + 1);\r\n\t\t  }\r\n\t\t  var fromParts = trim(from.split('/'));\r\n\t\t  var toParts = trim(to.split('/'));\r\n\t\t  var length = Math.min(fromParts.length, toParts.length);\r\n\t\t  var samePartsLength = length;\r\n\t\t  for (var i = 0; i < length; i++) {\r\n\t\t\tif (fromParts[i] !== toParts[i]) {\r\n\t\t\t  samePartsLength = i;\r\n\t\t\t  break;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  var outputParts = [];\r\n\t\t  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n\t\t\toutputParts.push('..');\r\n\t\t  }\r\n\t\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\t\t  return outputParts.join('/');\r\n\t\t},\r\n\t};\r\n\r\n\r\n\r\n\tvar FS_stdin_getChar_buffer = [];\r\n\r\n\r\n\t/** @type {function(string, boolean=, number=)} */\r\n\tfunction intArrayFromString(stringy, dontAddNull, length) {\r\n\t  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n\t  var u8array = new Array(len);\r\n\t  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n\t  if (dontAddNull) u8array.length = numBytesWritten;\r\n\t  return u8array;\r\n\t}\r\n\tvar FS_stdin_getChar = () => {\r\n\t\tif (!FS_stdin_getChar_buffer.length) {\r\n\t\t  var result = null;\r\n\t\t  if (ENVIRONMENT_IS_NODE) {\r\n\t\t\t// we will read data by chunks of BUFSIZE\r\n\t\t\tvar BUFSIZE = 256;\r\n\t\t\tvar buf = Buffer.alloc(BUFSIZE);\r\n\t\t\tvar bytesRead = 0;\r\n\r\n\t\t\t// For some reason we must suppress a closure warning here, even though\r\n\t\t\t// fd definitely exists on process.stdin, and is even the proper way to\r\n\t\t\t// get the fd of stdin,\r\n\t\t\t// https://github.com/nodejs/help/issues/2136#issuecomment-523649904\r\n\t\t\t// This started to happen after moving this logic out of library_tty.js,\r\n\t\t\t// so it is related to the surrounding code in some unclear manner.\r\n\t\t\t/** @suppress {missingProperties} */\r\n\t\t\tvar fd = process.stdin.fd;\r\n\r\n\t\t\ttry {\r\n\t\t\t  bytesRead = fs.readSync(fd, buf);\r\n\t\t\t} catch(e) {\r\n\t\t\t  // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\r\n\t\t\t  // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\r\n\t\t\t  if (e.toString().includes('EOF')) bytesRead = 0;\r\n\t\t\t  else throw e;\r\n\t\t\t}\r\n\r\n\t\t\tif (bytesRead > 0) {\r\n\t\t\t  result = buf.slice(0, bytesRead).toString('utf-8');\r\n\t\t\t} else {\r\n\t\t\t  result = null;\r\n\t\t\t}\r\n\t\t  } else\r\n\t\t  if (typeof window != 'undefined' &&\r\n\t\t\ttypeof window.prompt == 'function') {\r\n\t\t\t// Browser.\r\n\t\t\tresult = window.prompt('Input: ');  // returns null on cancel\r\n\t\t\tif (result !== null) {\r\n\t\t\t  result += '\\n';\r\n\t\t\t}\r\n\t\t  } else if (typeof readline == 'function') {\r\n\t\t\t// Command line.\r\n\t\t\tresult = readline();\r\n\t\t\tif (result !== null) {\r\n\t\t\t  result += '\\n';\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  if (!result) {\r\n\t\t\treturn null;\r\n\t\t  }\r\n\t\t  FS_stdin_getChar_buffer = intArrayFromString(result, true);\r\n\t\t}\r\n\t\treturn FS_stdin_getChar_buffer.shift();\r\n\t  };\r\n\tvar TTY = {\r\n\tttys:[],\r\n\tinit() {\r\n\t\t  // https://github.com/emscripten-core/emscripten/pull/1555\r\n\t\t  // if (ENVIRONMENT_IS_NODE) {\r\n\t\t  //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n\t\t  //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n\t\t  //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n\t\t  //   // with text files until FS.init can be refactored.\r\n\t\t  //   process.stdin.setEncoding('utf8');\r\n\t\t  // }\r\n\t\t},\r\n\tshutdown() {\r\n\t\t  // https://github.com/emscripten-core/emscripten/pull/1555\r\n\t\t  // if (ENVIRONMENT_IS_NODE) {\r\n\t\t  //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n\t\t  //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n\t\t  //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n\t\t  //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n\t\t  //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n\t\t  //   process.stdin.pause();\r\n\t\t  // }\r\n\t\t},\r\n\tregister(dev, ops) {\r\n\t\t  TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n\t\t  FS.registerDevice(dev, TTY.stream_ops);\r\n\t\t},\r\n\tstream_ops:{\r\n\topen(stream) {\r\n\t\t\tvar tty = TTY.ttys[stream.node.rdev];\r\n\t\t\tif (!tty) {\r\n\t\t\t  throw new FS.ErrnoError(43);\r\n\t\t\t}\r\n\t\t\tstream.tty = tty;\r\n\t\t\tstream.seekable = false;\r\n\t\t  },\r\n\tclose(stream) {\r\n\t\t\t// flush any pending line data\r\n\t\t\tstream.tty.ops.fsync(stream.tty);\r\n\t\t  },\r\n\tfsync(stream) {\r\n\t\t\tstream.tty.ops.fsync(stream.tty);\r\n\t\t  },\r\n\tread(stream, buffer, offset, length, pos /* ignored */) {\r\n\t\t\tif (!stream.tty || !stream.tty.ops.get_char) {\r\n\t\t\t  throw new FS.ErrnoError(60);\r\n\t\t\t}\r\n\t\t\tvar bytesRead = 0;\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t  var result;\r\n\t\t\t  try {\r\n\t\t\t\tresult = stream.tty.ops.get_char(stream.tty);\r\n\t\t\t  } catch (e) {\r\n\t\t\t\tthrow new FS.ErrnoError(29);\r\n\t\t\t  }\r\n\t\t\t  if (result === undefined && bytesRead === 0) {\r\n\t\t\t\tthrow new FS.ErrnoError(6);\r\n\t\t\t  }\r\n\t\t\t  if (result === null || result === undefined) break;\r\n\t\t\t  bytesRead++;\r\n\t\t\t  buffer[offset+i] = result;\r\n\t\t\t}\r\n\t\t\tif (bytesRead) {\r\n\t\t\t  stream.node.timestamp = Date.now();\r\n\t\t\t}\r\n\t\t\treturn bytesRead;\r\n\t\t  },\r\n\twrite(stream, buffer, offset, length, pos) {\r\n\t\t\tif (!stream.tty || !stream.tty.ops.put_char) {\r\n\t\t\t  throw new FS.ErrnoError(60);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t  for (var i = 0; i < length; i++) {\r\n\t\t\t\tstream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n\t\t\t  }\r\n\t\t\t} catch (e) {\r\n\t\t\t  throw new FS.ErrnoError(29);\r\n\t\t\t}\r\n\t\t\tif (length) {\r\n\t\t\t  stream.node.timestamp = Date.now();\r\n\t\t\t}\r\n\t\t\treturn i;\r\n\t\t  },\r\n\t},\r\n\tdefault_tty_ops:{\r\n\tget_char(tty) {\r\n\t\t\treturn FS_stdin_getChar();\r\n\t\t  },\r\n\tput_char(tty, val) {\r\n\t\t\tif (val === null || val === 10) {\r\n\t\t\t  out(UTF8ArrayToString(tty.output, 0));\r\n\t\t\t  tty.output = [];\r\n\t\t\t} else {\r\n\t\t\t  if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n\t\t\t}\r\n\t\t  },\r\n\tfsync(tty) {\r\n\t\t\tif (tty.output && tty.output.length > 0) {\r\n\t\t\t  out(UTF8ArrayToString(tty.output, 0));\r\n\t\t\t  tty.output = [];\r\n\t\t\t}\r\n\t\t  },\r\n\tioctl_tcgets(tty) {\r\n\t\t\t// typical setting\r\n\t\t\treturn {\r\n\t\t\t  c_iflag: 25856,\r\n\t\t\t  c_oflag: 5,\r\n\t\t\t  c_cflag: 191,\r\n\t\t\t  c_lflag: 35387,\r\n\t\t\t  c_cc: [\r\n\t\t\t\t0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\r\n\t\t\t\t0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t\t\t  ]\r\n\t\t\t};\r\n\t\t  },\r\n\tioctl_tcsets(tty, optional_actions, data) {\r\n\t\t\t// currently just ignore\r\n\t\t\treturn 0;\r\n\t\t  },\r\n\tioctl_tiocgwinsz(tty) {\r\n\t\t\treturn [24, 80];\r\n\t\t  },\r\n\t},\r\n\tdefault_tty1_ops:{\r\n\tput_char(tty, val) {\r\n\t\t\tif (val === null || val === 10) {\r\n\t\t\t  err(UTF8ArrayToString(tty.output, 0));\r\n\t\t\t  tty.output = [];\r\n\t\t\t} else {\r\n\t\t\t  if (val != 0) tty.output.push(val);\r\n\t\t\t}\r\n\t\t  },\r\n\tfsync(tty) {\r\n\t\t\tif (tty.output && tty.output.length > 0) {\r\n\t\t\t  err(UTF8ArrayToString(tty.output, 0));\r\n\t\t\t  tty.output = [];\r\n\t\t\t}\r\n\t\t  },\r\n\t},\r\n\t};\r\n\tvar mmapAlloc = (size) => {\r\n\t\tabort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');\r\n\t  };\r\n\tvar MEMFS = {\r\n\tops_table:null,\r\n\tmount(mount) {\r\n\t\t  return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\r\n\t\t},\r\n\tcreateNode(parent, name, mode, dev) {\r\n\t\t  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n\t\t\t// no supported\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  if (!MEMFS.ops_table) {\r\n\t\t\tMEMFS.ops_table = {\r\n\t\t\t  dir: {\r\n\t\t\t\tnode: {\r\n\t\t\t\t  getattr: MEMFS.node_ops.getattr,\r\n\t\t\t\t  setattr: MEMFS.node_ops.setattr,\r\n\t\t\t\t  lookup: MEMFS.node_ops.lookup,\r\n\t\t\t\t  mknod: MEMFS.node_ops.mknod,\r\n\t\t\t\t  rename: MEMFS.node_ops.rename,\r\n\t\t\t\t  unlink: MEMFS.node_ops.unlink,\r\n\t\t\t\t  rmdir: MEMFS.node_ops.rmdir,\r\n\t\t\t\t  readdir: MEMFS.node_ops.readdir,\r\n\t\t\t\t  symlink: MEMFS.node_ops.symlink\r\n\t\t\t\t},\r\n\t\t\t\tstream: {\r\n\t\t\t\t  llseek: MEMFS.stream_ops.llseek\r\n\t\t\t\t}\r\n\t\t\t  },\r\n\t\t\t  file: {\r\n\t\t\t\tnode: {\r\n\t\t\t\t  getattr: MEMFS.node_ops.getattr,\r\n\t\t\t\t  setattr: MEMFS.node_ops.setattr\r\n\t\t\t\t},\r\n\t\t\t\tstream: {\r\n\t\t\t\t  llseek: MEMFS.stream_ops.llseek,\r\n\t\t\t\t  read: MEMFS.stream_ops.read,\r\n\t\t\t\t  write: MEMFS.stream_ops.write,\r\n\t\t\t\t  allocate: MEMFS.stream_ops.allocate,\r\n\t\t\t\t  mmap: MEMFS.stream_ops.mmap,\r\n\t\t\t\t  msync: MEMFS.stream_ops.msync\r\n\t\t\t\t}\r\n\t\t\t  },\r\n\t\t\t  link: {\r\n\t\t\t\tnode: {\r\n\t\t\t\t  getattr: MEMFS.node_ops.getattr,\r\n\t\t\t\t  setattr: MEMFS.node_ops.setattr,\r\n\t\t\t\t  readlink: MEMFS.node_ops.readlink\r\n\t\t\t\t},\r\n\t\t\t\tstream: {}\r\n\t\t\t  },\r\n\t\t\t  chrdev: {\r\n\t\t\t\tnode: {\r\n\t\t\t\t  getattr: MEMFS.node_ops.getattr,\r\n\t\t\t\t  setattr: MEMFS.node_ops.setattr\r\n\t\t\t\t},\r\n\t\t\t\tstream: FS.chrdev_stream_ops\r\n\t\t\t  }\r\n\t\t\t};\r\n\t\t  }\r\n\t\t  var node = FS.createNode(parent, name, mode, dev);\r\n\t\t  if (FS.isDir(node.mode)) {\r\n\t\t\tnode.node_ops = MEMFS.ops_table.dir.node;\r\n\t\t\tnode.stream_ops = MEMFS.ops_table.dir.stream;\r\n\t\t\tnode.contents = {};\r\n\t\t  } else if (FS.isFile(node.mode)) {\r\n\t\t\tnode.node_ops = MEMFS.ops_table.file.node;\r\n\t\t\tnode.stream_ops = MEMFS.ops_table.file.stream;\r\n\t\t\tnode.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n\t\t\t// When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n\t\t\t// for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n\t\t\t// penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n\t\t\tnode.contents = null;\r\n\t\t  } else if (FS.isLink(node.mode)) {\r\n\t\t\tnode.node_ops = MEMFS.ops_table.link.node;\r\n\t\t\tnode.stream_ops = MEMFS.ops_table.link.stream;\r\n\t\t  } else if (FS.isChrdev(node.mode)) {\r\n\t\t\tnode.node_ops = MEMFS.ops_table.chrdev.node;\r\n\t\t\tnode.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n\t\t  }\r\n\t\t  node.timestamp = Date.now();\r\n\t\t  // add the new node to the parent\r\n\t\t  if (parent) {\r\n\t\t\tparent.contents[name] = node;\r\n\t\t\tparent.timestamp = node.timestamp;\r\n\t\t  }\r\n\t\t  return node;\r\n\t\t},\r\n\tgetFileDataAsTypedArray(node) {\r\n\t\t  if (!node.contents) return new Uint8Array(0);\r\n\t\t  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n\t\t  return new Uint8Array(node.contents);\r\n\t\t},\r\n\texpandFileStorage(node, newCapacity) {\r\n\t\t  var prevCapacity = node.contents ? node.contents.length : 0;\r\n\t\t  if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n\t\t  // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n\t\t  // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n\t\t  // avoid overshooting the allocation cap by a very large margin.\r\n\t\t  var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n\t\t  newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\r\n\t\t  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n\t\t  var oldContents = node.contents;\r\n\t\t  node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n\t\t  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n\t\t},\r\n\tresizeFileStorage(node, newSize) {\r\n\t\t  if (node.usedBytes == newSize) return;\r\n\t\t  if (newSize == 0) {\r\n\t\t\tnode.contents = null; // Fully decommit when requesting a resize to zero.\r\n\t\t\tnode.usedBytes = 0;\r\n\t\t  } else {\r\n\t\t\tvar oldContents = node.contents;\r\n\t\t\tnode.contents = new Uint8Array(newSize); // Allocate new storage.\r\n\t\t\tif (oldContents) {\r\n\t\t\t  node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n\t\t\t}\r\n\t\t\tnode.usedBytes = newSize;\r\n\t\t  }\r\n\t\t},\r\n\tnode_ops:{\r\n\tgetattr(node) {\r\n\t\t\tvar attr = {};\r\n\t\t\t// device numbers reuse inode numbers.\r\n\t\t\tattr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n\t\t\tattr.ino = node.id;\r\n\t\t\tattr.mode = node.mode;\r\n\t\t\tattr.nlink = 1;\r\n\t\t\tattr.uid = 0;\r\n\t\t\tattr.gid = 0;\r\n\t\t\tattr.rdev = node.rdev;\r\n\t\t\tif (FS.isDir(node.mode)) {\r\n\t\t\t  attr.size = 4096;\r\n\t\t\t} else if (FS.isFile(node.mode)) {\r\n\t\t\t  attr.size = node.usedBytes;\r\n\t\t\t} else if (FS.isLink(node.mode)) {\r\n\t\t\t  attr.size = node.link.length;\r\n\t\t\t} else {\r\n\t\t\t  attr.size = 0;\r\n\t\t\t}\r\n\t\t\tattr.atime = new Date(node.timestamp);\r\n\t\t\tattr.mtime = new Date(node.timestamp);\r\n\t\t\tattr.ctime = new Date(node.timestamp);\r\n\t\t\t// NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n\t\t\t//       but this is not required by the standard.\r\n\t\t\tattr.blksize = 4096;\r\n\t\t\tattr.blocks = Math.ceil(attr.size / attr.blksize);\r\n\t\t\treturn attr;\r\n\t\t  },\r\n\tsetattr(node, attr) {\r\n\t\t\tif (attr.mode !== undefined) {\r\n\t\t\t  node.mode = attr.mode;\r\n\t\t\t}\r\n\t\t\tif (attr.timestamp !== undefined) {\r\n\t\t\t  node.timestamp = attr.timestamp;\r\n\t\t\t}\r\n\t\t\tif (attr.size !== undefined) {\r\n\t\t\t  MEMFS.resizeFileStorage(node, attr.size);\r\n\t\t\t}\r\n\t\t  },\r\n\tlookup(parent, name) {\r\n\t\t\tthrow FS.genericErrors[44];\r\n\t\t  },\r\n\tmknod(parent, name, mode, dev) {\r\n\t\t\treturn MEMFS.createNode(parent, name, mode, dev);\r\n\t\t  },\r\n\trename(old_node, new_dir, new_name) {\r\n\t\t\t// if we're overwriting a directory at new_name, make sure it's empty.\r\n\t\t\tif (FS.isDir(old_node.mode)) {\r\n\t\t\t  var new_node;\r\n\t\t\t  try {\r\n\t\t\t\tnew_node = FS.lookupNode(new_dir, new_name);\r\n\t\t\t  } catch (e) {\r\n\t\t\t  }\r\n\t\t\t  if (new_node) {\r\n\t\t\t\tfor (var i in new_node.contents) {\r\n\t\t\t\t  throw new FS.ErrnoError(55);\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\t// do the internal rewiring\r\n\t\t\tdelete old_node.parent.contents[old_node.name];\r\n\t\t\told_node.parent.timestamp = Date.now();\r\n\t\t\told_node.name = new_name;\r\n\t\t\tnew_dir.contents[new_name] = old_node;\r\n\t\t\tnew_dir.timestamp = old_node.parent.timestamp;\r\n\t\t\told_node.parent = new_dir;\r\n\t\t  },\r\n\tunlink(parent, name) {\r\n\t\t\tdelete parent.contents[name];\r\n\t\t\tparent.timestamp = Date.now();\r\n\t\t  },\r\n\trmdir(parent, name) {\r\n\t\t\tvar node = FS.lookupNode(parent, name);\r\n\t\t\tfor (var i in node.contents) {\r\n\t\t\t  throw new FS.ErrnoError(55);\r\n\t\t\t}\r\n\t\t\tdelete parent.contents[name];\r\n\t\t\tparent.timestamp = Date.now();\r\n\t\t  },\r\n\treaddir(node) {\r\n\t\t\tvar entries = ['.', '..'];\r\n\t\t\tfor (var key in node.contents) {\r\n\t\t\t  if (!node.contents.hasOwnProperty(key)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t  }\r\n\t\t\t  entries.push(key);\r\n\t\t\t}\r\n\t\t\treturn entries;\r\n\t\t  },\r\n\tsymlink(parent, newname, oldpath) {\r\n\t\t\tvar node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n\t\t\tnode.link = oldpath;\r\n\t\t\treturn node;\r\n\t\t  },\r\n\treadlink(node) {\r\n\t\t\tif (!FS.isLink(node.mode)) {\r\n\t\t\t  throw new FS.ErrnoError(28);\r\n\t\t\t}\r\n\t\t\treturn node.link;\r\n\t\t  },\r\n\t},\r\n\tstream_ops:{\r\n\tread(stream, buffer, offset, length, position) {\r\n\t\t\tvar contents = stream.node.contents;\r\n\t\t\tif (position >= stream.node.usedBytes) return 0;\r\n\t\t\tvar size = Math.min(stream.node.usedBytes - position, length);\r\n\t\t\tassert(size >= 0);\r\n\t\t\tif (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n\t\t\t  buffer.set(contents.subarray(position, position + size), offset);\r\n\t\t\t} else {\r\n\t\t\t  for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n\t\t\t}\r\n\t\t\treturn size;\r\n\t\t  },\r\n\twrite(stream, buffer, offset, length, position, canOwn) {\r\n\t\t\t// The data buffer should be a typed array view\r\n\t\t\tassert(!(buffer instanceof ArrayBuffer));\r\n\t\t\t// If the buffer is located in main memory (HEAP), and if\r\n\t\t\t// memory can grow, we can't hold on to references of the\r\n\t\t\t// memory buffer, as they may get invalidated. That means we\r\n\t\t\t// need to do copy its contents.\r\n\t\t\tif (buffer.buffer === HEAP8.buffer) {\r\n\t\t\t  canOwn = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!length) return 0;\r\n\t\t\tvar node = stream.node;\r\n\t\t\tnode.timestamp = Date.now();\r\n\r\n\t\t\tif (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n\t\t\t  if (canOwn) {\r\n\t\t\t\tassert(position === 0, 'canOwn must imply no weird position inside the file');\r\n\t\t\t\tnode.contents = buffer.subarray(offset, offset + length);\r\n\t\t\t\tnode.usedBytes = length;\r\n\t\t\t\treturn length;\r\n\t\t\t  } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n\t\t\t\tnode.contents = buffer.slice(offset, offset + length);\r\n\t\t\t\tnode.usedBytes = length;\r\n\t\t\t\treturn length;\r\n\t\t\t  } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n\t\t\t\tnode.contents.set(buffer.subarray(offset, offset + length), position);\r\n\t\t\t\treturn length;\r\n\t\t\t  }\r\n\t\t\t}\r\n\r\n\t\t\t// Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n\t\t\tMEMFS.expandFileStorage(node, position+length);\r\n\t\t\tif (node.contents.subarray && buffer.subarray) {\r\n\t\t\t  // Use typed array write which is available.\r\n\t\t\t  node.contents.set(buffer.subarray(offset, offset + length), position);\r\n\t\t\t} else {\r\n\t\t\t  for (var i = 0; i < length; i++) {\r\n\t\t\t   node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\tnode.usedBytes = Math.max(node.usedBytes, position + length);\r\n\t\t\treturn length;\r\n\t\t  },\r\n\tllseek(stream, offset, whence) {\r\n\t\t\tvar position = offset;\r\n\t\t\tif (whence === 1) {\r\n\t\t\t  position += stream.position;\r\n\t\t\t} else if (whence === 2) {\r\n\t\t\t  if (FS.isFile(stream.node.mode)) {\r\n\t\t\t\tposition += stream.node.usedBytes;\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\tif (position < 0) {\r\n\t\t\t  throw new FS.ErrnoError(28);\r\n\t\t\t}\r\n\t\t\treturn position;\r\n\t\t  },\r\n\tallocate(stream, offset, length) {\r\n\t\t\tMEMFS.expandFileStorage(stream.node, offset + length);\r\n\t\t\tstream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n\t\t  },\r\n\tmmap(stream, length, position, prot, flags) {\r\n\t\t\tif (!FS.isFile(stream.node.mode)) {\r\n\t\t\t  throw new FS.ErrnoError(43);\r\n\t\t\t}\r\n\t\t\tvar ptr;\r\n\t\t\tvar allocated;\r\n\t\t\tvar contents = stream.node.contents;\r\n\t\t\t// Only make a new copy when MAP_PRIVATE is specified.\r\n\t\t\tif (!(flags & 2) && contents.buffer === HEAP8.buffer) {\r\n\t\t\t  // We can't emulate MAP_SHARED when the file is not backed by the\r\n\t\t\t  // buffer we're mapping to (e.g. the HEAP buffer).\r\n\t\t\t  allocated = false;\r\n\t\t\t  ptr = contents.byteOffset;\r\n\t\t\t} else {\r\n\t\t\t  // Try to avoid unnecessary slices.\r\n\t\t\t  if (position > 0 || position + length < contents.length) {\r\n\t\t\t\tif (contents.subarray) {\r\n\t\t\t\t  contents = contents.subarray(position, position + length);\r\n\t\t\t\t} else {\r\n\t\t\t\t  contents = Array.prototype.slice.call(contents, position, position + length);\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t  allocated = true;\r\n\t\t\t  ptr = mmapAlloc();\r\n\t\t\t  if (!ptr) {\r\n\t\t\t\tthrow new FS.ErrnoError(48);\r\n\t\t\t  }\r\n\t\t\t  HEAP8.set(contents, ptr);\r\n\t\t\t}\r\n\t\t\treturn { ptr, allocated };\r\n\t\t  },\r\n\tmsync(stream, buffer, offset, length, mmapFlags) {\r\n\t\t\tMEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n\t\t\t// should we check if bytesWritten and length are the same?\r\n\t\t\treturn 0;\r\n\t\t  },\r\n\t},\r\n\t};\r\n\r\n\t/** @param {boolean=} noRunDep */\r\n\tvar asyncLoad = (url, onload, onerror, noRunDep) => {\r\n\t\tvar dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';\r\n\t\treadAsync(url, (arrayBuffer) => {\r\n\t\t  assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\r\n\t\t  onload(new Uint8Array(arrayBuffer));\r\n\t\t  if (dep) removeRunDependency(dep);\r\n\t\t}, (event) => {\r\n\t\t  if (onerror) {\r\n\t\t\tonerror();\r\n\t\t  } else {\r\n\t\t\tthrow `Loading data file \"${url}\" failed.`;\r\n\t\t  }\r\n\t\t});\r\n\t\tif (dep) addRunDependency(dep);\r\n\t  };\r\n\r\n\r\n\tvar FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\r\n\t\treturn FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\r\n\t  };\r\n\r\n\tvar preloadPlugins = Module['preloadPlugins'] || [];\r\n\tvar FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\r\n\t\t// Ensure plugins are ready.\r\n\t\tif (typeof Browser != 'undefined') Browser.init();\r\n\r\n\t\tvar handled = false;\r\n\t\tpreloadPlugins.forEach((plugin) => {\r\n\t\t  if (handled) return;\r\n\t\t  if (plugin['canHandle'](fullname)) {\r\n\t\t\tplugin['handle'](byteArray, fullname, finish, onerror);\r\n\t\t\thandled = true;\r\n\t\t  }\r\n\t\t});\r\n\t\treturn handled;\r\n\t  };\r\n\tvar FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n\t\t// TODO we should allow people to just pass in a complete filename instead\r\n\t\t// of parent and name being that we just join them anyways\r\n\t\tvar fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n\t\tvar dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\r\n\t\tfunction processData(byteArray) {\r\n\t\t  function finish(byteArray) {\r\n\t\t\tif (preFinish) preFinish();\r\n\t\t\tif (!dontCreateFile) {\r\n\t\t\t  FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n\t\t\t}\r\n\t\t\tif (onload) onload();\r\n\t\t\tremoveRunDependency(dep);\r\n\t\t  }\r\n\t\t  if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n\t\t\tif (onerror) onerror();\r\n\t\t\tremoveRunDependency(dep);\r\n\t\t  })) {\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  finish(byteArray);\r\n\t\t}\r\n\t\taddRunDependency(dep);\r\n\t\tif (typeof url == 'string') {\r\n\t\t  asyncLoad(url, (byteArray) => processData(byteArray), onerror);\r\n\t\t} else {\r\n\t\t  processData(url);\r\n\t\t}\r\n\t  };\r\n\r\n\tvar FS_modeStringToFlags = (str) => {\r\n\t\tvar flagModes = {\r\n\t\t  'r': 0,\r\n\t\t  'r+': 2,\r\n\t\t  'w': 512 | 64 | 1,\r\n\t\t  'w+': 512 | 64 | 2,\r\n\t\t  'a': 1024 | 64 | 1,\r\n\t\t  'a+': 1024 | 64 | 2,\r\n\t\t};\r\n\t\tvar flags = flagModes[str];\r\n\t\tif (typeof flags == 'undefined') {\r\n\t\t  throw new Error(`Unknown file open mode: ${str}`);\r\n\t\t}\r\n\t\treturn flags;\r\n\t  };\r\n\r\n\tvar FS_getMode = (canRead, canWrite) => {\r\n\t\tvar mode = 0;\r\n\t\tif (canRead) mode |= 292 | 73;\r\n\t\tif (canWrite) mode |= 146;\r\n\t\treturn mode;\r\n\t  };\r\n\r\n\r\n\r\n\r\n\tvar ERRNO_MESSAGES = {\r\n\t0:\"Success\",\r\n\t1:\"Arg list too long\",\r\n\t2:\"Permission denied\",\r\n\t3:\"Address already in use\",\r\n\t4:\"Address not available\",\r\n\t5:\"Address family not supported by protocol family\",\r\n\t6:\"No more processes\",\r\n\t7:\"Socket already connected\",\r\n\t8:\"Bad file number\",\r\n\t9:\"Trying to read unreadable message\",\r\n\t10:\"Mount device busy\",\r\n\t11:\"Operation canceled\",\r\n\t12:\"No children\",\r\n\t13:\"Connection aborted\",\r\n\t14:\"Connection refused\",\r\n\t15:\"Connection reset by peer\",\r\n\t16:\"File locking deadlock error\",\r\n\t17:\"Destination address required\",\r\n\t18:\"Math arg out of domain of func\",\r\n\t19:\"Quota exceeded\",\r\n\t20:\"File exists\",\r\n\t21:\"Bad address\",\r\n\t22:\"File too large\",\r\n\t23:\"Host is unreachable\",\r\n\t24:\"Identifier removed\",\r\n\t25:\"Illegal byte sequence\",\r\n\t26:\"Connection already in progress\",\r\n\t27:\"Interrupted system call\",\r\n\t28:\"Invalid argument\",\r\n\t29:\"I/O error\",\r\n\t30:\"Socket is already connected\",\r\n\t31:\"Is a directory\",\r\n\t32:\"Too many symbolic links\",\r\n\t33:\"Too many open files\",\r\n\t34:\"Too many links\",\r\n\t35:\"Message too long\",\r\n\t36:\"Multihop attempted\",\r\n\t37:\"File or path name too long\",\r\n\t38:\"Network interface is not configured\",\r\n\t39:\"Connection reset by network\",\r\n\t40:\"Network is unreachable\",\r\n\t41:\"Too many open files in system\",\r\n\t42:\"No buffer space available\",\r\n\t43:\"No such device\",\r\n\t44:\"No such file or directory\",\r\n\t45:\"Exec format error\",\r\n\t46:\"No record locks available\",\r\n\t47:\"The link has been severed\",\r\n\t48:\"Not enough core\",\r\n\t49:\"No message of desired type\",\r\n\t50:\"Protocol not available\",\r\n\t51:\"No space left on device\",\r\n\t52:\"Function not implemented\",\r\n\t53:\"Socket is not connected\",\r\n\t54:\"Not a directory\",\r\n\t55:\"Directory not empty\",\r\n\t56:\"State not recoverable\",\r\n\t57:\"Socket operation on non-socket\",\r\n\t59:\"Not a typewriter\",\r\n\t60:\"No such device or address\",\r\n\t61:\"Value too large for defined data type\",\r\n\t62:\"Previous owner died\",\r\n\t63:\"Not super-user\",\r\n\t64:\"Broken pipe\",\r\n\t65:\"Protocol error\",\r\n\t66:\"Unknown protocol\",\r\n\t67:\"Protocol wrong type for socket\",\r\n\t68:\"Math result not representable\",\r\n\t69:\"Read only file system\",\r\n\t70:\"Illegal seek\",\r\n\t71:\"No such process\",\r\n\t72:\"Stale file handle\",\r\n\t73:\"Connection timed out\",\r\n\t74:\"Text file busy\",\r\n\t75:\"Cross-device link\",\r\n\t100:\"Device not a stream\",\r\n\t101:\"Bad font file fmt\",\r\n\t102:\"Invalid slot\",\r\n\t103:\"Invalid request code\",\r\n\t104:\"No anode\",\r\n\t105:\"Block device required\",\r\n\t106:\"Channel number out of range\",\r\n\t107:\"Level 3 halted\",\r\n\t108:\"Level 3 reset\",\r\n\t109:\"Link number out of range\",\r\n\t110:\"Protocol driver not attached\",\r\n\t111:\"No CSI structure available\",\r\n\t112:\"Level 2 halted\",\r\n\t113:\"Invalid exchange\",\r\n\t114:\"Invalid request descriptor\",\r\n\t115:\"Exchange full\",\r\n\t116:\"No data (for no delay io)\",\r\n\t117:\"Timer expired\",\r\n\t118:\"Out of streams resources\",\r\n\t119:\"Machine is not on the network\",\r\n\t120:\"Package not installed\",\r\n\t121:\"The object is remote\",\r\n\t122:\"Advertise error\",\r\n\t123:\"Srmount error\",\r\n\t124:\"Communication error on send\",\r\n\t125:\"Cross mount point (not really error)\",\r\n\t126:\"Given log. name not unique\",\r\n\t127:\"f.d. invalid for this operation\",\r\n\t128:\"Remote address changed\",\r\n\t129:\"Can   access a needed shared lib\",\r\n\t130:\"Accessing a corrupted shared lib\",\r\n\t131:\".lib section in a.out corrupted\",\r\n\t132:\"Attempting to link in too many libs\",\r\n\t133:\"Attempting to exec a shared library\",\r\n\t135:\"Streams pipe error\",\r\n\t136:\"Too many users\",\r\n\t137:\"Socket type not supported\",\r\n\t138:\"Not supported\",\r\n\t139:\"Protocol family not supported\",\r\n\t140:\"Can't send after socket shutdown\",\r\n\t141:\"Too many references\",\r\n\t142:\"Host is down\",\r\n\t148:\"No medium (in tape drive)\",\r\n\t156:\"Level 2 not synchronized\",\r\n\t};\r\n\r\n\tvar ERRNO_CODES = {\r\n\t};\r\n\r\n\tvar demangle = (func) => {\r\n\t\twarnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');\r\n\t\treturn func;\r\n\t  };\r\n\tvar demangleAll = (text) => {\r\n\t\tvar regex =\r\n\t\t  /\\b_Z[\\w\\d_]+/g;\r\n\t\treturn text.replace(regex,\r\n\t\t  function(x) {\r\n\t\t\tvar y = demangle(x);\r\n\t\t\treturn x === y ? x : (y + ' [' + x + ']');\r\n\t\t  });\r\n\t  };\r\n\tvar FS = {\r\n\troot:null,\r\n\tmounts:[],\r\n\tdevices:{\r\n\t},\r\n\tstreams:[],\r\n\tnextInode:1,\r\n\tnameTable:null,\r\n\tcurrentPath:\"/\",\r\n\tinitialized:false,\r\n\tignorePermissions:true,\r\n\tErrnoError:null,\r\n\tgenericErrors:{\r\n\t},\r\n\tfilesystems:null,\r\n\tsyncFSRequests:0,\r\n\tlookupPath(path, opts = {}) {\r\n\t\t  path = PATH_FS.resolve(path);\r\n\r\n\t\t  if (!path) return { path: '', node: null };\r\n\r\n\t\t  var defaults = {\r\n\t\t\tfollow_mount: true,\r\n\t\t\trecurse_count: 0\r\n\t\t  };\r\n\t\t  opts = Object.assign(defaults, opts);\r\n\r\n\t\t  if (opts.recurse_count > 8) {  // max recursive lookup of 8\r\n\t\t\tthrow new FS.ErrnoError(32);\r\n\t\t  }\r\n\r\n\t\t  // split the absolute path\r\n\t\t  var parts = path.split('/').filter((p) => !!p);\r\n\r\n\t\t  // start at the root\r\n\t\t  var current = FS.root;\r\n\t\t  var current_path = '/';\r\n\r\n\t\t  for (var i = 0; i < parts.length; i++) {\r\n\t\t\tvar islast = (i === parts.length-1);\r\n\t\t\tif (islast && opts.parent) {\r\n\t\t\t  // stop resolving\r\n\t\t\t  break;\r\n\t\t\t}\r\n\r\n\t\t\tcurrent = FS.lookupNode(current, parts[i]);\r\n\t\t\tcurrent_path = PATH.join2(current_path, parts[i]);\r\n\r\n\t\t\t// jump to the mount's root node if this is a mountpoint\r\n\t\t\tif (FS.isMountpoint(current)) {\r\n\t\t\t  if (!islast || (islast && opts.follow_mount)) {\r\n\t\t\t\tcurrent = current.mounted.root;\r\n\t\t\t  }\r\n\t\t\t}\r\n\r\n\t\t\t// by default, lookupPath will not follow a symlink if it is the final path component.\r\n\t\t\t// setting opts.follow = true will override this behavior.\r\n\t\t\tif (!islast || opts.follow) {\r\n\t\t\t  var count = 0;\r\n\t\t\t  while (FS.isLink(current.mode)) {\r\n\t\t\t\tvar link = FS.readlink(current_path);\r\n\t\t\t\tcurrent_path = PATH_FS.resolve(PATH.dirname(current_path), link);\r\n\r\n\t\t\t\tvar lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\r\n\t\t\t\tcurrent = lookup.node;\r\n\r\n\t\t\t\tif (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n\t\t\t\t  throw new FS.ErrnoError(32);\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t  }\r\n\r\n\t\t  return { path: current_path, node: current };\r\n\t\t},\r\n\tgetPath(node) {\r\n\t\t  var path;\r\n\t\t  while (true) {\r\n\t\t\tif (FS.isRoot(node)) {\r\n\t\t\t  var mount = node.mount.mountpoint;\r\n\t\t\t  if (!path) return mount;\r\n\t\t\t  return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;\r\n\t\t\t}\r\n\t\t\tpath = path ? `${node.name}/${path}` : node.name;\r\n\t\t\tnode = node.parent;\r\n\t\t  }\r\n\t\t},\r\n\thashName(parentid, name) {\r\n\t\t  var hash = 0;\r\n\r\n\t\t  for (var i = 0; i < name.length; i++) {\r\n\t\t\thash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n\t\t  }\r\n\t\t  return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n\t\t},\r\n\thashAddNode(node) {\r\n\t\t  var hash = FS.hashName(node.parent.id, node.name);\r\n\t\t  node.name_next = FS.nameTable[hash];\r\n\t\t  FS.nameTable[hash] = node;\r\n\t\t},\r\n\thashRemoveNode(node) {\r\n\t\t  var hash = FS.hashName(node.parent.id, node.name);\r\n\t\t  if (FS.nameTable[hash] === node) {\r\n\t\t\tFS.nameTable[hash] = node.name_next;\r\n\t\t  } else {\r\n\t\t\tvar current = FS.nameTable[hash];\r\n\t\t\twhile (current) {\r\n\t\t\t  if (current.name_next === node) {\r\n\t\t\t\tcurrent.name_next = node.name_next;\r\n\t\t\t\tbreak;\r\n\t\t\t  }\r\n\t\t\t  current = current.name_next;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t},\r\n\tlookupNode(parent, name) {\r\n\t\t  var errCode = FS.mayLookup(parent);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode, parent);\r\n\t\t  }\r\n\t\t  var hash = FS.hashName(parent.id, name);\r\n\t\t  for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n\t\t\tvar nodeName = node.name;\r\n\t\t\tif (node.parent.id === parent.id && nodeName === name) {\r\n\t\t\t  return node;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // if we failed to find it in the cache, call into the VFS\r\n\t\t  return FS.lookup(parent, name);\r\n\t\t},\r\n\tcreateNode(parent, name, mode, rdev) {\r\n\t\t  assert(typeof parent == 'object');\r\n\t\t  var node = new FS.FSNode(parent, name, mode, rdev);\r\n\r\n\t\t  FS.hashAddNode(node);\r\n\r\n\t\t  return node;\r\n\t\t},\r\n\tdestroyNode(node) {\r\n\t\t  FS.hashRemoveNode(node);\r\n\t\t},\r\n\tisRoot(node) {\r\n\t\t  return node === node.parent;\r\n\t\t},\r\n\tisMountpoint(node) {\r\n\t\t  return !!node.mounted;\r\n\t\t},\r\n\tisFile(mode) {\r\n\t\t  return (mode & 61440) === 32768;\r\n\t\t},\r\n\tisDir(mode) {\r\n\t\t  return (mode & 61440) === 16384;\r\n\t\t},\r\n\tisLink(mode) {\r\n\t\t  return (mode & 61440) === 40960;\r\n\t\t},\r\n\tisChrdev(mode) {\r\n\t\t  return (mode & 61440) === 8192;\r\n\t\t},\r\n\tisBlkdev(mode) {\r\n\t\t  return (mode & 61440) === 24576;\r\n\t\t},\r\n\tisFIFO(mode) {\r\n\t\t  return (mode & 61440) === 4096;\r\n\t\t},\r\n\tisSocket(mode) {\r\n\t\t  return (mode & 49152) === 49152;\r\n\t\t},\r\n\tflagsToPermissionString(flag) {\r\n\t\t  var perms = ['r', 'w', 'rw'][flag & 3];\r\n\t\t  if ((flag & 512)) {\r\n\t\t\tperms += 'w';\r\n\t\t  }\r\n\t\t  return perms;\r\n\t\t},\r\n\tnodePermissions(node, perms) {\r\n\t\t  if (FS.ignorePermissions) {\r\n\t\t\treturn 0;\r\n\t\t  }\r\n\t\t  // return 0 if any user, group or owner bits are set.\r\n\t\t  if (perms.includes('r') && !(node.mode & 292)) {\r\n\t\t\treturn 2;\r\n\t\t  } else if (perms.includes('w') && !(node.mode & 146)) {\r\n\t\t\treturn 2;\r\n\t\t  } else if (perms.includes('x') && !(node.mode & 73)) {\r\n\t\t\treturn 2;\r\n\t\t  }\r\n\t\t  return 0;\r\n\t\t},\r\n\tmayLookup(dir) {\r\n\t\t  var errCode = FS.nodePermissions(dir, 'x');\r\n\t\t  if (errCode) return errCode;\r\n\t\t  if (!dir.node_ops.lookup) return 2;\r\n\t\t  return 0;\r\n\t\t},\r\n\tmayCreate(dir, name) {\r\n\t\t  try {\r\n\t\t\tvar node = FS.lookupNode(dir, name);\r\n\t\t\treturn 20;\r\n\t\t  } catch (e) {\r\n\t\t  }\r\n\t\t  return FS.nodePermissions(dir, 'wx');\r\n\t\t},\r\n\tmayDelete(dir, name, isdir) {\r\n\t\t  var node;\r\n\t\t  try {\r\n\t\t\tnode = FS.lookupNode(dir, name);\r\n\t\t  } catch (e) {\r\n\t\t\treturn e.errno;\r\n\t\t  }\r\n\t\t  var errCode = FS.nodePermissions(dir, 'wx');\r\n\t\t  if (errCode) {\r\n\t\t\treturn errCode;\r\n\t\t  }\r\n\t\t  if (isdir) {\r\n\t\t\tif (!FS.isDir(node.mode)) {\r\n\t\t\t  return 54;\r\n\t\t\t}\r\n\t\t\tif (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n\t\t\t  return 10;\r\n\t\t\t}\r\n\t\t  } else {\r\n\t\t\tif (FS.isDir(node.mode)) {\r\n\t\t\t  return 31;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  return 0;\r\n\t\t},\r\n\tmayOpen(node, flags) {\r\n\t\t  if (!node) {\r\n\t\t\treturn 44;\r\n\t\t  }\r\n\t\t  if (FS.isLink(node.mode)) {\r\n\t\t\treturn 32;\r\n\t\t  } else if (FS.isDir(node.mode)) {\r\n\t\t\tif (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\r\n\t\t\t\t(flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\r\n\t\t\t  return 31;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n\t\t},\r\n\tMAX_OPEN_FDS:4096,\r\n\tnextfd() {\r\n\t\t  for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\r\n\t\t\tif (!FS.streams[fd]) {\r\n\t\t\t  return fd;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  throw new FS.ErrnoError(33);\r\n\t\t},\r\n\tgetStreamChecked(fd) {\r\n\t\t  var stream = FS.getStream(fd);\r\n\t\t  if (!stream) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  return stream;\r\n\t\t},\r\n\tgetStream:(fd) => FS.streams[fd],\r\n\tcreateStream(stream, fd = -1) {\r\n\t\t  if (!FS.FSStream) {\r\n\t\t\tFS.FSStream = /** @constructor */ function() {\r\n\t\t\t  this.shared = { };\r\n\t\t\t};\r\n\t\t\tFS.FSStream.prototype = {};\r\n\t\t\tObject.defineProperties(FS.FSStream.prototype, {\r\n\t\t\t  object: {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return this.node; },\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tset(val) { this.node = val; }\r\n\t\t\t  },\r\n\t\t\t  isRead: {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return (this.flags & 2097155) !== 1; }\r\n\t\t\t  },\r\n\t\t\t  isWrite: {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return (this.flags & 2097155) !== 0; }\r\n\t\t\t  },\r\n\t\t\t  isAppend: {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return (this.flags & 1024); }\r\n\t\t\t  },\r\n\t\t\t  flags: {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return this.shared.flags; },\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tset(val) { this.shared.flags = val; },\r\n\t\t\t  },\r\n\t\t\t  position : {\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tget() { return this.shared.position; },\r\n\t\t\t\t/** @this {FS.FSStream} */\r\n\t\t\t\tset(val) { this.shared.position = val; },\r\n\t\t\t  },\r\n\t\t\t});\r\n\t\t  }\r\n\t\t  // clone it, so we can return an instance of FSStream\r\n\t\t  stream = Object.assign(new FS.FSStream(), stream);\r\n\t\t  if (fd == -1) {\r\n\t\t\tfd = FS.nextfd();\r\n\t\t  }\r\n\t\t  stream.fd = fd;\r\n\t\t  FS.streams[fd] = stream;\r\n\t\t  return stream;\r\n\t\t},\r\n\tcloseStream(fd) {\r\n\t\t  FS.streams[fd] = null;\r\n\t\t},\r\n\tchrdev_stream_ops:{\r\n\topen(stream) {\r\n\t\t\tvar device = FS.getDevice(stream.node.rdev);\r\n\t\t\t// override node's stream ops with the device's\r\n\t\t\tstream.stream_ops = device.stream_ops;\r\n\t\t\t// forward the open call\r\n\t\t\tif (stream.stream_ops.open) {\r\n\t\t\t  stream.stream_ops.open(stream);\r\n\t\t\t}\r\n\t\t  },\r\n\tllseek() {\r\n\t\t\tthrow new FS.ErrnoError(70);\r\n\t\t  },\r\n\t},\r\n\tmajor:(dev) => ((dev) >> 8),\r\n\tminor:(dev) => ((dev) & 0xff),\r\n\tmakedev:(ma, mi) => ((ma) << 8 | (mi)),\r\n\tregisterDevice(dev, ops) {\r\n\t\t  FS.devices[dev] = { stream_ops: ops };\r\n\t\t},\r\n\tgetDevice:(dev) => FS.devices[dev],\r\n\tgetMounts(mount) {\r\n\t\t  var mounts = [];\r\n\t\t  var check = [mount];\r\n\r\n\t\t  while (check.length) {\r\n\t\t\tvar m = check.pop();\r\n\r\n\t\t\tmounts.push(m);\r\n\r\n\t\t\tcheck.push.apply(check, m.mounts);\r\n\t\t  }\r\n\r\n\t\t  return mounts;\r\n\t\t},\r\n\tsyncfs(populate, callback) {\r\n\t\t  if (typeof populate == 'function') {\r\n\t\t\tcallback = populate;\r\n\t\t\tpopulate = false;\r\n\t\t  }\r\n\r\n\t\t  FS.syncFSRequests++;\r\n\r\n\t\t  if (FS.syncFSRequests > 1) {\r\n\t\t\terr(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\r\n\t\t  }\r\n\r\n\t\t  var mounts = FS.getMounts(FS.root.mount);\r\n\t\t  var completed = 0;\r\n\r\n\t\t  function doCallback(errCode) {\r\n\t\t\tassert(FS.syncFSRequests > 0);\r\n\t\t\tFS.syncFSRequests--;\r\n\t\t\treturn callback(errCode);\r\n\t\t  }\r\n\r\n\t\t  function done(errCode) {\r\n\t\t\tif (errCode) {\r\n\t\t\t  if (!done.errored) {\r\n\t\t\t\tdone.errored = true;\r\n\t\t\t\treturn doCallback(errCode);\r\n\t\t\t  }\r\n\t\t\t  return;\r\n\t\t\t}\r\n\t\t\tif (++completed >= mounts.length) {\r\n\t\t\t  doCallback(null);\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // sync all mounts\r\n\t\t  mounts.forEach((mount) => {\r\n\t\t\tif (!mount.type.syncfs) {\r\n\t\t\t  return done(null);\r\n\t\t\t}\r\n\t\t\tmount.type.syncfs(mount, populate, done);\r\n\t\t  });\r\n\t\t},\r\n\tmount(type, opts, mountpoint) {\r\n\t\t  if (typeof type == 'string') {\r\n\t\t\t// The filesystem was not included, and instead we have an error\r\n\t\t\t// message stored in the variable.\r\n\t\t\tthrow type;\r\n\t\t  }\r\n\t\t  var root = mountpoint === '/';\r\n\t\t  var pseudo = !mountpoint;\r\n\t\t  var node;\r\n\r\n\t\t  if (root && FS.root) {\r\n\t\t\tthrow new FS.ErrnoError(10);\r\n\t\t  } else if (!root && !pseudo) {\r\n\t\t\tvar lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n\r\n\t\t\tmountpoint = lookup.path;  // use the absolute path\r\n\t\t\tnode = lookup.node;\r\n\r\n\t\t\tif (FS.isMountpoint(node)) {\r\n\t\t\t  throw new FS.ErrnoError(10);\r\n\t\t\t}\r\n\r\n\t\t\tif (!FS.isDir(node.mode)) {\r\n\t\t\t  throw new FS.ErrnoError(54);\r\n\t\t\t}\r\n\t\t  }\r\n\r\n\t\t  var mount = {\r\n\t\t\ttype,\r\n\t\t\topts,\r\n\t\t\tmountpoint,\r\n\t\t\tmounts: []\r\n\t\t  };\r\n\r\n\t\t  // create a root node for the fs\r\n\t\t  var mountRoot = type.mount(mount);\r\n\t\t  mountRoot.mount = mount;\r\n\t\t  mount.root = mountRoot;\r\n\r\n\t\t  if (root) {\r\n\t\t\tFS.root = mountRoot;\r\n\t\t  } else if (node) {\r\n\t\t\t// set as a mountpoint\r\n\t\t\tnode.mounted = mount;\r\n\r\n\t\t\t// add the new mount to the current mount's children\r\n\t\t\tif (node.mount) {\r\n\t\t\t  node.mount.mounts.push(mount);\r\n\t\t\t}\r\n\t\t  }\r\n\r\n\t\t  return mountRoot;\r\n\t\t},\r\n\tunmount(mountpoint) {\r\n\t\t  var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n\r\n\t\t  if (!FS.isMountpoint(lookup.node)) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\r\n\t\t  // destroy the nodes for this mount, and all its child mounts\r\n\t\t  var node = lookup.node;\r\n\t\t  var mount = node.mounted;\r\n\t\t  var mounts = FS.getMounts(mount);\r\n\r\n\t\t  Object.keys(FS.nameTable).forEach((hash) => {\r\n\t\t\tvar current = FS.nameTable[hash];\r\n\r\n\t\t\twhile (current) {\r\n\t\t\t  var next = current.name_next;\r\n\r\n\t\t\t  if (mounts.includes(current.mount)) {\r\n\t\t\t\tFS.destroyNode(current);\r\n\t\t\t  }\r\n\r\n\t\t\t  current = next;\r\n\t\t\t}\r\n\t\t  });\r\n\r\n\t\t  // no longer a mountpoint\r\n\t\t  node.mounted = null;\r\n\r\n\t\t  // remove this mount from the child mounts\r\n\t\t  var idx = node.mount.mounts.indexOf(mount);\r\n\t\t  assert(idx !== -1);\r\n\t\t  node.mount.mounts.splice(idx, 1);\r\n\t\t},\r\n\tlookup(parent, name) {\r\n\t\t  return parent.node_ops.lookup(parent, name);\r\n\t\t},\r\n\tmknod(path, mode, dev) {\r\n\t\t  var lookup = FS.lookupPath(path, { parent: true });\r\n\t\t  var parent = lookup.node;\r\n\t\t  var name = PATH.basename(path);\r\n\t\t  if (!name || name === '.' || name === '..') {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  var errCode = FS.mayCreate(parent, name);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  if (!parent.node_ops.mknod) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  return parent.node_ops.mknod(parent, name, mode, dev);\r\n\t\t},\r\n\tcreate(path, mode) {\r\n\t\t  mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n\t\t  mode &= 4095;\r\n\t\t  mode |= 32768;\r\n\t\t  return FS.mknod(path, mode, 0);\r\n\t\t},\r\n\tmkdir(path, mode) {\r\n\t\t  mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n\t\t  mode &= 511 | 512;\r\n\t\t  mode |= 16384;\r\n\t\t  return FS.mknod(path, mode, 0);\r\n\t\t},\r\n\tmkdirTree(path, mode) {\r\n\t\t  var dirs = path.split('/');\r\n\t\t  var d = '';\r\n\t\t  for (var i = 0; i < dirs.length; ++i) {\r\n\t\t\tif (!dirs[i]) continue;\r\n\t\t\td += '/' + dirs[i];\r\n\t\t\ttry {\r\n\t\t\t  FS.mkdir(d, mode);\r\n\t\t\t} catch(e) {\r\n\t\t\t  if (e.errno != 20) throw e;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t},\r\n\tmkdev(path, mode, dev) {\r\n\t\t  if (typeof dev == 'undefined') {\r\n\t\t\tdev = mode;\r\n\t\t\tmode = 438 /* 0666 */;\r\n\t\t  }\r\n\t\t  mode |= 8192;\r\n\t\t  return FS.mknod(path, mode, dev);\r\n\t\t},\r\n\tsymlink(oldpath, newpath) {\r\n\t\t  if (!PATH_FS.resolve(oldpath)) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  var lookup = FS.lookupPath(newpath, { parent: true });\r\n\t\t  var parent = lookup.node;\r\n\t\t  if (!parent) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  var newname = PATH.basename(newpath);\r\n\t\t  var errCode = FS.mayCreate(parent, newname);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  if (!parent.node_ops.symlink) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  return parent.node_ops.symlink(parent, newname, oldpath);\r\n\t\t},\r\n\trename(old_path, new_path) {\r\n\t\t  var old_dirname = PATH.dirname(old_path);\r\n\t\t  var new_dirname = PATH.dirname(new_path);\r\n\t\t  var old_name = PATH.basename(old_path);\r\n\t\t  var new_name = PATH.basename(new_path);\r\n\t\t  // parents must exist\r\n\t\t  var lookup, old_dir, new_dir;\r\n\r\n\t\t  // let the errors from non existant directories percolate up\r\n\t\t  lookup = FS.lookupPath(old_path, { parent: true });\r\n\t\t  old_dir = lookup.node;\r\n\t\t  lookup = FS.lookupPath(new_path, { parent: true });\r\n\t\t  new_dir = lookup.node;\r\n\r\n\t\t  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n\t\t  // need to be part of the same mount\r\n\t\t  if (old_dir.mount !== new_dir.mount) {\r\n\t\t\tthrow new FS.ErrnoError(75);\r\n\t\t  }\r\n\t\t  // source must exist\r\n\t\t  var old_node = FS.lookupNode(old_dir, old_name);\r\n\t\t  // old path should not be an ancestor of the new path\r\n\t\t  var relative = PATH_FS.relative(old_path, new_dirname);\r\n\t\t  if (relative.charAt(0) !== '.') {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  // new path should not be an ancestor of the old path\r\n\t\t  relative = PATH_FS.relative(new_path, old_dirname);\r\n\t\t  if (relative.charAt(0) !== '.') {\r\n\t\t\tthrow new FS.ErrnoError(55);\r\n\t\t  }\r\n\t\t  // see if the new path already exists\r\n\t\t  var new_node;\r\n\t\t  try {\r\n\t\t\tnew_node = FS.lookupNode(new_dir, new_name);\r\n\t\t  } catch (e) {\r\n\t\t\t// not fatal\r\n\t\t  }\r\n\t\t  // early out if nothing needs to change\r\n\t\t  if (old_node === new_node) {\r\n\t\t\treturn;\r\n\t\t  }\r\n\t\t  // we'll need to delete the old entry\r\n\t\t  var isdir = FS.isDir(old_node.mode);\r\n\t\t  var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  // need delete permissions if we'll be overwriting.\r\n\t\t  // need create permissions if new doesn't already exist.\r\n\t\t  errCode = new_node ?\r\n\t\t\tFS.mayDelete(new_dir, new_name, isdir) :\r\n\t\t\tFS.mayCreate(new_dir, new_name);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  if (!old_dir.node_ops.rename) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n\t\t\tthrow new FS.ErrnoError(10);\r\n\t\t  }\r\n\t\t  // if we are going to change the parent, check write permissions\r\n\t\t  if (new_dir !== old_dir) {\r\n\t\t\terrCode = FS.nodePermissions(old_dir, 'w');\r\n\t\t\tif (errCode) {\r\n\t\t\t  throw new FS.ErrnoError(errCode);\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // remove the node from the lookup hash\r\n\t\t  FS.hashRemoveNode(old_node);\r\n\t\t  // do the underlying fs rename\r\n\t\t  try {\r\n\t\t\told_dir.node_ops.rename(old_node, new_dir, new_name);\r\n\t\t  } catch (e) {\r\n\t\t\tthrow e;\r\n\t\t  } finally {\r\n\t\t\t// add the node back to the hash (in case node_ops.rename\r\n\t\t\t// changed its name)\r\n\t\t\tFS.hashAddNode(old_node);\r\n\t\t  }\r\n\t\t},\r\n\trmdir(path) {\r\n\t\t  var lookup = FS.lookupPath(path, { parent: true });\r\n\t\t  var parent = lookup.node;\r\n\t\t  var name = PATH.basename(path);\r\n\t\t  var node = FS.lookupNode(parent, name);\r\n\t\t  var errCode = FS.mayDelete(parent, name, true);\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  if (!parent.node_ops.rmdir) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  if (FS.isMountpoint(node)) {\r\n\t\t\tthrow new FS.ErrnoError(10);\r\n\t\t  }\r\n\t\t  parent.node_ops.rmdir(parent, name);\r\n\t\t  FS.destroyNode(node);\r\n\t\t},\r\n\treaddir(path) {\r\n\t\t  var lookup = FS.lookupPath(path, { follow: true });\r\n\t\t  var node = lookup.node;\r\n\t\t  if (!node.node_ops.readdir) {\r\n\t\t\tthrow new FS.ErrnoError(54);\r\n\t\t  }\r\n\t\t  return node.node_ops.readdir(node);\r\n\t\t},\r\n\tunlink(path) {\r\n\t\t  var lookup = FS.lookupPath(path, { parent: true });\r\n\t\t  var parent = lookup.node;\r\n\t\t  if (!parent) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  var name = PATH.basename(path);\r\n\t\t  var node = FS.lookupNode(parent, name);\r\n\t\t  var errCode = FS.mayDelete(parent, name, false);\r\n\t\t  if (errCode) {\r\n\t\t\t// According to POSIX, we should map EISDIR to EPERM, but\r\n\t\t\t// we instead do what Linux does (and we must, as we use\r\n\t\t\t// the musl linux libc).\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  if (!parent.node_ops.unlink) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  if (FS.isMountpoint(node)) {\r\n\t\t\tthrow new FS.ErrnoError(10);\r\n\t\t  }\r\n\t\t  parent.node_ops.unlink(parent, name);\r\n\t\t  FS.destroyNode(node);\r\n\t\t},\r\n\treadlink(path) {\r\n\t\t  var lookup = FS.lookupPath(path);\r\n\t\t  var link = lookup.node;\r\n\t\t  if (!link) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  if (!link.node_ops.readlink) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n\t\t},\r\n\tstat(path, dontFollow) {\r\n\t\t  var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n\t\t  var node = lookup.node;\r\n\t\t  if (!node) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  if (!node.node_ops.getattr) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  return node.node_ops.getattr(node);\r\n\t\t},\r\n\tlstat(path) {\r\n\t\t  return FS.stat(path, true);\r\n\t\t},\r\n\tchmod(path, mode, dontFollow) {\r\n\t\t  var node;\r\n\t\t  if (typeof path == 'string') {\r\n\t\t\tvar lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n\t\t\tnode = lookup.node;\r\n\t\t  } else {\r\n\t\t\tnode = path;\r\n\t\t  }\r\n\t\t  if (!node.node_ops.setattr) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  node.node_ops.setattr(node, {\r\n\t\t\tmode: (mode & 4095) | (node.mode & ~4095),\r\n\t\t\ttimestamp: Date.now()\r\n\t\t  });\r\n\t\t},\r\n\tlchmod(path, mode) {\r\n\t\t  FS.chmod(path, mode, true);\r\n\t\t},\r\n\tfchmod(fd, mode) {\r\n\t\t  var stream = FS.getStreamChecked(fd);\r\n\t\t  FS.chmod(stream.node, mode);\r\n\t\t},\r\n\tchown(path, uid, gid, dontFollow) {\r\n\t\t  var node;\r\n\t\t  if (typeof path == 'string') {\r\n\t\t\tvar lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n\t\t\tnode = lookup.node;\r\n\t\t  } else {\r\n\t\t\tnode = path;\r\n\t\t  }\r\n\t\t  if (!node.node_ops.setattr) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  node.node_ops.setattr(node, {\r\n\t\t\ttimestamp: Date.now()\r\n\t\t\t// we ignore the uid / gid for now\r\n\t\t  });\r\n\t\t},\r\n\tlchown(path, uid, gid) {\r\n\t\t  FS.chown(path, uid, gid, true);\r\n\t\t},\r\n\tfchown(fd, uid, gid) {\r\n\t\t  var stream = FS.getStreamChecked(fd);\r\n\t\t  FS.chown(stream.node, uid, gid);\r\n\t\t},\r\n\ttruncate(path, len) {\r\n\t\t  if (len < 0) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  var node;\r\n\t\t  if (typeof path == 'string') {\r\n\t\t\tvar lookup = FS.lookupPath(path, { follow: true });\r\n\t\t\tnode = lookup.node;\r\n\t\t  } else {\r\n\t\t\tnode = path;\r\n\t\t  }\r\n\t\t  if (!node.node_ops.setattr) {\r\n\t\t\tthrow new FS.ErrnoError(63);\r\n\t\t  }\r\n\t\t  if (FS.isDir(node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(31);\r\n\t\t  }\r\n\t\t  if (!FS.isFile(node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  var errCode = FS.nodePermissions(node, 'w');\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  node.node_ops.setattr(node, {\r\n\t\t\tsize: len,\r\n\t\t\ttimestamp: Date.now()\r\n\t\t  });\r\n\t\t},\r\n\tftruncate(fd, len) {\r\n\t\t  var stream = FS.getStreamChecked(fd);\r\n\t\t  if ((stream.flags & 2097155) === 0) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  FS.truncate(stream.node, len);\r\n\t\t},\r\n\tutime(path, atime, mtime) {\r\n\t\t  var lookup = FS.lookupPath(path, { follow: true });\r\n\t\t  var node = lookup.node;\r\n\t\t  node.node_ops.setattr(node, {\r\n\t\t\ttimestamp: Math.max(atime, mtime)\r\n\t\t  });\r\n\t\t},\r\n\topen(path, flags, mode) {\r\n\t\t  if (path === \"\") {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\r\n\t\t  mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\r\n\t\t  if ((flags & 64)) {\r\n\t\t\tmode = (mode & 4095) | 32768;\r\n\t\t  } else {\r\n\t\t\tmode = 0;\r\n\t\t  }\r\n\t\t  var node;\r\n\t\t  if (typeof path == 'object') {\r\n\t\t\tnode = path;\r\n\t\t  } else {\r\n\t\t\tpath = PATH.normalize(path);\r\n\t\t\ttry {\r\n\t\t\t  var lookup = FS.lookupPath(path, {\r\n\t\t\t\tfollow: !(flags & 131072)\r\n\t\t\t  });\r\n\t\t\t  node = lookup.node;\r\n\t\t\t} catch (e) {\r\n\t\t\t  // ignore\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // perhaps we need to create the node\r\n\t\t  var created = false;\r\n\t\t  if ((flags & 64)) {\r\n\t\t\tif (node) {\r\n\t\t\t  // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n\t\t\t  if ((flags & 128)) {\r\n\t\t\t\tthrow new FS.ErrnoError(20);\r\n\t\t\t  }\r\n\t\t\t} else {\r\n\t\t\t  // node doesn't exist, try to create it\r\n\t\t\t  node = FS.mknod(path, mode, 0);\r\n\t\t\t  created = true;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  if (!node) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  // can't truncate a device\r\n\t\t  if (FS.isChrdev(node.mode)) {\r\n\t\t\tflags &= ~512;\r\n\t\t  }\r\n\t\t  // if asked only for a directory, then this must be one\r\n\t\t  if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(54);\r\n\t\t  }\r\n\t\t  // check permissions, if this is not a file we just created now (it is ok to\r\n\t\t  // create and write to a file with read-only permissions; it is read-only\r\n\t\t  // for later use)\r\n\t\t  if (!created) {\r\n\t\t\tvar errCode = FS.mayOpen(node, flags);\r\n\t\t\tif (errCode) {\r\n\t\t\t  throw new FS.ErrnoError(errCode);\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  // do truncation if necessary\r\n\t\t  if ((flags & 512) && !created) {\r\n\t\t\tFS.truncate(node, 0);\r\n\t\t  }\r\n\t\t  // we've already handled these, don't pass down to the underlying vfs\r\n\t\t  flags &= ~(128 | 512 | 131072);\r\n\r\n\t\t  // register the stream with the filesystem\r\n\t\t  var stream = FS.createStream({\r\n\t\t\tnode,\r\n\t\t\tpath: FS.getPath(node),  // we want the absolute path to the node\r\n\t\t\tflags,\r\n\t\t\tseekable: true,\r\n\t\t\tposition: 0,\r\n\t\t\tstream_ops: node.stream_ops,\r\n\t\t\t// used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n\t\t\tungotten: [],\r\n\t\t\terror: false\r\n\t\t  });\r\n\t\t  // call the new stream's open function\r\n\t\t  if (stream.stream_ops.open) {\r\n\t\t\tstream.stream_ops.open(stream);\r\n\t\t  }\r\n\t\t  if (Module['logReadFiles'] && !(flags & 1)) {\r\n\t\t\tif (!FS.readFiles) FS.readFiles = {};\r\n\t\t\tif (!(path in FS.readFiles)) {\r\n\t\t\t  FS.readFiles[path] = 1;\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  return stream;\r\n\t\t},\r\n\tclose(stream) {\r\n\t\t  if (FS.isClosed(stream)) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (stream.getdents) stream.getdents = null; // free readdir state\r\n\t\t  try {\r\n\t\t\tif (stream.stream_ops.close) {\r\n\t\t\t  stream.stream_ops.close(stream);\r\n\t\t\t}\r\n\t\t  } catch (e) {\r\n\t\t\tthrow e;\r\n\t\t  } finally {\r\n\t\t\tFS.closeStream(stream.fd);\r\n\t\t  }\r\n\t\t  stream.fd = null;\r\n\t\t},\r\n\tisClosed(stream) {\r\n\t\t  return stream.fd === null;\r\n\t\t},\r\n\tllseek(stream, offset, whence) {\r\n\t\t  if (FS.isClosed(stream)) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (!stream.seekable || !stream.stream_ops.llseek) {\r\n\t\t\tthrow new FS.ErrnoError(70);\r\n\t\t  }\r\n\t\t  if (whence != 0 && whence != 1 && whence != 2) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n\t\t  stream.ungotten = [];\r\n\t\t  return stream.position;\r\n\t\t},\r\n\tread(stream, buffer, offset, length, position) {\r\n\t\t  assert(offset >= 0);\r\n\t\t  if (length < 0 || position < 0) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  if (FS.isClosed(stream)) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if ((stream.flags & 2097155) === 1) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (FS.isDir(stream.node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(31);\r\n\t\t  }\r\n\t\t  if (!stream.stream_ops.read) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  var seeking = typeof position != 'undefined';\r\n\t\t  if (!seeking) {\r\n\t\t\tposition = stream.position;\r\n\t\t  } else if (!stream.seekable) {\r\n\t\t\tthrow new FS.ErrnoError(70);\r\n\t\t  }\r\n\t\t  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n\t\t  if (!seeking) stream.position += bytesRead;\r\n\t\t  return bytesRead;\r\n\t\t},\r\n\twrite(stream, buffer, offset, length, position, canOwn) {\r\n\t\t  assert(offset >= 0);\r\n\t\t  if (length < 0 || position < 0) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  if (FS.isClosed(stream)) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if ((stream.flags & 2097155) === 0) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (FS.isDir(stream.node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(31);\r\n\t\t  }\r\n\t\t  if (!stream.stream_ops.write) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  if (stream.seekable && stream.flags & 1024) {\r\n\t\t\t// seek to the end before writing in append mode\r\n\t\t\tFS.llseek(stream, 0, 2);\r\n\t\t  }\r\n\t\t  var seeking = typeof position != 'undefined';\r\n\t\t  if (!seeking) {\r\n\t\t\tposition = stream.position;\r\n\t\t  } else if (!stream.seekable) {\r\n\t\t\tthrow new FS.ErrnoError(70);\r\n\t\t  }\r\n\t\t  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n\t\t  if (!seeking) stream.position += bytesWritten;\r\n\t\t  return bytesWritten;\r\n\t\t},\r\n\tallocate(stream, offset, length) {\r\n\t\t  if (FS.isClosed(stream)) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (offset < 0 || length <= 0) {\r\n\t\t\tthrow new FS.ErrnoError(28);\r\n\t\t  }\r\n\t\t  if ((stream.flags & 2097155) === 0) {\r\n\t\t\tthrow new FS.ErrnoError(8);\r\n\t\t  }\r\n\t\t  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(43);\r\n\t\t  }\r\n\t\t  if (!stream.stream_ops.allocate) {\r\n\t\t\tthrow new FS.ErrnoError(138);\r\n\t\t  }\r\n\t\t  stream.stream_ops.allocate(stream, offset, length);\r\n\t\t},\r\n\tmmap(stream, length, position, prot, flags) {\r\n\t\t  // User requests writing to file (prot & PROT_WRITE != 0).\r\n\t\t  // Checking if we have permissions to write to the file unless\r\n\t\t  // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n\t\t  // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n\t\t  // as all modifications will be visible only in the memory of\r\n\t\t  // the current process.\r\n\t\t  if ((prot & 2) !== 0\r\n\t\t\t  && (flags & 2) === 0\r\n\t\t\t  && (stream.flags & 2097155) !== 2) {\r\n\t\t\tthrow new FS.ErrnoError(2);\r\n\t\t  }\r\n\t\t  if ((stream.flags & 2097155) === 1) {\r\n\t\t\tthrow new FS.ErrnoError(2);\r\n\t\t  }\r\n\t\t  if (!stream.stream_ops.mmap) {\r\n\t\t\tthrow new FS.ErrnoError(43);\r\n\t\t  }\r\n\t\t  return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n\t\t},\r\n\tmsync(stream, buffer, offset, length, mmapFlags) {\r\n\t\t  assert(offset >= 0);\r\n\t\t  if (!stream.stream_ops.msync) {\r\n\t\t\treturn 0;\r\n\t\t  }\r\n\t\t  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n\t\t},\r\n\tmunmap:(stream) => 0,\r\n\tioctl(stream, cmd, arg) {\r\n\t\t  if (!stream.stream_ops.ioctl) {\r\n\t\t\tthrow new FS.ErrnoError(59);\r\n\t\t  }\r\n\t\t  return stream.stream_ops.ioctl(stream, cmd, arg);\r\n\t\t},\r\n\treadFile(path, opts = {}) {\r\n\t\t  opts.flags = opts.flags || 0;\r\n\t\t  opts.encoding = opts.encoding || 'binary';\r\n\t\t  if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n\t\t\tthrow new Error(`Invalid encoding type \"${opts.encoding}\"`);\r\n\t\t  }\r\n\t\t  var ret;\r\n\t\t  var stream = FS.open(path, opts.flags);\r\n\t\t  var stat = FS.stat(path);\r\n\t\t  var length = stat.size;\r\n\t\t  var buf = new Uint8Array(length);\r\n\t\t  FS.read(stream, buf, 0, length, 0);\r\n\t\t  if (opts.encoding === 'utf8') {\r\n\t\t\tret = UTF8ArrayToString(buf, 0);\r\n\t\t  } else if (opts.encoding === 'binary') {\r\n\t\t\tret = buf;\r\n\t\t  }\r\n\t\t  FS.close(stream);\r\n\t\t  return ret;\r\n\t\t},\r\n\twriteFile(path, data, opts = {}) {\r\n\t\t  opts.flags = opts.flags || 577;\r\n\t\t  var stream = FS.open(path, opts.flags, opts.mode);\r\n\t\t  if (typeof data == 'string') {\r\n\t\t\tvar buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n\t\t\tvar actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n\t\t\tFS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n\t\t  } else if (ArrayBuffer.isView(data)) {\r\n\t\t\tFS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n\t\t  } else {\r\n\t\t\tthrow new Error('Unsupported data type');\r\n\t\t  }\r\n\t\t  FS.close(stream);\r\n\t\t},\r\n\tcwd:() => FS.currentPath,\r\n\tchdir(path) {\r\n\t\t  var lookup = FS.lookupPath(path, { follow: true });\r\n\t\t  if (lookup.node === null) {\r\n\t\t\tthrow new FS.ErrnoError(44);\r\n\t\t  }\r\n\t\t  if (!FS.isDir(lookup.node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(54);\r\n\t\t  }\r\n\t\t  var errCode = FS.nodePermissions(lookup.node, 'x');\r\n\t\t  if (errCode) {\r\n\t\t\tthrow new FS.ErrnoError(errCode);\r\n\t\t  }\r\n\t\t  FS.currentPath = lookup.path;\r\n\t\t},\r\n\tcreateDefaultDirectories() {\r\n\t\t  FS.mkdir('/tmp');\r\n\t\t  FS.mkdir('/home');\r\n\t\t  FS.mkdir('/home/web_user');\r\n\t\t},\r\n\tcreateDefaultDevices() {\r\n\t\t  // create /dev\r\n\t\t  FS.mkdir('/dev');\r\n\t\t  // setup /dev/null\r\n\t\t  FS.registerDevice(FS.makedev(1, 3), {\r\n\t\t\tread: () => 0,\r\n\t\t\twrite: (stream, buffer, offset, length, pos) => length,\r\n\t\t  });\r\n\t\t  FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n\t\t  // setup /dev/tty and /dev/tty1\r\n\t\t  // stderr needs to print output using err() rather than out()\r\n\t\t  // so we register a second tty just for it.\r\n\t\t  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n\t\t  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n\t\t  FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n\t\t  FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n\t\t  // setup /dev/[u]random\r\n\t\t  // use a buffer to avoid overhead of individual crypto calls per byte\r\n\t\t  var randomBuffer = new Uint8Array(1024), randomLeft = 0;\r\n\t\t  var randomByte = () => {\r\n\t\t\tif (randomLeft === 0) {\r\n\t\t\t  randomLeft = randomFill(randomBuffer).byteLength;\r\n\t\t\t}\r\n\t\t\treturn randomBuffer[--randomLeft];\r\n\t\t  };\r\n\t\t  FS.createDevice('/dev', 'random', randomByte);\r\n\t\t  FS.createDevice('/dev', 'urandom', randomByte);\r\n\t\t  // we're not going to emulate the actual shm device,\r\n\t\t  // just create the tmp dirs that reside in it commonly\r\n\t\t  FS.mkdir('/dev/shm');\r\n\t\t  FS.mkdir('/dev/shm/tmp');\r\n\t\t},\r\n\tcreateSpecialDirectories() {\r\n\t\t  // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n\t\t  // name of the stream for fd 6 (see test_unistd_ttyname)\r\n\t\t  FS.mkdir('/proc');\r\n\t\t  var proc_self = FS.mkdir('/proc/self');\r\n\t\t  FS.mkdir('/proc/self/fd');\r\n\t\t  FS.mount({\r\n\t\t\tmount() {\r\n\t\t\t  var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\r\n\t\t\t  node.node_ops = {\r\n\t\t\t\tlookup(parent, name) {\r\n\t\t\t\t  var fd = +name;\r\n\t\t\t\t  var stream = FS.getStreamChecked(fd);\r\n\t\t\t\t  var ret = {\r\n\t\t\t\t\tparent: null,\r\n\t\t\t\t\tmount: { mountpoint: 'fake' },\r\n\t\t\t\t\tnode_ops: { readlink: () => stream.path },\r\n\t\t\t\t  };\r\n\t\t\t\t  ret.parent = ret; // make it look like a simple root node\r\n\t\t\t\t  return ret;\r\n\t\t\t\t}\r\n\t\t\t  };\r\n\t\t\t  return node;\r\n\t\t\t}\r\n\t\t  }, {}, '/proc/self/fd');\r\n\t\t},\r\n\tcreateStandardStreams() {\r\n\t\t  // TODO deprecate the old functionality of a single\r\n\t\t  // input / output callback and that utilizes FS.createDevice\r\n\t\t  // and instead require a unique set of stream ops\r\n\r\n\t\t  // by default, we symlink the standard streams to the\r\n\t\t  // default tty devices. however, if the standard streams\r\n\t\t  // have been overwritten we create a unique device for\r\n\t\t  // them instead.\r\n\t\t  if (Module['stdin']) {\r\n\t\t\tFS.createDevice('/dev', 'stdin', Module['stdin']);\r\n\t\t  } else {\r\n\t\t\tFS.symlink('/dev/tty', '/dev/stdin');\r\n\t\t  }\r\n\t\t  if (Module['stdout']) {\r\n\t\t\tFS.createDevice('/dev', 'stdout', null, Module['stdout']);\r\n\t\t  } else {\r\n\t\t\tFS.symlink('/dev/tty', '/dev/stdout');\r\n\t\t  }\r\n\t\t  if (Module['stderr']) {\r\n\t\t\tFS.createDevice('/dev', 'stderr', null, Module['stderr']);\r\n\t\t  } else {\r\n\t\t\tFS.symlink('/dev/tty1', '/dev/stderr');\r\n\t\t  }\r\n\r\n\t\t  // open default streams for the stdin, stdout and stderr devices\r\n\t\t  var stdin = FS.open('/dev/stdin', 0);\r\n\t\t  var stdout = FS.open('/dev/stdout', 1);\r\n\t\t  var stderr = FS.open('/dev/stderr', 1);\r\n\t\t  assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\r\n\t\t  assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\r\n\t\t  assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\r\n\t\t},\r\n\tensureErrnoError() {\r\n\t\t  if (FS.ErrnoError) return;\r\n\t\t  FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\r\n\t\t\t// We set the `name` property to be able to identify `FS.ErrnoError`\r\n\t\t\t// - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\r\n\t\t\t// - when using PROXYFS, an error can come from an underlying FS\r\n\t\t\t// as different FS objects have their own FS.ErrnoError each,\r\n\t\t\t// the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\r\n\t\t\t// we'll use the reliable test `err.name == \"ErrnoError\"` instead\r\n\t\t\tthis.name = 'ErrnoError';\r\n\t\t\tthis.node = node;\r\n\t\t\tthis.setErrno = /** @this{Object} */ function(errno) {\r\n\t\t\t  this.errno = errno;\r\n\t\t\t  for (var key in ERRNO_CODES) {\r\n\t\t\t\tif (ERRNO_CODES[key] === errno) {\r\n\t\t\t\t  this.code = key;\r\n\t\t\t\t  break;\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t};\r\n\t\t\tthis.setErrno(errno);\r\n\t\t\tthis.message = ERRNO_MESSAGES[errno];\r\n\r\n\t\t\t// Try to get a maximally helpful stack trace. On Node.js, getting Error.stack\r\n\t\t\t// now ensures it shows what we want.\r\n\t\t\tif (this.stack) {\r\n\t\t\t  // Define the stack property for Node.js 4, which otherwise errors on the next line.\r\n\t\t\t  Object.defineProperty(this, \"stack\", { value: (new Error).stack, writable: true });\r\n\t\t\t  this.stack = demangleAll(this.stack);\r\n\t\t\t}\r\n\t\t  };\r\n\t\t  FS.ErrnoError.prototype = new Error();\r\n\t\t  FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n\t\t  // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n\t\t  [44].forEach((code) => {\r\n\t\t\tFS.genericErrors[code] = new FS.ErrnoError(code);\r\n\t\t\tFS.genericErrors[code].stack = '<generic error, no stack>';\r\n\t\t  });\r\n\t\t},\r\n\tstaticInit() {\r\n\t\t  FS.ensureErrnoError();\r\n\r\n\t\t  FS.nameTable = new Array(4096);\r\n\r\n\t\t  FS.mount(MEMFS, {}, '/');\r\n\r\n\t\t  FS.createDefaultDirectories();\r\n\t\t  FS.createDefaultDevices();\r\n\t\t  FS.createSpecialDirectories();\r\n\r\n\t\t  FS.filesystems = {\r\n\t\t\t'MEMFS': MEMFS,\r\n\t\t  };\r\n\t\t},\r\n\tinit(input, output, error) {\r\n\t\t  assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\r\n\t\t  FS.init.initialized = true;\r\n\r\n\t\t  FS.ensureErrnoError();\r\n\r\n\t\t  // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n\t\t  Module['stdin'] = input || Module['stdin'];\r\n\t\t  Module['stdout'] = output || Module['stdout'];\r\n\t\t  Module['stderr'] = error || Module['stderr'];\r\n\r\n\t\t  FS.createStandardStreams();\r\n\t\t},\r\n\tquit() {\r\n\t\t  FS.init.initialized = false;\r\n\t\t  // force-flush all streams, so we get musl std streams printed out\r\n\t\t  _fflush(0);\r\n\t\t  // close all of our streams\r\n\t\t  for (var i = 0; i < FS.streams.length; i++) {\r\n\t\t\tvar stream = FS.streams[i];\r\n\t\t\tif (!stream) {\r\n\t\t\t  continue;\r\n\t\t\t}\r\n\t\t\tFS.close(stream);\r\n\t\t  }\r\n\t\t},\r\n\tfindObject(path, dontResolveLastLink) {\r\n\t\t  var ret = FS.analyzePath(path, dontResolveLastLink);\r\n\t\t  if (!ret.exists) {\r\n\t\t\treturn null;\r\n\t\t  }\r\n\t\t  return ret.object;\r\n\t\t},\r\n\tanalyzePath(path, dontResolveLastLink) {\r\n\t\t  // operate from within the context of the symlink's target\r\n\t\t  try {\r\n\t\t\tvar lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n\t\t\tpath = lookup.path;\r\n\t\t  } catch (e) {\r\n\t\t  }\r\n\t\t  var ret = {\r\n\t\t\tisRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n\t\t\tparentExists: false, parentPath: null, parentObject: null\r\n\t\t  };\r\n\t\t  try {\r\n\t\t\tvar lookup = FS.lookupPath(path, { parent: true });\r\n\t\t\tret.parentExists = true;\r\n\t\t\tret.parentPath = lookup.path;\r\n\t\t\tret.parentObject = lookup.node;\r\n\t\t\tret.name = PATH.basename(path);\r\n\t\t\tlookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n\t\t\tret.exists = true;\r\n\t\t\tret.path = lookup.path;\r\n\t\t\tret.object = lookup.node;\r\n\t\t\tret.name = lookup.node.name;\r\n\t\t\tret.isRoot = lookup.path === '/';\r\n\t\t  } catch (e) {\r\n\t\t\tret.error = e.errno;\r\n\t\t  }        return ret;\r\n\t\t},\r\n\tcreatePath(parent, path, canRead, canWrite) {\r\n\t\t  parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n\t\t  var parts = path.split('/').reverse();\r\n\t\t  while (parts.length) {\r\n\t\t\tvar part = parts.pop();\r\n\t\t\tif (!part) continue;\r\n\t\t\tvar current = PATH.join2(parent, part);\r\n\t\t\ttry {\r\n\t\t\t  FS.mkdir(current);\r\n\t\t\t} catch (e) {\r\n\t\t\t  // ignore EEXIST\r\n\t\t\t}\r\n\t\t\tparent = current;\r\n\t\t  }\r\n\t\t  return current;\r\n\t\t},\r\n\tcreateFile(parent, name, properties, canRead, canWrite) {\r\n\t\t  var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n\t\t  var mode = FS_getMode(canRead, canWrite);\r\n\t\t  return FS.create(path, mode);\r\n\t\t},\r\n\tcreateDataFile(parent, name, data, canRead, canWrite, canOwn) {\r\n\t\t  var path = name;\r\n\t\t  if (parent) {\r\n\t\t\tparent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n\t\t\tpath = name ? PATH.join2(parent, name) : parent;\r\n\t\t  }\r\n\t\t  var mode = FS_getMode(canRead, canWrite);\r\n\t\t  var node = FS.create(path, mode);\r\n\t\t  if (data) {\r\n\t\t\tif (typeof data == 'string') {\r\n\t\t\t  var arr = new Array(data.length);\r\n\t\t\t  for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n\t\t\t  data = arr;\r\n\t\t\t}\r\n\t\t\t// make sure we can write to the file\r\n\t\t\tFS.chmod(node, mode | 146);\r\n\t\t\tvar stream = FS.open(node, 577);\r\n\t\t\tFS.write(stream, data, 0, data.length, 0, canOwn);\r\n\t\t\tFS.close(stream);\r\n\t\t\tFS.chmod(node, mode);\r\n\t\t  }\r\n\t\t  return node;\r\n\t\t},\r\n\tcreateDevice(parent, name, input, output) {\r\n\t\t  var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n\t\t  var mode = FS_getMode(!!input, !!output);\r\n\t\t  if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n\t\t  var dev = FS.makedev(FS.createDevice.major++, 0);\r\n\t\t  // Create a fake device that a set of stream ops to emulate\r\n\t\t  // the old behavior.\r\n\t\t  FS.registerDevice(dev, {\r\n\t\t\topen(stream) {\r\n\t\t\t  stream.seekable = false;\r\n\t\t\t},\r\n\t\t\tclose(stream) {\r\n\t\t\t  // flush any pending line data\r\n\t\t\t  if (output && output.buffer && output.buffer.length) {\r\n\t\t\t\toutput(10);\r\n\t\t\t  }\r\n\t\t\t},\r\n\t\t\tread(stream, buffer, offset, length, pos /* ignored */) {\r\n\t\t\t  var bytesRead = 0;\r\n\t\t\t  for (var i = 0; i < length; i++) {\r\n\t\t\t\tvar result;\r\n\t\t\t\ttry {\r\n\t\t\t\t  result = input();\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t  throw new FS.ErrnoError(29);\r\n\t\t\t\t}\r\n\t\t\t\tif (result === undefined && bytesRead === 0) {\r\n\t\t\t\t  throw new FS.ErrnoError(6);\r\n\t\t\t\t}\r\n\t\t\t\tif (result === null || result === undefined) break;\r\n\t\t\t\tbytesRead++;\r\n\t\t\t\tbuffer[offset+i] = result;\r\n\t\t\t  }\r\n\t\t\t  if (bytesRead) {\r\n\t\t\t\tstream.node.timestamp = Date.now();\r\n\t\t\t  }\r\n\t\t\t  return bytesRead;\r\n\t\t\t},\r\n\t\t\twrite(stream, buffer, offset, length, pos) {\r\n\t\t\t  for (var i = 0; i < length; i++) {\r\n\t\t\t\ttry {\r\n\t\t\t\t  output(buffer[offset+i]);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t  throw new FS.ErrnoError(29);\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t  if (length) {\r\n\t\t\t\tstream.node.timestamp = Date.now();\r\n\t\t\t  }\r\n\t\t\t  return i;\r\n\t\t\t}\r\n\t\t  });\r\n\t\t  return FS.mkdev(path, mode, dev);\r\n\t\t},\r\n\tforceLoadFile(obj) {\r\n\t\t  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n\t\t  if (typeof XMLHttpRequest != 'undefined') {\r\n\t\t\tthrow new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n\t\t  } else if (read_) {\r\n\t\t\t// Command-line.\r\n\t\t\ttry {\r\n\t\t\t  // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n\t\t\t  //          read() will try to parse UTF8.\r\n\t\t\t  obj.contents = intArrayFromString(read_(obj.url), true);\r\n\t\t\t  obj.usedBytes = obj.contents.length;\r\n\t\t\t} catch (e) {\r\n\t\t\t  throw new FS.ErrnoError(29);\r\n\t\t\t}\r\n\t\t  } else {\r\n\t\t\tthrow new Error('Cannot load without read() or XMLHttpRequest.');\r\n\t\t  }\r\n\t\t},\r\n\tcreateLazyFile(parent, name, url, canRead, canWrite) {\r\n\t\t  // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n\t\t  /** @constructor */\r\n\t\t  function LazyUint8Array() {\r\n\t\t\tthis.lengthKnown = false;\r\n\t\t\tthis.chunks = []; // Loaded chunks. Index is the chunk number\r\n\t\t  }\r\n\t\t  LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\r\n\t\t\tif (idx > this.length-1 || idx < 0) {\r\n\t\t\t  return undefined;\r\n\t\t\t}\r\n\t\t\tvar chunkOffset = idx % this.chunkSize;\r\n\t\t\tvar chunkNum = (idx / this.chunkSize)|0;\r\n\t\t\treturn this.getter(chunkNum)[chunkOffset];\r\n\t\t  };\r\n\t\t  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n\t\t\tthis.getter = getter;\r\n\t\t  };\r\n\t\t  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n\t\t\t// Find length\r\n\t\t\tvar xhr = new XMLHttpRequest();\r\n\t\t\txhr.open('HEAD', url, false);\r\n\t\t\txhr.send(null);\r\n\t\t\tif (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n\t\t\tvar datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n\t\t\tvar header;\r\n\t\t\tvar hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n\t\t\tvar usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n\r\n\t\t\tvar chunkSize = 1024*1024; // Chunk size in bytes\r\n\r\n\t\t\tif (!hasByteServing) chunkSize = datalength;\r\n\r\n\t\t\t// Function to get a range from the remote URL.\r\n\t\t\tvar doXHR = (from, to) => {\r\n\t\t\t  if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n\t\t\t  if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n\r\n\t\t\t  // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n\t\t\t  var xhr = new XMLHttpRequest();\r\n\t\t\t  xhr.open('GET', url, false);\r\n\t\t\t  if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n\r\n\t\t\t  // Some hints to the browser that we want binary data.\r\n\t\t\t  xhr.responseType = 'arraybuffer';\r\n\t\t\t  if (xhr.overrideMimeType) {\r\n\t\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n\t\t\t  }\r\n\r\n\t\t\t  xhr.send(null);\r\n\t\t\t  if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n\t\t\t  if (xhr.response !== undefined) {\r\n\t\t\t\treturn new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\r\n\t\t\t  }\r\n\t\t\t  return intArrayFromString(xhr.responseText || '', true);\r\n\t\t\t};\r\n\t\t\tvar lazyArray = this;\r\n\t\t\tlazyArray.setDataGetter((chunkNum) => {\r\n\t\t\t  var start = chunkNum * chunkSize;\r\n\t\t\t  var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n\t\t\t  end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n\t\t\t  if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\r\n\t\t\t\tlazyArray.chunks[chunkNum] = doXHR(start, end);\r\n\t\t\t  }\r\n\t\t\t  if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\r\n\t\t\t  return lazyArray.chunks[chunkNum];\r\n\t\t\t});\r\n\r\n\t\t\tif (usesGzip || !datalength) {\r\n\t\t\t  // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n\t\t\t  chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n\t\t\t  datalength = this.getter(0).length;\r\n\t\t\t  chunkSize = datalength;\r\n\t\t\t  out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n\t\t\t}\r\n\r\n\t\t\tthis._length = datalength;\r\n\t\t\tthis._chunkSize = chunkSize;\r\n\t\t\tthis.lengthKnown = true;\r\n\t\t  };\r\n\t\t  if (typeof XMLHttpRequest != 'undefined') {\r\n\t\t\tif (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n\t\t\tvar lazyArray = new LazyUint8Array();\r\n\t\t\tObject.defineProperties(lazyArray, {\r\n\t\t\t  length: {\r\n\t\t\t\tget: /** @this{Object} */ function() {\r\n\t\t\t\t  if (!this.lengthKnown) {\r\n\t\t\t\t\tthis.cacheLength();\r\n\t\t\t\t  }\r\n\t\t\t\t  return this._length;\r\n\t\t\t\t}\r\n\t\t\t  },\r\n\t\t\t  chunkSize: {\r\n\t\t\t\tget: /** @this{Object} */ function() {\r\n\t\t\t\t  if (!this.lengthKnown) {\r\n\t\t\t\t\tthis.cacheLength();\r\n\t\t\t\t  }\r\n\t\t\t\t  return this._chunkSize;\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t});\r\n\r\n\t\t\tvar properties = { isDevice: false, contents: lazyArray };\r\n\t\t  } else {\r\n\t\t\tvar properties = { isDevice: false, url: url };\r\n\t\t  }\r\n\r\n\t\t  var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n\t\t  // This is a total hack, but I want to get this lazy file code out of the\r\n\t\t  // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n\t\t  // be its own thin LAZYFS proxying calls to MEMFS.\r\n\t\t  if (properties.contents) {\r\n\t\t\tnode.contents = properties.contents;\r\n\t\t  } else if (properties.url) {\r\n\t\t\tnode.contents = null;\r\n\t\t\tnode.url = properties.url;\r\n\t\t  }\r\n\t\t  // Add a function that defers querying the file size until it is asked the first time.\r\n\t\t  Object.defineProperties(node, {\r\n\t\t\tusedBytes: {\r\n\t\t\t  get: /** @this {FSNode} */ function() { return this.contents.length; }\r\n\t\t\t}\r\n\t\t  });\r\n\t\t  // override each stream op with one that tries to force load the lazy file first\r\n\t\t  var stream_ops = {};\r\n\t\t  var keys = Object.keys(node.stream_ops);\r\n\t\t  keys.forEach((key) => {\r\n\t\t\tvar fn = node.stream_ops[key];\r\n\t\t\tstream_ops[key] = function forceLoadLazyFile() {\r\n\t\t\t  FS.forceLoadFile(node);\r\n\t\t\t  return fn.apply(null, arguments);\r\n\t\t\t};\r\n\t\t  });\r\n\t\t  function writeChunks(stream, buffer, offset, length, position) {\r\n\t\t\tvar contents = stream.node.contents;\r\n\t\t\tif (position >= contents.length)\r\n\t\t\t  return 0;\r\n\t\t\tvar size = Math.min(contents.length - position, length);\r\n\t\t\tassert(size >= 0);\r\n\t\t\tif (contents.slice) { // normal array\r\n\t\t\t  for (var i = 0; i < size; i++) {\r\n\t\t\t\tbuffer[offset + i] = contents[position + i];\r\n\t\t\t  }\r\n\t\t\t} else {\r\n\t\t\t  for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n\t\t\t\tbuffer[offset + i] = contents.get(position + i);\r\n\t\t\t  }\r\n\t\t\t}\r\n\t\t\treturn size;\r\n\t\t  }\r\n\t\t  // use a custom read function\r\n\t\t  stream_ops.read = (stream, buffer, offset, length, position) => {\r\n\t\t\tFS.forceLoadFile(node);\r\n\t\t\treturn writeChunks(stream, buffer, offset, length, position)\r\n\t\t  };\r\n\t\t  // use a custom mmap function\r\n\t\t  stream_ops.mmap = (stream, length, position, prot, flags) => {\r\n\t\t\tFS.forceLoadFile(node);\r\n\t\t\tvar ptr = mmapAlloc();\r\n\t\t\tif (!ptr) {\r\n\t\t\t  throw new FS.ErrnoError(48);\r\n\t\t\t}\r\n\t\t\twriteChunks(stream, HEAP8, ptr, length, position);\r\n\t\t\treturn { ptr, allocated: true };\r\n\t\t  };\r\n\t\t  node.stream_ops = stream_ops;\r\n\t\t  return node;\r\n\t\t},\r\n\tabsolutePath() {\r\n\t\t  abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\r\n\t\t},\r\n\tcreateFolder() {\r\n\t\t  abort('FS.createFolder has been removed; use FS.mkdir instead');\r\n\t\t},\r\n\tcreateLink() {\r\n\t\t  abort('FS.createLink has been removed; use FS.symlink instead');\r\n\t\t},\r\n\tjoinPath() {\r\n\t\t  abort('FS.joinPath has been removed; use PATH.join instead');\r\n\t\t},\r\n\tmmapAlloc() {\r\n\t\t  abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\r\n\t\t},\r\n\tstandardizePath() {\r\n\t\t  abort('FS.standardizePath has been removed; use PATH.normalize instead');\r\n\t\t},\r\n\t};\r\n\r\n\tvar SYSCALLS = {\r\n\tDEFAULT_POLLMASK:5,\r\n\tcalculateAt(dirfd, path, allowEmpty) {\r\n\t\t  if (PATH.isAbs(path)) {\r\n\t\t\treturn path;\r\n\t\t  }\r\n\t\t  // relative path\r\n\t\t  var dir;\r\n\t\t  if (dirfd === -100) {\r\n\t\t\tdir = FS.cwd();\r\n\t\t  } else {\r\n\t\t\tvar dirstream = SYSCALLS.getStreamFromFD(dirfd);\r\n\t\t\tdir = dirstream.path;\r\n\t\t  }\r\n\t\t  if (path.length == 0) {\r\n\t\t\tif (!allowEmpty) {\r\n\t\t\t  throw new FS.ErrnoError(44);          }\r\n\t\t\treturn dir;\r\n\t\t  }\r\n\t\t  return PATH.join2(dir, path);\r\n\t\t},\r\n\tdoStat(func, path, buf) {\r\n\t\t  try {\r\n\t\t\tvar stat = func(path);\r\n\t\t  } catch (e) {\r\n\t\t\tif (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n\t\t\t  // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n\t\t\t  return -54;\r\n\t\t\t}\r\n\t\t\tthrow e;\r\n\t\t  }\r\n\t\t  HEAP32[((buf)>>2)] = stat.dev;\r\n\t\t  HEAP32[(((buf)+(4))>>2)] = stat.mode;\r\n\t\t  HEAPU32[(((buf)+(8))>>2)] = stat.nlink;\r\n\t\t  HEAP32[(((buf)+(12))>>2)] = stat.uid;\r\n\t\t  HEAP32[(((buf)+(16))>>2)] = stat.gid;\r\n\t\t  HEAP32[(((buf)+(20))>>2)] = stat.rdev;\r\n\t\t  (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(24))>>2)] = tempI64[0],HEAP32[(((buf)+(28))>>2)] = tempI64[1]);\r\n\t\t  HEAP32[(((buf)+(32))>>2)] = 4096;\r\n\t\t  HEAP32[(((buf)+(36))>>2)] = stat.blocks;\r\n\t\t  var atime = stat.atime.getTime();\r\n\t\t  var mtime = stat.mtime.getTime();\r\n\t\t  var ctime = stat.ctime.getTime();\r\n\t\t  (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble=Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);\r\n\t\t  HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000;\r\n\t\t  (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble=Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);\r\n\t\t  HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000;\r\n\t\t  (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble=Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);\r\n\t\t  HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000;\r\n\t\t  (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);\r\n\t\t  return 0;\r\n\t\t},\r\n\tdoMsync(addr, stream, len, flags, offset) {\r\n\t\t  if (!FS.isFile(stream.node.mode)) {\r\n\t\t\tthrow new FS.ErrnoError(43);\r\n\t\t  }\r\n\t\t  if (flags & 2) {\r\n\t\t\t// MAP_PRIVATE calls need not to be synced back to underlying fs\r\n\t\t\treturn 0;\r\n\t\t  }\r\n\t\t  var buffer = HEAPU8.slice(addr, addr + len);\r\n\t\t  FS.msync(stream, buffer, offset, len, flags);\r\n\t\t},\r\n\tvarargs:undefined,\r\n\tget() {\r\n\t\t  assert(SYSCALLS.varargs != undefined);\r\n\t\t  // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\r\n\t\t  var ret = HEAP32[((+SYSCALLS.varargs)>>2)];\r\n\t\t  SYSCALLS.varargs += 4;\r\n\t\t  return ret;\r\n\t\t},\r\n\tgetp() { return SYSCALLS.get() },\r\n\tgetStr(ptr) {\r\n\t\t  var ret = UTF8ToString(ptr);\r\n\t\t  return ret;\r\n\t\t},\r\n\tgetStreamFromFD(fd) {\r\n\t\t  var stream = FS.getStreamChecked(fd);\r\n\t\t  return stream;\r\n\t\t},\r\n\t};\r\n\tvar _environ_get = (__environ, environ_buf) => {\r\n\t\tvar bufSize = 0;\r\n\t\tgetEnvStrings().forEach((string, i) => {\r\n\t\t  var ptr = environ_buf + bufSize;\r\n\t\t  HEAPU32[(((__environ)+(i*4))>>2)] = ptr;\r\n\t\t  stringToAscii(string, ptr);\r\n\t\t  bufSize += string.length + 1;\r\n\t\t});\r\n\t\treturn 0;\r\n\t  };\r\n\r\n\r\n\tvar _environ_sizes_get = (penviron_count, penviron_buf_size) => {\r\n\t\tvar strings = getEnvStrings();\r\n\t\tHEAPU32[((penviron_count)>>2)] = strings.length;\r\n\t\tvar bufSize = 0;\r\n\t\tstrings.forEach((string) => bufSize += string.length + 1);\r\n\t\tHEAPU32[((penviron_buf_size)>>2)] = bufSize;\r\n\t\treturn 0;\r\n\t  };\r\n\r\n\r\n\tvar runtimeKeepaliveCounter = 0;\r\n\tvar keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\r\n\r\n\tvar _proc_exit = (code) => {\r\n\t\tEXITSTATUS = code;\r\n\t\tif (!keepRuntimeAlive()) {\r\n\t\t  if (Module['onExit']) Module['onExit'](code);\r\n\t\t  ABORT = true;\r\n\t\t}\r\n\t\tquit_(code, new ExitStatus(code));\r\n\t  };\r\n\r\n\t/** @suppress {duplicate } */\r\n\t/** @param {boolean|number=} implicit */\r\n\tvar exitJS = (status, implicit) => {\r\n\t\tEXITSTATUS = status;\r\n\r\n\t\tcheckUnflushedContent();\r\n\r\n\t\t// if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\r\n\t\tif (keepRuntimeAlive() && !implicit) {\r\n\t\t  var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\r\n\t\t  readyPromiseReject(msg);\r\n\t\t  err(msg);\r\n\t\t}\r\n\r\n\t\t_proc_exit(status);\r\n\t  };\r\n\tvar _exit = exitJS;\r\n\r\n\tfunction _fd_close(fd) {\r\n\ttry {\r\n\r\n\t\tvar stream = SYSCALLS.getStreamFromFD(fd);\r\n\t\tFS.close(stream);\r\n\t\treturn 0;\r\n\t  } catch (e) {\r\n\t  if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n\t  return e.errno;\r\n\t}\r\n\t}\r\n\r\n\t/** @param {number=} offset */\r\n\tvar doReadv = (stream, iov, iovcnt, offset) => {\r\n\t\tvar ret = 0;\r\n\t\tfor (var i = 0; i < iovcnt; i++) {\r\n\t\t  var ptr = HEAPU32[((iov)>>2)];\r\n\t\t  var len = HEAPU32[(((iov)+(4))>>2)];\r\n\t\t  iov += 8;\r\n\t\t  var curr = FS.read(stream, HEAP8, ptr, len, offset);\r\n\t\t  if (curr < 0) return -1;\r\n\t\t  ret += curr;\r\n\t\t  if (curr < len) break; // nothing more to read\r\n\t\t  if (typeof offset !== 'undefined') {\r\n\t\t\toffset += curr;\r\n\t\t  }\r\n\t\t}\r\n\t\treturn ret;\r\n\t  };\r\n\r\n\tfunction _fd_read(fd, iov, iovcnt, pnum) {\r\n\ttry {\r\n\r\n\t\tvar stream = SYSCALLS.getStreamFromFD(fd);\r\n\t\tvar num = doReadv(stream, iov, iovcnt);\r\n\t\tHEAPU32[((pnum)>>2)] = num;\r\n\t\treturn 0;\r\n\t  } catch (e) {\r\n\t  if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n\t  return e.errno;\r\n\t}\r\n\t}\r\n\r\n\r\n\tvar convertI32PairToI53Checked = (lo, hi) => {\r\n\t\tassert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32\r\n\t\tassert(hi === (hi|0));                    // hi should be a i32\r\n\t\treturn ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\r\n\t  };\r\n\tfunction _fd_seek(fd,offset_low, offset_high,whence,newOffset) {\r\n\t  var offset = convertI32PairToI53Checked(offset_low, offset_high);\r\n\r\n\ttry {\r\n\r\n\t\tif (isNaN(offset)) return 61;\r\n\t\tvar stream = SYSCALLS.getStreamFromFD(fd);\r\n\t\tFS.llseek(stream, offset, whence);\r\n\t\t(tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);\r\n\t\tif (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n\t\treturn 0;\r\n\t  } catch (e) {\r\n\t  if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n\t  return e.errno;\r\n\t}\r\n\t}\r\n\r\n\t/** @param {number=} offset */\r\n\tvar doWritev = (stream, iov, iovcnt, offset) => {\r\n\t\tvar ret = 0;\r\n\t\tfor (var i = 0; i < iovcnt; i++) {\r\n\t\t  var ptr = HEAPU32[((iov)>>2)];\r\n\t\t  var len = HEAPU32[(((iov)+(4))>>2)];\r\n\t\t  iov += 8;\r\n\t\t  var curr = FS.write(stream, HEAP8, ptr, len, offset);\r\n\t\t  if (curr < 0) return -1;\r\n\t\t  ret += curr;\r\n\t\t  if (typeof offset !== 'undefined') {\r\n\t\t\toffset += curr;\r\n\t\t  }\r\n\t\t}\r\n\t\treturn ret;\r\n\t  };\r\n\r\n\tfunction _fd_write(fd, iov, iovcnt, pnum) {\r\n\ttry {\r\n\r\n\t\tvar stream = SYSCALLS.getStreamFromFD(fd);\r\n\t\tvar num = doWritev(stream, iov, iovcnt);\r\n\t\tHEAPU32[((pnum)>>2)] = num;\r\n\t\treturn 0;\r\n\t  } catch (e) {\r\n\t  if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n\t  return e.errno;\r\n\t}\r\n\t}\r\n\r\n\tvar isLeapYear = (year) => {\r\n\t\t  return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\r\n\t  };\r\n\r\n\tvar arraySum = (array, index) => {\r\n\t\tvar sum = 0;\r\n\t\tfor (var i = 0; i <= index; sum += array[i++]) {\r\n\t\t  // no-op\r\n\t\t}\r\n\t\treturn sum;\r\n\t  };\r\n\r\n\r\n\tvar MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];\r\n\r\n\tvar MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];\r\n\tvar addDays = (date, days) => {\r\n\t\tvar newDate = new Date(date.getTime());\r\n\t\twhile (days > 0) {\r\n\t\t  var leap = isLeapYear(newDate.getFullYear());\r\n\t\t  var currentMonth = newDate.getMonth();\r\n\t\t  var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\r\n\r\n\t\t  if (days > daysInCurrentMonth-newDate.getDate()) {\r\n\t\t\t// we spill over to next month\r\n\t\t\tdays -= (daysInCurrentMonth-newDate.getDate()+1);\r\n\t\t\tnewDate.setDate(1);\r\n\t\t\tif (currentMonth < 11) {\r\n\t\t\t  newDate.setMonth(currentMonth+1);\r\n\t\t\t} else {\r\n\t\t\t  newDate.setMonth(0);\r\n\t\t\t  newDate.setFullYear(newDate.getFullYear()+1);\r\n\t\t\t}\r\n\t\t  } else {\r\n\t\t\t// we stay in current month\r\n\t\t\tnewDate.setDate(newDate.getDate()+days);\r\n\t\t\treturn newDate;\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\treturn newDate;\r\n\t  };\r\n\r\n\r\n\r\n\r\n\tvar writeArrayToMemory = (array, buffer) => {\r\n\t\tassert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\r\n\t\tHEAP8.set(array, buffer);\r\n\t  };\r\n\r\n\tvar _strftime = (s, maxsize, format, tm) => {\r\n\t\t// size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\r\n\t\t// http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\r\n\r\n\t\tvar tm_zone = HEAPU32[(((tm)+(40))>>2)];\r\n\r\n\t\tvar date = {\r\n\t\t  tm_sec: HEAP32[((tm)>>2)],\r\n\t\t  tm_min: HEAP32[(((tm)+(4))>>2)],\r\n\t\t  tm_hour: HEAP32[(((tm)+(8))>>2)],\r\n\t\t  tm_mday: HEAP32[(((tm)+(12))>>2)],\r\n\t\t  tm_mon: HEAP32[(((tm)+(16))>>2)],\r\n\t\t  tm_year: HEAP32[(((tm)+(20))>>2)],\r\n\t\t  tm_wday: HEAP32[(((tm)+(24))>>2)],\r\n\t\t  tm_yday: HEAP32[(((tm)+(28))>>2)],\r\n\t\t  tm_isdst: HEAP32[(((tm)+(32))>>2)],\r\n\t\t  tm_gmtoff: HEAP32[(((tm)+(36))>>2)],\r\n\t\t  tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\r\n\t\t};\r\n\r\n\t\tvar pattern = UTF8ToString(format);\r\n\r\n\t\t// expand format\r\n\t\tvar EXPANSION_RULES_1 = {\r\n\t\t  '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013\r\n\t\t  '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y\r\n\t\t  '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d\r\n\t\t  '%h': '%b',                       // Equivalent to %b\r\n\t\t  '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation\r\n\t\t  '%R': '%H:%M',                    // Replaced by the time in 24-hour notation\r\n\t\t  '%T': '%H:%M:%S',                 // Replaced by the time\r\n\t\t  '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation\r\n\t\t  '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation\r\n\t\t  // Modified Conversion Specifiers\r\n\t\t  '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.\r\n\t\t  '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.\r\n\t\t  '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.\r\n\t\t  '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.\r\n\t\t  '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.\r\n\t\t  '%EY': '%Y',                      // Replaced by the full alternative year representation.\r\n\t\t  '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.\r\n\t\t  '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.\r\n\t\t  '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.\r\n\t\t  '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.\r\n\t\t  '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.\r\n\t\t  '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.\r\n\t\t  '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.\r\n\t\t  '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).\r\n\t\t  '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.\r\n\t\t  '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.\r\n\t\t  '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.\r\n\t\t  '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.\r\n\t\t  '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.\r\n\t\t};\r\n\t\tfor (var rule in EXPANSION_RULES_1) {\r\n\t\t  pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\r\n\t\t}\r\n\r\n\t\tvar WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n\t\tvar MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\r\n\r\n\t\tfunction leadingSomething(value, digits, character) {\r\n\t\t  var str = typeof value == 'number' ? value.toString() : (value || '');\r\n\t\t  while (str.length < digits) {\r\n\t\t\tstr = character[0]+str;\r\n\t\t  }\r\n\t\t  return str;\r\n\t\t}\r\n\r\n\t\tfunction leadingNulls(value, digits) {\r\n\t\t  return leadingSomething(value, digits, '0');\r\n\t\t}\r\n\r\n\t\tfunction compareByDay(date1, date2) {\r\n\t\t  function sgn(value) {\r\n\t\t\treturn value < 0 ? -1 : (value > 0 ? 1 : 0);\r\n\t\t  }\r\n\r\n\t\t  var compare;\r\n\t\t  if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {\r\n\t\t\tif ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {\r\n\t\t\t  compare = sgn(date1.getDate()-date2.getDate());\r\n\t\t\t}\r\n\t\t  }\r\n\t\t  return compare;\r\n\t\t}\r\n\r\n\t\tfunction getFirstWeekStartDate(janFourth) {\r\n\t\t\tswitch (janFourth.getDay()) {\r\n\t\t\t  case 0: // Sunday\r\n\t\t\t\treturn new Date(janFourth.getFullYear()-1, 11, 29);\r\n\t\t\t  case 1: // Monday\r\n\t\t\t\treturn janFourth;\r\n\t\t\t  case 2: // Tuesday\r\n\t\t\t\treturn new Date(janFourth.getFullYear(), 0, 3);\r\n\t\t\t  case 3: // Wednesday\r\n\t\t\t\treturn new Date(janFourth.getFullYear(), 0, 2);\r\n\t\t\t  case 4: // Thursday\r\n\t\t\t\treturn new Date(janFourth.getFullYear(), 0, 1);\r\n\t\t\t  case 5: // Friday\r\n\t\t\t\treturn new Date(janFourth.getFullYear()-1, 11, 31);\r\n\t\t\t  case 6: // Saturday\r\n\t\t\t\treturn new Date(janFourth.getFullYear()-1, 11, 30);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction getWeekBasedYear(date) {\r\n\t\t\tvar thisDate = addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\r\n\r\n\t\t\tvar janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\r\n\t\t\tvar janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);\r\n\r\n\t\t\tvar firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n\t\t\tvar firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n\r\n\t\t\tif (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\r\n\t\t\t  // this date is after the start of the first week of this year\r\n\t\t\t  if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\r\n\t\t\t\treturn thisDate.getFullYear()+1;\r\n\t\t\t  }\r\n\t\t\t  return thisDate.getFullYear();\r\n\t\t\t}\r\n\t\t\treturn thisDate.getFullYear()-1;\r\n\t\t}\r\n\r\n\t\tvar EXPANSION_RULES_2 = {\r\n\t\t  '%a': (date) => WEEKDAYS[date.tm_wday].substring(0,3) ,\r\n\t\t  '%A': (date) => WEEKDAYS[date.tm_wday],\r\n\t\t  '%b': (date) => MONTHS[date.tm_mon].substring(0,3),\r\n\t\t  '%B': (date) => MONTHS[date.tm_mon],\r\n\t\t  '%C': (date) => {\r\n\t\t\tvar year = date.tm_year+1900;\r\n\t\t\treturn leadingNulls((year/100)|0,2);\r\n\t\t  },\r\n\t\t  '%d': (date) => leadingNulls(date.tm_mday, 2),\r\n\t\t  '%e': (date) => leadingSomething(date.tm_mday, 2, ' '),\r\n\t\t  '%g': (date) => {\r\n\t\t\t// %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\r\n\t\t\t// In this system, weeks begin on a Monday and week 1 of the year is the week that includes\r\n\t\t\t// January 4th, which is also the week that includes the first Thursday of the year, and\r\n\t\t\t// is also the first week that contains at least four days in the year.\r\n\t\t\t// If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\r\n\t\t\t// the last week of the preceding year; thus, for Saturday 2nd January 1999,\r\n\t\t\t// %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\r\n\t\t\t// or 31st is a Monday, it and any following days are part of week 1 of the following year.\r\n\t\t\t// Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\r\n\r\n\t\t\treturn getWeekBasedYear(date).toString().substring(2);\r\n\t\t  },\r\n\t\t  '%G': (date) => getWeekBasedYear(date),\r\n\t\t  '%H': (date) => leadingNulls(date.tm_hour, 2),\r\n\t\t  '%I': (date) => {\r\n\t\t\tvar twelveHour = date.tm_hour;\r\n\t\t\tif (twelveHour == 0) twelveHour = 12;\r\n\t\t\telse if (twelveHour > 12) twelveHour -= 12;\r\n\t\t\treturn leadingNulls(twelveHour, 2);\r\n\t\t  },\r\n\t\t  '%j': (date) => {\r\n\t\t\t// Day of the year (001-366)\r\n\t\t\treturn leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year+1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon-1), 3);\r\n\t\t  },\r\n\t\t  '%m': (date) => leadingNulls(date.tm_mon+1, 2),\r\n\t\t  '%M': (date) => leadingNulls(date.tm_min, 2),\r\n\t\t  '%n': () => '\\n',\r\n\t\t  '%p': (date) => {\r\n\t\t\tif (date.tm_hour >= 0 && date.tm_hour < 12) {\r\n\t\t\t  return 'AM';\r\n\t\t\t}\r\n\t\t\treturn 'PM';\r\n\t\t  },\r\n\t\t  '%S': (date) => leadingNulls(date.tm_sec, 2),\r\n\t\t  '%t': () => '\\t',\r\n\t\t  '%u': (date) => date.tm_wday || 7,\r\n\t\t  '%U': (date) => {\r\n\t\t\tvar days = date.tm_yday + 7 - date.tm_wday;\r\n\t\t\treturn leadingNulls(Math.floor(days / 7), 2);\r\n\t\t  },\r\n\t\t  '%V': (date) => {\r\n\t\t\t// Replaced by the week number of the year (Monday as the first day of the week)\r\n\t\t\t// as a decimal number [01,53]. If the week containing 1 January has four\r\n\t\t\t// or more days in the new year, then it is considered week 1.\r\n\t\t\t// Otherwise, it is the last week of the previous year, and the next week is week 1.\r\n\t\t\t// Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\r\n\t\t\tvar val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);\r\n\t\t\t// If 1 Jan is just 1-3 days past Monday, the previous week\r\n\t\t\t// is also in this year.\r\n\t\t\tif ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\r\n\t\t\t  val++;\r\n\t\t\t}\r\n\t\t\tif (!val) {\r\n\t\t\t  val = 52;\r\n\t\t\t  // If 31 December of prev year a Thursday, or Friday of a\r\n\t\t\t  // leap year, then the prev year has 53 weeks.\r\n\t\t\t  var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\r\n\t\t\t  if (dec31 == 4 || (dec31 == 5 && isLeapYear(date.tm_year%400-1))) {\r\n\t\t\t\tval++;\r\n\t\t\t  }\r\n\t\t\t} else if (val == 53) {\r\n\t\t\t  // If 1 January is not a Thursday, and not a Wednesday of a\r\n\t\t\t  // leap year, then this year has only 52 weeks.\r\n\t\t\t  var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\r\n\t\t\t  if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year)))\r\n\t\t\t\tval = 1;\r\n\t\t\t}\r\n\t\t\treturn leadingNulls(val, 2);\r\n\t\t  },\r\n\t\t  '%w': (date) => date.tm_wday,\r\n\t\t  '%W': (date) => {\r\n\t\t\tvar days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\r\n\t\t\treturn leadingNulls(Math.floor(days / 7), 2);\r\n\t\t  },\r\n\t\t  '%y': (date) => {\r\n\t\t\t// Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\r\n\t\t\treturn (date.tm_year+1900).toString().substring(2);\r\n\t\t  },\r\n\t\t  // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\r\n\t\t  '%Y': (date) => date.tm_year+1900,\r\n\t\t  '%z': (date) => {\r\n\t\t\t// Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\r\n\t\t\t// For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\r\n\t\t\tvar off = date.tm_gmtoff;\r\n\t\t\tvar ahead = off >= 0;\r\n\t\t\toff = Math.abs(off) / 60;\r\n\t\t\t// convert from minutes into hhmm format (which means 60 minutes = 100 units)\r\n\t\t\toff = (off / 60)*100 + (off % 60);\r\n\t\t\treturn (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\r\n\t\t  },\r\n\t\t  '%Z': (date) => date.tm_zone,\r\n\t\t  '%%': () => '%'\r\n\t\t};\r\n\r\n\t\t// Replace %% with a pair of NULLs (which cannot occur in a C string), then\r\n\t\t// re-inject them after processing.\r\n\t\tpattern = pattern.replace(/%%/g, '\\0\\0');\r\n\t\tfor (var rule in EXPANSION_RULES_2) {\r\n\t\t  if (pattern.includes(rule)) {\r\n\t\t\tpattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\r\n\t\t  }\r\n\t\t}\r\n\t\tpattern = pattern.replace(/\\0\\0/g, '%');\r\n\r\n\t\tvar bytes = intArrayFromString(pattern, false);\r\n\t\tif (bytes.length > maxsize) {\r\n\t\t  return 0;\r\n\t\t}\r\n\r\n\t\twriteArrayToMemory(bytes, s);\r\n\t\treturn bytes.length-1;\r\n\t  };\r\n\tvar _strftime_l = (s, maxsize, format, tm, loc) => {\r\n\t\treturn _strftime(s, maxsize, format, tm); // no locale support yet\r\n\t  };\r\n\r\n\r\n\tvar handleException = (e) => {\r\n\t\t// Certain exception types we do not treat as errors since they are used for\r\n\t\t// internal control flow.\r\n\t\t// 1. ExitStatus, which is thrown by exit()\r\n\t\t// 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n\t\t//    that wish to return to JS event loop.\r\n\t\tif (e instanceof ExitStatus || e == 'unwind') {\r\n\t\t  return EXITSTATUS;\r\n\t\t}\r\n\t\tcheckStackCookie();\r\n\t\tif (e instanceof WebAssembly.RuntimeError) {\r\n\t\t  if (_emscripten_stack_get_current() <= 0) {\r\n\t\t\terr('Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)');\r\n\t\t  }\r\n\t\t}\r\n\t\tquit_(1, e);\r\n\t  };\r\n\r\n  InternalError = Module['InternalError'] = class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};\r\n  embind_init_charCodes();\r\n  BindingError = Module['BindingError'] = class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};\r\n  handleAllocatorInit();\r\n  init_emval();UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');\r\n\tvar FSNode = /** @constructor */ function(parent, name, mode, rdev) {\r\n\t  if (!parent) {\r\n\t\tparent = this;  // root node sets parent to itself\r\n\t  }\r\n\t  this.parent = parent;\r\n\t  this.mount = parent.mount;\r\n\t  this.mounted = null;\r\n\t  this.id = FS.nextInode++;\r\n\t  this.name = name;\r\n\t  this.mode = mode;\r\n\t  this.node_ops = {};\r\n\t  this.stream_ops = {};\r\n\t  this.rdev = rdev;\r\n\t};\r\n\tvar readMode = 292/*292*/ | 73/*73*/;\r\n\tvar writeMode = 146/*146*/;\r\n\tObject.defineProperties(FSNode.prototype, {\r\n\t read: {\r\n\t  get: /** @this{FSNode} */function() {\r\n\t   return (this.mode & readMode) === readMode;\r\n\t  },\r\n\t  set: /** @this{FSNode} */function(val) {\r\n\t   val ? this.mode |= readMode : this.mode &= ~readMode;\r\n\t  }\r\n\t },\r\n\t write: {\r\n\t  get: /** @this{FSNode} */function() {\r\n\t   return (this.mode & writeMode) === writeMode;\r\n\t  },\r\n\t  set: /** @this{FSNode} */function(val) {\r\n\t   val ? this.mode |= writeMode : this.mode &= ~writeMode;\r\n\t  }\r\n\t },\r\n\t isFolder: {\r\n\t  get: /** @this{FSNode} */function() {\r\n\t   return FS.isDir(this.mode);\r\n\t  }\r\n\t },\r\n\t isDevice: {\r\n\t  get: /** @this{FSNode} */function() {\r\n\t   return FS.isChrdev(this.mode);\r\n\t  }\r\n\t }\r\n\t});\r\n\tFS.FSNode = FSNode;\r\n\tFS.createPreloadedFile = FS_createPreloadedFile;\r\n\tFS.staticInit();ERRNO_CODES = {\r\n\t\t'EPERM': 63,\r\n\t\t'ENOENT': 44,\r\n\t\t'ESRCH': 71,\r\n\t\t'EINTR': 27,\r\n\t\t'EIO': 29,\r\n\t\t'ENXIO': 60,\r\n\t\t'E2BIG': 1,\r\n\t\t'ENOEXEC': 45,\r\n\t\t'EBADF': 8,\r\n\t\t'ECHILD': 12,\r\n\t\t'EAGAIN': 6,\r\n\t\t'EWOULDBLOCK': 6,\r\n\t\t'ENOMEM': 48,\r\n\t\t'EACCES': 2,\r\n\t\t'EFAULT': 21,\r\n\t\t'ENOTBLK': 105,\r\n\t\t'EBUSY': 10,\r\n\t\t'EEXIST': 20,\r\n\t\t'EXDEV': 75,\r\n\t\t'ENODEV': 43,\r\n\t\t'ENOTDIR': 54,\r\n\t\t'EISDIR': 31,\r\n\t\t'EINVAL': 28,\r\n\t\t'ENFILE': 41,\r\n\t\t'EMFILE': 33,\r\n\t\t'ENOTTY': 59,\r\n\t\t'ETXTBSY': 74,\r\n\t\t'EFBIG': 22,\r\n\t\t'ENOSPC': 51,\r\n\t\t'ESPIPE': 70,\r\n\t\t'EROFS': 69,\r\n\t\t'EMLINK': 34,\r\n\t\t'EPIPE': 64,\r\n\t\t'EDOM': 18,\r\n\t\t'ERANGE': 68,\r\n\t\t'ENOMSG': 49,\r\n\t\t'EIDRM': 24,\r\n\t\t'ECHRNG': 106,\r\n\t\t'EL2NSYNC': 156,\r\n\t\t'EL3HLT': 107,\r\n\t\t'EL3RST': 108,\r\n\t\t'ELNRNG': 109,\r\n\t\t'EUNATCH': 110,\r\n\t\t'ENOCSI': 111,\r\n\t\t'EL2HLT': 112,\r\n\t\t'EDEADLK': 16,\r\n\t\t'ENOLCK': 46,\r\n\t\t'EBADE': 113,\r\n\t\t'EBADR': 114,\r\n\t\t'EXFULL': 115,\r\n\t\t'ENOANO': 104,\r\n\t\t'EBADRQC': 103,\r\n\t\t'EBADSLT': 102,\r\n\t\t'EDEADLOCK': 16,\r\n\t\t'EBFONT': 101,\r\n\t\t'ENOSTR': 100,\r\n\t\t'ENODATA': 116,\r\n\t\t'ETIME': 117,\r\n\t\t'ENOSR': 118,\r\n\t\t'ENONET': 119,\r\n\t\t'ENOPKG': 120,\r\n\t\t'EREMOTE': 121,\r\n\t\t'ENOLINK': 47,\r\n\t\t'EADV': 122,\r\n\t\t'ESRMNT': 123,\r\n\t\t'ECOMM': 124,\r\n\t\t'EPROTO': 65,\r\n\t\t'EMULTIHOP': 36,\r\n\t\t'EDOTDOT': 125,\r\n\t\t'EBADMSG': 9,\r\n\t\t'ENOTUNIQ': 126,\r\n\t\t'EBADFD': 127,\r\n\t\t'EREMCHG': 128,\r\n\t\t'ELIBACC': 129,\r\n\t\t'ELIBBAD': 130,\r\n\t\t'ELIBSCN': 131,\r\n\t\t'ELIBMAX': 132,\r\n\t\t'ELIBEXEC': 133,\r\n\t\t'ENOSYS': 52,\r\n\t\t'ENOTEMPTY': 55,\r\n\t\t'ENAMETOOLONG': 37,\r\n\t\t'ELOOP': 32,\r\n\t\t'EOPNOTSUPP': 138,\r\n\t\t'EPFNOSUPPORT': 139,\r\n\t\t'ECONNRESET': 15,\r\n\t\t'ENOBUFS': 42,\r\n\t\t'EAFNOSUPPORT': 5,\r\n\t\t'EPROTOTYPE': 67,\r\n\t\t'ENOTSOCK': 57,\r\n\t\t'ENOPROTOOPT': 50,\r\n\t\t'ESHUTDOWN': 140,\r\n\t\t'ECONNREFUSED': 14,\r\n\t\t'EADDRINUSE': 3,\r\n\t\t'ECONNABORTED': 13,\r\n\t\t'ENETUNREACH': 40,\r\n\t\t'ENETDOWN': 38,\r\n\t\t'ETIMEDOUT': 73,\r\n\t\t'EHOSTDOWN': 142,\r\n\t\t'EHOSTUNREACH': 23,\r\n\t\t'EINPROGRESS': 26,\r\n\t\t'EALREADY': 7,\r\n\t\t'EDESTADDRREQ': 17,\r\n\t\t'EMSGSIZE': 35,\r\n\t\t'EPROTONOSUPPORT': 66,\r\n\t\t'ESOCKTNOSUPPORT': 137,\r\n\t\t'EADDRNOTAVAIL': 4,\r\n\t\t'ENETRESET': 39,\r\n\t\t'EISCONN': 30,\r\n\t\t'ENOTCONN': 53,\r\n\t\t'ETOOMANYREFS': 141,\r\n\t\t'EUSERS': 136,\r\n\t\t'EDQUOT': 19,\r\n\t\t'ESTALE': 72,\r\n\t\t'ENOTSUP': 138,\r\n\t\t'ENOMEDIUM': 148,\r\n\t\t'EILSEQ': 25,\r\n\t\t'EOVERFLOW': 61,\r\n\t\t'ECANCELED': 11,\r\n\t\t'ENOTRECOVERABLE': 56,\r\n\t\t'EOWNERDEAD': 62,\r\n\t\t'ESTRPIPE': 135,\r\n\t  };function checkIncomingModuleAPI() {\r\n\tignoredModuleProp('fetchSettings');\r\n  }\r\n  var wasmImports = {\r\n\t/** @export */\r\n\t__cxa_throw: ___cxa_throw,\r\n\t/** @export */\r\n\t_embind_finalize_value_object: __embind_finalize_value_object,\r\n\t/** @export */\r\n\t_embind_register_bigint: __embind_register_bigint,\r\n\t/** @export */\r\n\t_embind_register_bool: __embind_register_bool,\r\n\t/** @export */\r\n\t_embind_register_emval: __embind_register_emval,\r\n\t/** @export */\r\n\t_embind_register_float: __embind_register_float,\r\n\t/** @export */\r\n\t_embind_register_function: __embind_register_function,\r\n\t/** @export */\r\n\t_embind_register_integer: __embind_register_integer,\r\n\t/** @export */\r\n\t_embind_register_memory_view: __embind_register_memory_view,\r\n\t/** @export */\r\n\t_embind_register_std_string: __embind_register_std_string,\r\n\t/** @export */\r\n\t_embind_register_std_wstring: __embind_register_std_wstring,\r\n\t/** @export */\r\n\t_embind_register_value_object: __embind_register_value_object,\r\n\t/** @export */\r\n\t_embind_register_value_object_field: __embind_register_value_object_field,\r\n\t/** @export */\r\n\t_embind_register_void: __embind_register_void,\r\n\t/** @export */\r\n\t_emscripten_throw_longjmp: __emscripten_throw_longjmp,\r\n\t/** @export */\r\n\t_emval_decref: __emval_decref,\r\n\t/** @export */\r\n\t_emval_incref: __emval_incref,\r\n\t/** @export */\r\n\t_emval_new_cstring: __emval_new_cstring,\r\n\t/** @export */\r\n\t_emval_take_value: __emval_take_value,\r\n\t/** @export */\r\n\tabort: _abort,\r\n\t/** @export */\r\n\temscripten_memcpy_js: _emscripten_memcpy_js,\r\n\t/** @export */\r\n\temscripten_resize_heap: _emscripten_resize_heap,\r\n\t/** @export */\r\n\tenviron_get: _environ_get,\r\n\t/** @export */\r\n\tenviron_sizes_get: _environ_sizes_get,\r\n\t/** @export */\r\n\texit: _exit,\r\n\t/** @export */\r\n\tfd_close: _fd_close,\r\n\t/** @export */\r\n\tfd_read: _fd_read,\r\n\t/** @export */\r\n\tfd_seek: _fd_seek,\r\n\t/** @export */\r\n\tfd_write: _fd_write,\r\n\t/** @export */\r\n\tinvoke_ii: invoke_ii,\r\n\t/** @export */\r\n\tinvoke_iii: invoke_iii,\r\n\t/** @export */\r\n\tinvoke_iiii: invoke_iiii,\r\n\t/** @export */\r\n\tinvoke_iiiii: invoke_iiiii,\r\n\t/** @export */\r\n\tinvoke_vi: invoke_vi,\r\n\t/** @export */\r\n\tinvoke_viii: invoke_viii,\r\n\t/** @export */\r\n\tstrftime_l: _strftime_l\r\n  };\r\n  var wasmExports = createWasm();\r\n  var _malloc = createExportWrapper('malloc');\r\n  var _main = Module['_main'] = createExportWrapper('main');\r\n  var _free = createExportWrapper('free');\r\n  var ___getTypeName = createExportWrapper('__getTypeName');\r\n  Module['__embind_initialize_bindings'] = createExportWrapper('_embind_initialize_bindings');\r\n  var _fflush = Module['_fflush'] = createExportWrapper('fflush');\r\n  var _setThrew = createExportWrapper('setThrew');\r\n  var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\r\n  var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\r\n  var stackSave = createExportWrapper('stackSave');\r\n  var stackRestore = createExportWrapper('stackRestore');\r\n  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\r\n  var ___cxa_is_pointer_type = createExportWrapper('__cxa_is_pointer_type');\r\n  Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji');\r\n  Module['dynCall_viijii'] = createExportWrapper('dynCall_viijii');\r\n  Module['dynCall_iiiiij'] = createExportWrapper('dynCall_iiiiij');\r\n  Module['dynCall_iiiiijj'] = createExportWrapper('dynCall_iiiiijj');\r\n  Module['dynCall_iiiiiijj'] = createExportWrapper('dynCall_iiiiiijj');\r\n\r\n  function invoke_ii(index,a1) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  return getWasmTableEntry(index)(a1);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n  function invoke_vi(index,a1) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  getWasmTableEntry(index)(a1);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n  function invoke_viii(index,a1,a2,a3) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  getWasmTableEntry(index)(a1,a2,a3);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n  function invoke_iiii(index,a1,a2,a3) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  return getWasmTableEntry(index)(a1,a2,a3);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n  function invoke_iii(index,a1,a2) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  return getWasmTableEntry(index)(a1,a2);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n  function invoke_iiiii(index,a1,a2,a3,a4) {\r\n\tvar sp = stackSave();\r\n\ttry {\r\n\t  return getWasmTableEntry(index)(a1,a2,a3,a4);\r\n\t} catch(e) {\r\n\t  stackRestore(sp);\r\n\t  if (e !== e+0) throw e;\r\n\t  _setThrew(1, 0);\r\n\t}\r\n  }\r\n\r\n\r\n  // include: postamble.js\r\n  // === Auto-generated postamble setup entry stuff ===\r\n\r\n  var missingLibrarySymbols = [\r\n\t'writeI53ToI64',\r\n\t'writeI53ToI64Clamped',\r\n\t'writeI53ToI64Signaling',\r\n\t'writeI53ToU64Clamped',\r\n\t'writeI53ToU64Signaling',\r\n\t'readI53FromI64',\r\n\t'readI53FromU64',\r\n\t'convertI32PairToI53',\r\n\t'convertU32PairToI53',\r\n\t'ydayFromDate',\r\n\t'setErrNo',\r\n\t'inetPton4',\r\n\t'inetNtop4',\r\n\t'inetPton6',\r\n\t'inetNtop6',\r\n\t'readSockaddr',\r\n\t'writeSockaddr',\r\n\t'getHostByName',\r\n\t'getCallstack',\r\n\t'emscriptenLog',\r\n\t'convertPCtoSourceLocation',\r\n\t'readEmAsmArgs',\r\n\t'jstoi_q',\r\n\t'jstoi_s',\r\n\t'listenOnce',\r\n\t'autoResumeAudioContext',\r\n\t'runtimeKeepalivePush',\r\n\t'runtimeKeepalivePop',\r\n\t'callUserCallback',\r\n\t'maybeExit',\r\n\t'asmjsMangle',\r\n\t'getNativeTypeSize',\r\n\t'STACK_SIZE',\r\n\t'STACK_ALIGN',\r\n\t'POINTER_SIZE',\r\n\t'ASSERTIONS',\r\n\t'getCFunc',\r\n\t'ccall',\r\n\t'cwrap',\r\n\t'uleb128Encode',\r\n\t'sigToWasmTypes',\r\n\t'generateFuncType',\r\n\t'convertJsFunctionToWasm',\r\n\t'getEmptyTableSlot',\r\n\t'updateTableMap',\r\n\t'getFunctionAddress',\r\n\t'addFunction',\r\n\t'removeFunction',\r\n\t'reallyNegative',\r\n\t'unSign',\r\n\t'strLen',\r\n\t'reSign',\r\n\t'formatString',\r\n\t'intArrayToString',\r\n\t'AsciiToString',\r\n\t'stringToNewUTF8',\r\n\t'stringToUTF8OnStack',\r\n\t'registerKeyEventCallback',\r\n\t'maybeCStringToJsString',\r\n\t'findEventTarget',\r\n\t'findCanvasEventTarget',\r\n\t'getBoundingClientRect',\r\n\t'fillMouseEventData',\r\n\t'registerMouseEventCallback',\r\n\t'registerWheelEventCallback',\r\n\t'registerUiEventCallback',\r\n\t'registerFocusEventCallback',\r\n\t'fillDeviceOrientationEventData',\r\n\t'registerDeviceOrientationEventCallback',\r\n\t'fillDeviceMotionEventData',\r\n\t'registerDeviceMotionEventCallback',\r\n\t'screenOrientation',\r\n\t'fillOrientationChangeEventData',\r\n\t'registerOrientationChangeEventCallback',\r\n\t'fillFullscreenChangeEventData',\r\n\t'registerFullscreenChangeEventCallback',\r\n\t'JSEvents_requestFullscreen',\r\n\t'JSEvents_resizeCanvasForFullscreen',\r\n\t'registerRestoreOldStyle',\r\n\t'hideEverythingExceptGivenElement',\r\n\t'restoreHiddenElements',\r\n\t'setLetterbox',\r\n\t'softFullscreenResizeWebGLRenderTarget',\r\n\t'doRequestFullscreen',\r\n\t'fillPointerlockChangeEventData',\r\n\t'registerPointerlockChangeEventCallback',\r\n\t'registerPointerlockErrorEventCallback',\r\n\t'requestPointerLock',\r\n\t'fillVisibilityChangeEventData',\r\n\t'registerVisibilityChangeEventCallback',\r\n\t'registerTouchEventCallback',\r\n\t'fillGamepadEventData',\r\n\t'registerGamepadEventCallback',\r\n\t'registerBeforeUnloadEventCallback',\r\n\t'fillBatteryEventData',\r\n\t'battery',\r\n\t'registerBatteryEventCallback',\r\n\t'setCanvasElementSize',\r\n\t'getCanvasElementSize',\r\n\t'jsStackTrace',\r\n\t'stackTrace',\r\n\t'checkWasiClock',\r\n\t'wasiRightsToMuslOFlags',\r\n\t'wasiOFlagsToMuslOFlags',\r\n\t'createDyncallWrapper',\r\n\t'safeSetTimeout',\r\n\t'setImmediateWrapped',\r\n\t'clearImmediateWrapped',\r\n\t'polyfillSetImmediate',\r\n\t'getPromise',\r\n\t'makePromise',\r\n\t'idsToPromises',\r\n\t'makePromiseCallback',\r\n\t'findMatchingCatch',\r\n\t'setMainLoop',\r\n\t'getSocketFromFD',\r\n\t'getSocketAddress',\r\n\t'FS_unlink',\r\n\t'FS_mkdirTree',\r\n\t'_setNetworkCallback',\r\n\t'heapObjectForWebGLType',\r\n\t'heapAccessShiftForWebGLHeap',\r\n\t'webgl_enable_ANGLE_instanced_arrays',\r\n\t'webgl_enable_OES_vertex_array_object',\r\n\t'webgl_enable_WEBGL_draw_buffers',\r\n\t'webgl_enable_WEBGL_multi_draw',\r\n\t'emscriptenWebGLGet',\r\n\t'computeUnpackAlignedImageSize',\r\n\t'colorChannelsInGlTextureFormat',\r\n\t'emscriptenWebGLGetTexPixelData',\r\n\t'__glGenObject',\r\n\t'emscriptenWebGLGetUniform',\r\n\t'webglGetUniformLocation',\r\n\t'webglPrepareUniformLocationsBeforeFirstUse',\r\n\t'webglGetLeftBracePos',\r\n\t'emscriptenWebGLGetVertexAttrib',\r\n\t'__glGetActiveAttribOrUniform',\r\n\t'writeGLArray',\r\n\t'registerWebGlEventCallback',\r\n\t'runAndAbortIfError',\r\n\t'SDL_unicode',\r\n\t'SDL_ttfContext',\r\n\t'SDL_audio',\r\n\t'ALLOC_NORMAL',\r\n\t'ALLOC_STACK',\r\n\t'allocate',\r\n\t'writeStringToMemory',\r\n\t'writeAsciiToMemory',\r\n\t'getFunctionArgsName',\r\n\t'init_embind',\r\n\t'getBasestPointer',\r\n\t'registerInheritedInstance',\r\n\t'unregisterInheritedInstance',\r\n\t'getInheritedInstance',\r\n\t'getInheritedInstanceCount',\r\n\t'getLiveInheritedInstances',\r\n\t'enumReadValueFromPointer',\r\n\t'genericPointerToWireType',\r\n\t'constNoSmartPtrRawPointerToWireType',\r\n\t'nonConstNoSmartPtrRawPointerToWireType',\r\n\t'init_RegisteredPointer',\r\n\t'RegisteredPointer',\r\n\t'RegisteredPointer_fromWireType',\r\n\t'runDestructor',\r\n\t'releaseClassHandle',\r\n\t'detachFinalizer',\r\n\t'attachFinalizer',\r\n\t'makeClassHandle',\r\n\t'init_ClassHandle',\r\n\t'ClassHandle',\r\n\t'throwInstanceAlreadyDeleted',\r\n\t'flushPendingDeletes',\r\n\t'setDelayFunction',\r\n\t'RegisteredClass',\r\n\t'shallowCopyInternalPointer',\r\n\t'downcastPointer',\r\n\t'upcastPointer',\r\n\t'validateThis',\r\n\t'craftEmvalAllocator',\r\n\t'emval_get_global',\r\n\t'emval_lookupTypes',\r\n\t'emval_addMethodCaller',\r\n  ];\r\n  missingLibrarySymbols.forEach(missingLibrarySymbol);\r\n\r\n  var unexportedSymbols = [\r\n\t'run',\r\n\t'addOnPreRun',\r\n\t'addOnInit',\r\n\t'addOnPreMain',\r\n\t'addOnExit',\r\n\t'addOnPostRun',\r\n\t'addRunDependency',\r\n\t'removeRunDependency',\r\n\t'FS_createFolder',\r\n\t'FS_createPath',\r\n\t'FS_createLazyFile',\r\n\t'FS_createLink',\r\n\t'FS_createDevice',\r\n\t'FS_readFile',\r\n\t'out',\r\n\t'err',\r\n\t'callMain',\r\n\t'abort',\r\n\t'wasmMemory',\r\n\t'wasmExports',\r\n\t'stackAlloc',\r\n\t'stackSave',\r\n\t'stackRestore',\r\n\t'getTempRet0',\r\n\t'setTempRet0',\r\n\t'writeStackCookie',\r\n\t'checkStackCookie',\r\n\t'convertI32PairToI53Checked',\r\n\t'ptrToString',\r\n\t'zeroMemory',\r\n\t'exitJS',\r\n\t'getHeapMax',\r\n\t'growMemory',\r\n\t'ENV',\r\n\t'MONTH_DAYS_REGULAR',\r\n\t'MONTH_DAYS_LEAP',\r\n\t'MONTH_DAYS_REGULAR_CUMULATIVE',\r\n\t'MONTH_DAYS_LEAP_CUMULATIVE',\r\n\t'isLeapYear',\r\n\t'arraySum',\r\n\t'addDays',\r\n\t'ERRNO_CODES',\r\n\t'ERRNO_MESSAGES',\r\n\t'DNS',\r\n\t'Protocols',\r\n\t'Sockets',\r\n\t'initRandomFill',\r\n\t'randomFill',\r\n\t'timers',\r\n\t'warnOnce',\r\n\t'UNWIND_CACHE',\r\n\t'readEmAsmArgsArray',\r\n\t'getExecutableName',\r\n\t'dynCallLegacy',\r\n\t'getDynCaller',\r\n\t'dynCall',\r\n\t'handleException',\r\n\t'keepRuntimeAlive',\r\n\t'asyncLoad',\r\n\t'alignMemory',\r\n\t'mmapAlloc',\r\n\t'handleAllocatorInit',\r\n\t'HandleAllocator',\r\n\t'wasmTable',\r\n\t'noExitRuntime',\r\n\t'freeTableIndexes',\r\n\t'functionsInTableMap',\r\n\t'setValue',\r\n\t'getValue',\r\n\t'PATH',\r\n\t'PATH_FS',\r\n\t'UTF8Decoder',\r\n\t'UTF8ArrayToString',\r\n\t'UTF8ToString',\r\n\t'stringToUTF8Array',\r\n\t'stringToUTF8',\r\n\t'lengthBytesUTF8',\r\n\t'intArrayFromString',\r\n\t'stringToAscii',\r\n\t'UTF16Decoder',\r\n\t'UTF16ToString',\r\n\t'stringToUTF16',\r\n\t'lengthBytesUTF16',\r\n\t'UTF32ToString',\r\n\t'stringToUTF32',\r\n\t'lengthBytesUTF32',\r\n\t'writeArrayToMemory',\r\n\t'JSEvents',\r\n\t'specialHTMLTargets',\r\n\t'currentFullscreenStrategy',\r\n\t'restoreOldWindowedStyle',\r\n\t'demangle',\r\n\t'demangleAll',\r\n\t'ExitStatus',\r\n\t'getEnvStrings',\r\n\t'doReadv',\r\n\t'doWritev',\r\n\t'promiseMap',\r\n\t'uncaughtExceptionCount',\r\n\t'exceptionLast',\r\n\t'exceptionCaught',\r\n\t'ExceptionInfo',\r\n\t'Browser',\r\n\t'wget',\r\n\t'SYSCALLS',\r\n\t'preloadPlugins',\r\n\t'FS_createPreloadedFile',\r\n\t'FS_modeStringToFlags',\r\n\t'FS_getMode',\r\n\t'FS_stdin_getChar_buffer',\r\n\t'FS_stdin_getChar',\r\n\t'FS',\r\n\t'FS_createDataFile',\r\n\t'MEMFS',\r\n\t'TTY',\r\n\t'PIPEFS',\r\n\t'SOCKFS',\r\n\t'tempFixedLengthArray',\r\n\t'miniTempWebGLFloatBuffers',\r\n\t'miniTempWebGLIntBuffers',\r\n\t'GL',\r\n\t'emscripten_webgl_power_preferences',\r\n\t'AL',\r\n\t'GLUT',\r\n\t'EGL',\r\n\t'GLEW',\r\n\t'IDBStore',\r\n\t'SDL',\r\n\t'SDL_gfx',\r\n\t'allocateUTF8',\r\n\t'allocateUTF8OnStack',\r\n\t'InternalError',\r\n\t'BindingError',\r\n\t'throwInternalError',\r\n\t'throwBindingError',\r\n\t'registeredTypes',\r\n\t'awaitingDependencies',\r\n\t'typeDependencies',\r\n\t'tupleRegistrations',\r\n\t'structRegistrations',\r\n\t'sharedRegisterType',\r\n\t'whenDependentTypesAreResolved',\r\n\t'embind_charCodes',\r\n\t'embind_init_charCodes',\r\n\t'readLatin1String',\r\n\t'getTypeName',\r\n\t'getFunctionName',\r\n\t'heap32VectorToArray',\r\n\t'requireRegisteredType',\r\n\t'UnboundTypeError',\r\n\t'PureVirtualError',\r\n\t'GenericWireTypeSize',\r\n\t'throwUnboundTypeError',\r\n\t'ensureOverloadTable',\r\n\t'exposePublicSymbol',\r\n\t'replacePublicSymbol',\r\n\t'extendError',\r\n\t'createNamedFunction',\r\n\t'embindRepr',\r\n\t'registeredInstances',\r\n\t'registeredPointers',\r\n\t'registerType',\r\n\t'integerReadValueFromPointer',\r\n\t'floatReadValueFromPointer',\r\n\t'simpleReadValueFromPointer',\r\n\t'readPointer',\r\n\t'runDestructors',\r\n\t'newFunc',\r\n\t'craftInvokerFunction',\r\n\t'embind__requireFunction',\r\n\t'finalizationRegistry',\r\n\t'detachFinalizer_deps',\r\n\t'deletionQueue',\r\n\t'delayFunction',\r\n\t'char_0',\r\n\t'char_9',\r\n\t'makeLegalFunctionName',\r\n\t'emval_handles',\r\n\t'emval_symbols',\r\n\t'init_emval',\r\n\t'count_emval_handles',\r\n\t'getStringOrSymbol',\r\n\t'Emval',\r\n\t'emval_newers',\r\n\t'emval_methodCallers',\r\n  ];\r\n  unexportedSymbols.forEach(unexportedRuntimeSymbol);\r\n\r\n\r\n\r\n  var calledRun;\r\n\r\n  dependenciesFulfilled = function runCaller() {\r\n\t// If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n\tif (!calledRun) run();\r\n\tif (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n  };\r\n\r\n  function callMain() {\r\n\tassert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\r\n\tassert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\r\n\r\n\tvar entryFunction = _main;\r\n\r\n\tvar argc = 0;\r\n\tvar argv = 0;\r\n\r\n\ttry {\r\n\r\n\t  var ret = entryFunction(argc, argv);\r\n\r\n\t  // if we're not running an evented main loop, it's time to exit\r\n\t  exitJS(ret, /* implicit = */ true);\r\n\t  return ret;\r\n\t}\r\n\tcatch (e) {\r\n\t  return handleException(e);\r\n\t}\r\n  }\r\n\r\n  function stackCheckInit() {\r\n\t// This is normally called automatically during __wasm_call_ctors but need to\r\n\t// get these values before even running any of the ctors so we call it redundantly\r\n\t// here.\r\n\t_emscripten_stack_init();\r\n\t// TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n\twriteStackCookie();\r\n  }\r\n\r\n  function run() {\r\n\r\n\tif (runDependencies > 0) {\r\n\t  return;\r\n\t}\r\n\r\n\t  stackCheckInit();\r\n\r\n\tpreRun();\r\n\r\n\t// a preRun added a dependency, run will be called later\r\n\tif (runDependencies > 0) {\r\n\t  return;\r\n\t}\r\n\r\n\tfunction doRun() {\r\n\t  // run may have just been called through dependencies being fulfilled just in this very frame,\r\n\t  // or while the async setStatus time below was happening\r\n\t  if (calledRun) return;\r\n\t  calledRun = true;\r\n\t  Module['calledRun'] = true;\r\n\r\n\t  if (ABORT) return;\r\n\r\n\t  initRuntime();\r\n\r\n\t  preMain();\r\n\r\n\t  readyPromiseResolve(Module);\r\n\t  if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n\t  if (shouldRunNow) callMain();\r\n\r\n\t  postRun();\r\n\t}\r\n\r\n\tif (Module['setStatus']) {\r\n\t  Module['setStatus']('Running...');\r\n\t  setTimeout(function() {\r\n\t\tsetTimeout(function() {\r\n\t\t  Module['setStatus']('');\r\n\t\t}, 1);\r\n\t\tdoRun();\r\n\t  }, 1);\r\n\t} else\r\n\t{\r\n\t  doRun();\r\n\t}\r\n\tcheckStackCookie();\r\n  }\r\n\r\n  function checkUnflushedContent() {\r\n\t// Compiler settings do not allow exiting the runtime, so flushing\r\n\t// the streams is not possible. but in ASSERTIONS mode we check\r\n\t// if there was something to flush, and if so tell the user they\r\n\t// should request that the runtime be exitable.\r\n\t// Normally we would not even include flush() at all, but in ASSERTIONS\r\n\t// builds we do so just for this check, and here we see if there is any\r\n\t// content to flush, that is, we check if there would have been\r\n\t// something a non-ASSERTIONS build would have not seen.\r\n\t// How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n\t// mode (which has its own special function for this; otherwise, all\r\n\t// the code is inside libc)\r\n\tvar oldOut = out;\r\n\tvar oldErr = err;\r\n\tvar has = false;\r\n\tout = err = (x) => {\r\n\t  has = true;\r\n\t};\r\n\ttry { // it doesn't matter if it fails\r\n\t  _fflush(0);\r\n\t  // also flush in the JS FS layer\r\n\t  ['stdout', 'stderr'].forEach(function(name) {\r\n\t\tvar info = FS.analyzePath('/dev/' + name);\r\n\t\tif (!info) return;\r\n\t\tvar stream = info.object;\r\n\t\tvar rdev = stream.rdev;\r\n\t\tvar tty = TTY.ttys[rdev];\r\n\t\tif (tty && tty.output && tty.output.length) {\r\n\t\t  has = true;\r\n\t\t}\r\n\t  });\r\n\t} catch(e) {}\r\n\tout = oldOut;\r\n\terr = oldErr;\r\n\tif (has) {\r\n\t  warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\r\n\t}\r\n  }\r\n\r\n  if (Module['preInit']) {\r\n\tif (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n\twhile (Module['preInit'].length > 0) {\r\n\t  Module['preInit'].pop()();\r\n\t}\r\n  }\r\n\r\n  // shouldRunNow refers to calling main(), not run().\r\n  var shouldRunNow = true;\r\n\r\n  if (Module['noInitialRun']) shouldRunNow = false;\r\n\r\n  run();\r\n\r\n\r\n  // end include: postamble.js\r\n\r\n\r\n\treturn moduleArg.ready\r\n  }\r\n\r\n  );\r\n  })();\r\n\r\n  // @ts-expect-error untyped\r\n  let library;\r\n  /**\r\n   * Instances the WASM module and returns it, only one module will be created upon multiple calls.\r\n   * @category WASM\r\n   * @group WASM\r\n   *\r\n   * @returns\r\n   */\r\n  const getLibrary = async () => {\r\n\t  if (!library) {\r\n\t\t  library = await Module();\r\n\t  }\r\n\t  return library;\r\n  };\r\n\r\n  /**\r\n   * @deprecated\r\n   * @param description\r\n   * @param name\r\n   * @param defaultValue\r\n   * @returns\r\n   */\r\n  /* istanbul ignore next */\r\n  const getAttribute = (description, name, defaultValue) => {\r\n\t  var _a;\r\n\t  let returnValue;\r\n\t  const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\r\n\t  if (!parsedValue) {\r\n\t\t  const node = description.getElementsByTagName(name)[0];\r\n\t\t  if (node) {\r\n\t\t\t  const values = node.getElementsByTagName('rdf:li');\r\n\t\t\t  if (values.length === 3) {\r\n\t\t\t\t  returnValue = Array.from(values).map(v => v.innerHTML);\r\n\t\t\t  }\r\n\t\t\t  else {\r\n\t\t\t\t  throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\r\n\t\t\t  }\r\n\t\t  }\r\n\t\t  else {\r\n\t\t\t  if (defaultValue)\r\n\t\t\t\t  return defaultValue;\r\n\t\t\t  else\r\n\t\t\t\t  throw new Error(`Can't find ${name} in gainmap metadata`);\r\n\t\t  }\r\n\t  }\r\n\t  else {\r\n\t\t  returnValue = parsedValue;\r\n\t  }\r\n\t  return returnValue;\r\n  };\r\n  /**\r\n   * Decodes a JPEG file with an embedded Gainmap and XMP Metadata (aka JPEG-R)\r\n   *\r\n   * @category Decoding\r\n   * @group Decoding\r\n   * @deprecated\r\n   * @example\r\n   * import { decodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\r\n   *\r\n   * // fetch a JPEG image containing a gainmap as ArrayBuffer\r\n   * const gainmap = new Uint8Array(await (await fetch('gainmap.jpeg')).arrayBuffer())\r\n   *\r\n   * // extract data from the JPEG\r\n   * const { gainMap, sdr, parsedMetadata } = await decodeJPEGMetadata(gainmap)\r\n   *\r\n   * @param file A Jpeg file Uint8Array.\r\n   * @returns The decoded data\r\n   * @throws {Error} if the provided file cannot be parsed or does not contain a valid Gainmap\r\n   */\r\n  /* istanbul ignore next */\r\n  const decodeJPEGMetadata = async (file) => {\r\n\t  var _a, _b;\r\n\t  const lib = await getLibrary();\r\n\t  const result = lib.extractJpegR(file, file.length);\r\n\t  if (!result.success)\r\n\t\t  throw new Error(`${result.errorMessage}`);\r\n\t  const parser = new DOMParser();\r\n\t  const xmlDocument = parser.parseFromString(result.metadata, 'text/xml');\r\n\t  const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\r\n\t  const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\r\n\t  const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\r\n\t  const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\r\n\t  const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\r\n\t  const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\r\n\t  let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\r\n\t  if (!hdrCapacityMin)\r\n\t\t  hdrCapacityMin = '0';\r\n\t  const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\r\n\t  if (!hdrCapacityMax)\r\n\t\t  throw new Error('Incomplete gainmap metadata');\r\n\t  const parsedMetadata = {\r\n\t\t  gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\r\n\t\t  gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\r\n\t\t  gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\r\n\t\t  offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\r\n\t\t  offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\r\n\t\t  hdrCapacityMin: parseFloat(hdrCapacityMin),\r\n\t\t  hdrCapacityMax: parseFloat(hdrCapacityMax)\r\n\t  };\r\n\t  return {\r\n\t\t  ...result,\r\n\t\t  /**\r\n\t\t   * Parsed metadata\r\n\t\t   */\r\n\t\t  parsedMetadata\r\n\t  };\r\n  };\r\n\r\n  /**\r\n   * Encapsulates a Gainmap into a single JPEG file (aka: JPEG-R) with the base map\r\n   * as the sdr visualization and the gainMap encoded into a MPF (Multi-Picture Format) tag.\r\n   *\r\n   * @category Encoding\r\n   * @group Encoding\r\n   *\r\n   * @example\r\n   * import { compress, encode, findTextureMinMax } from '@monogrid/gainmap-js'\r\n   * import { encodeJPEGMetadata } from '@monogrid/gainmap-js/libultrahdr'\r\n   * import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js'\r\n   *\r\n   * // load an HDR file\r\n   * const loader = new EXRLoader()\r\n   * const image = await loader.loadAsync('image.exr')\r\n   *\r\n   * // find RAW RGB Max value of a texture\r\n   * const textureMax = await findTextureMinMax(image)\r\n   *\r\n   * // Encode the gainmap\r\n   * const encodingResult = encode({\r\n   *   image,\r\n   *   maxContentBoost: Math.max.apply(this, textureMax)\r\n   * })\r\n   *\r\n   * // obtain the RAW RGBA SDR buffer and create an ImageData\r\n   * const sdrImageData = new ImageData(\r\n   *   encodingResult.sdr.toArray(),\r\n   *   encodingResult.sdr.width,\r\n   *   encodingResult.sdr.height\r\n   * )\r\n   * // obtain the RAW RGBA Gain map buffer and create an ImageData\r\n   * const gainMapImageData = new ImageData(\r\n   *   encodingResult.gainMap.toArray(),\r\n   *   encodingResult.gainMap.width,\r\n   *   encodingResult.gainMap.height\r\n   * )\r\n   *\r\n   * // parallel compress the RAW buffers into the specified mimeType\r\n   * const mimeType = 'image/jpeg'\r\n   * const quality = 0.9\r\n   *\r\n   * const [sdr, gainMap] = await Promise.all([\r\n   *   compress({\r\n   *     source: sdrImageData,\r\n   *     mimeType,\r\n   *     quality,\r\n   *     flipY: true // output needs to be flipped\r\n   *   }),\r\n   *   compress({\r\n   *     source: gainMapImageData,\r\n   *     mimeType,\r\n   *     quality,\r\n   *     flipY: true // output needs to be flipped\r\n   *   })\r\n   * ])\r\n   *\r\n   * // obtain the metadata which will be embedded into\r\n   * // and XMP tag inside the final JPEG file\r\n   * const metadata = encodingResult.getMetadata()\r\n   *\r\n   * // embed the compressed images + metadata into a single\r\n   * // JPEG file\r\n   * const jpeg = await encodeJPEGMetadata({\r\n   *   ...encodingResult,\r\n   *   ...metadata,\r\n   *   sdr,\r\n   *   gainMap\r\n   * })\r\n   *\r\n   * // `jpeg` will be an `Uint8Array` which can be saved somewhere\r\n   *\r\n   *\r\n   * @param encodingResult\r\n   * @returns an Uint8Array representing a JPEG-R file\r\n   * @throws {Error} If `encodingResult.sdr.mimeType !== 'image/jpeg'`\r\n   * @throws {Error} If `encodingResult.gainMap.mimeType !== 'image/jpeg'`\r\n   */\r\n  const encodeJPEGMetadata = async (encodingResult) => {\r\n\t  const lib = await getLibrary();\r\n\t  if (encodingResult.sdr.mimeType !== 'image/jpeg')\r\n\t\t  throw new Error('This function expects an SDR image compressed in jpeg');\r\n\t  if (encodingResult.gainMap.mimeType !== 'image/jpeg')\r\n\t\t  throw new Error('This function expects a GainMap image compressed in jpeg');\r\n\t  return lib.appendGainMap(encodingResult.sdr.width, encodingResult.sdr.height, encodingResult.sdr.data, encodingResult.sdr.data.length, encodingResult.gainMap.data, encodingResult.gainMap.data.length, encodingResult.gainMapMax.reduce((p, n) => p + n, 0) / encodingResult.gainMapMax.length, encodingResult.gainMapMin.reduce((p, n) => p + n, 0) / encodingResult.gainMapMin.length, encodingResult.gamma.reduce((p, n) => p + n, 0) / encodingResult.gamma.length, encodingResult.offsetSdr.reduce((p, n) => p + n, 0) / encodingResult.offsetSdr.length, encodingResult.offsetHdr.reduce((p, n) => p + n, 0) / encodingResult.offsetHdr.length, encodingResult.hdrCapacityMin, encodingResult.hdrCapacityMax);\r\n  };\r\n\r\n  export { decodeJPEGMetadata, encodeJPEGMetadata, getLibrary };\r\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = new __parcel__URL__(\"libultrahdr-esm.c9dc1563.wasm\").toString();"],"names":["$1b636fde1e2ba3a5$var$_canReadPixelsResult","$e6803e952bdec1ea$var$library","$0eb9e8a838649cde$var$pathTracer","$0eb9e8a838649cde$var$renderer","$0eb9e8a838649cde$var$controls","$0eb9e8a838649cde$var$camera","$0eb9e8a838649cde$var$scene","$0eb9e8a838649cde$var$loader","$0eb9e8a838649cde$var$hdrGenerator","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","_scriptDir","$cfae44f0dfdf62c0$var$cachedSetTimeout","$cfae44f0dfdf62c0$var$cachedClearTimeout","$cfae44f0dfdf62c0$var$currentQueue","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$5ee05658f4b0e3bf$export$d076a711b55c758a","$ilwiq","DataTextureLoader","constructor","manager","type","HalfFloatType","parse","buffer","data","numElements","rgbe_error","rgbe_error_code","msg","fgets","lineLimit","consume","p","pos","i","len","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","byteArray","Uint8Array","rgbe_header_info","RGBE_ReadHeader","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","w","h","image_rgba_data","RGBE_ReadPixels_RLE","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","off","FloatType","floatArray","Float32Array","j","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","halfArray","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","colorSpace","LinearSRGBColorSpace","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","$edfd8156d2dff8d2$export$1369cce09af89668","$6KVZ3","$3ePKg","$cSOJe","$a8VBx","$5Gkg5","$edfd8156d2dff8d2$var$DEFAULT_WORKER_COUNT","navigator","hardwareConcurrency","$edfd8156d2dff8d2$var$_ParallelMeshBVHWorker","WorkerBase","Worker","name","maxWorkerCount","max","isSharedArrayBufferSupported","runTask","worker","geometry","options","Promise","resolve","reject","index","indirect","ensureIndex","getAttribute","isInterleavedBufferAttribute","onerror","message","onmessage","error","serialized","position","bvh","MeshBVH","deserialize","setIndex","boundsOptions","setBoundingBox","attributes","array","newIndex","BufferAttribute","boundingBox","getBoundingBox","Box3","progress","postMessage","operation","convertToBufferType","SharedArrayBuffer","includedProgressCallback","Boolean","groups","console","warn","object","GenerateMeshBVHWorker","$25bad171b6c71f9d$export$8dbf7c43841b75b7","running","generate","args","promise","finally","dispose","terminate","$762755cd5891d020$export$426cc6213ad628cf","assign","transferable","push","map","arr","filter","$7ryUf","$e82cb97686acadc5$var$url","URL","toString","origin","workerUrl","isESM","self","location","source","JSON","stringify","createObjectURL","Blob","$1ce6f7437f671131$var$url","$a399336cf50451da$var$_styleElement","$a399336cf50451da$export$c2252eb3bc5ad0b7","document","createElement","textContent","head","appendChild","container","classList","add","percentageEl","samplesEl","creditsEl","loaderBarEl","descriptionEl","_description","_loaderBar","_percentage","_credits","_samples","_container","setPercentage","attach","perc","style","innerText","toFixed","remove","setSamples","compiling","floor","setCredits","credits","innerHTML","setDescription","description","$13343f7d1c4dd8ec$export$92750171fb06fc99","dim","x","y","a","sqrt","xCent","xNorm","yCent","yNorm","tex","DataTexture","RGBAFormat","UnsignedByteType","wrapS","RepeatWrapping","wrapT","needsUpdate","$Gr8vk","then","$934d596524c3e5a8$export$5bc756cb1c628b75","tiles","renderScale","window","devicePixelRatio","innerWidth","innerHeight","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","ShaderMaterial","dispatchEvent","shader","key","uniforms","setDefine","defines","$ba14a4aaa0cde19b$export$98323a006d35be35","$a21c9b4177584031$export$fe1d788deccfbee3","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$7lx9d","$5Rd1x","$891vQ","$kqOCM","$e2Pv4","$8mHfG","$1EdOY","$jiuw3","$daaf2f33281be569$var$canvasToBlob","canvas","mimeType","quality","OffscreenCanvas","convertToBlob","HTMLCanvasElement","toBlob","res","$daaf2f33281be569$export$db3b6bfb95261072","params","imageBitmapSource","createImageBitmap","Uint8ClampedArray","sourceMimeType","ImageData","img","ctx","getContext","translate","drawImage","blob","arrayBuffer","$1b636fde1e2ba3a5$var$getBufferForType","out","UnsignedIntType","Uint32Array","ByteType","Int8Array","ShortType","Int16Array","IntType","Int32Array","$1b636fde1e2ba3a5$var$canReadPixels","renderer","camera","renderTargetOptions","undefined","testRT","WebGLRenderTarget","setRenderTarget","mesh","Mesh","PlaneGeometry","MeshBasicMaterial","color","render","readRenderTargetPixels","material","$1b636fde1e2ba3a5$export$3722cfe417b6ed86","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_rendererIsDisposable","_supportsReadPixels","_renderer","_renderTarget","_scene","_camera","_width","_height","_type","_colorSpace","rtOptions","depthBuffer","stencilBuffer","anisotropy","samples","ClampToEdgeWrapping","_material","instantiateRenderer","Scene","OrthographicCamera","left","right","top","bottom","updateProjectionMatrix","alternativeType","extensions","has","_quad","computeBoundingBox","mapping","UVMapping","WebGLRenderer","setSize","toArray","toDataTexture","returnValue","disposeOnDemandRenderer","forceContextLoss","disposeRenderTarget","renderTarget","values","forEach","Texture","$581a283dd38ad8c0$var$getDataTexture","image","dataTexture","$581a283dd38ad8c0$var$vertexShader$2","$581a283dd38ad8c0$var$fragmentShader$2","$581a283dd38ad8c0$export$9b80d24e3e631c1b","sdr","hdr","offsetSdr","offsetHdr","maxContentBoost","minContentBoost","_gamma","_offsetSdr","_offsetHdr","_minContentBoost","_maxContentBoost","vertexShader","fragmentShader","Vector3","fromArray","minLog2","log2","maxLog2","blending","NoBlending","depthTest","depthWrite","uniformsNeedUpdate","gainMapMin","gainMapMax","hdrCapacityMin","hdrCapacityMax","$581a283dd38ad8c0$export$2cab4d87f6303bef","quadRenderer","$581a283dd38ad8c0$var$vertexShader$1","$581a283dd38ad8c0$var$fragmentShader$1","$581a283dd38ad8c0$export$bf0f03a8a12ec73d","toneMapping","brightness","contrast","saturation","_brightness","_contrast","_saturation","_exposure","_map","_toneMapping","ACESFilmicToneMapping","TONEMAPPING_FUNCTION","ReinhardToneMapping","CineonToneMapping","LinearToneMapping","$581a283dd38ad8c0$export$630d5cd0f662908c","hdrTexture","SRGBColorSpace","$581a283dd38ad8c0$export$c564cdbbe6da493","gainMapRenderer","gainMap","getMetadata","$581a283dd38ad8c0$var$vertexShader","$581a283dd38ad8c0$var$fragmentShader","$581a283dd38ad8c0$export$1717a30775af005b","mode","srcTex","mat","u_srcResolution","Vector2","CELL_SIZE","COMPARE_FUNCTION","INITIAL_VALUE","frameBuffers","fb","NearestFilter","fbi","fromHalfFloat","$cfae44f0dfdf62c0$exports","$cfae44f0dfdf62c0$var$process","$cfae44f0dfdf62c0$var$defaultSetTimout","$cfae44f0dfdf62c0$var$defaultClearTimeout","$cfae44f0dfdf62c0$var$runTimeout","fun","setTimeout","clearTimeout","$cfae44f0dfdf62c0$var$queue","$cfae44f0dfdf62c0$var$draining","$cfae44f0dfdf62c0$var$queueIndex","$cfae44f0dfdf62c0$var$cleanUpNextTick","concat","$cfae44f0dfdf62c0$var$drainQueue","timeout","run","$cfae44f0dfdf62c0$var$runClearTimeout","marker","$cfae44f0dfdf62c0$var$Item","$cfae44f0dfdf62c0$var$noop","nextTick","Array","arguments","prototype","title","browser","env","argv","version","versions","on","addListener","once","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$e6803e952bdec1ea$require$Buffer","$6ZWSX","Buffer","$8f8cee75b5422920$exports","$e6803e952bdec1ea$var$Module","moduleArg","Module","readyPromiseResolve","readyPromiseReject","prop","getOwnPropertyDescriptor","abort","read_","readAsync","readBinary","wasmBinary","wasmMemory","EXITSTATUS","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","wasmBinaryFile","tempDouble","tempI64","InternalError","embind_charCodes","BindingError","wasmTable","UnboundTypeError","calledRun","path","baseErrorType","errorName","errorClass","moduleOverrides","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","importScripts","ENVIRONMENT_IS_NODE","node","ENVIRONMENT_IS_SHELL","scriptDirectory","release","nodeVersion","numericVersion","split","createRequire","require1","fs","nodePath","dirname","filename","binary","isFileURI","normalize","readFileSync","ret","assert","onload","readFile","replace","exitCode","read","f","readbuffer","scriptArgs","quit","ExitStatus","toLog","stack","print","log","printErr","href","currentScript","src","substr","lastIndexOf","xhr","XMLHttpRequest","open","send","responseText","responseType","response","bind","legacyModuleProp","WebAssembly","ABORT","condition","text","updateMemoryViews","b","Float64Array","checkStackCookie","_emscripten_stack_get_end","cookie1","cookie2","ptrToString","h16","h8","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","runtimeInitialized","imul","fround","clz32","trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","orig","random","addRunDependency","setInterval","clearInterval","shown","dep","removeRunDependency","callback","what","RuntimeError","isDataURI","startsWith","createExportWrapper","wasmExports","getBinarySync","file","instantiateArrayBuffer","binaryFile","imports","receiver","getBinaryPromise","fetch","credentials","catch","instantiate","instance","reason","newName","incomming","isExportedByForceFilesystem","missingGlobal","sym","warnOnce","unexportedRuntimeSymbol","callRuntimeCallbacks","callbacks","shift","noExitRuntime","padStart","ExceptionInfo","excPtr","set_type","get_type","set_destructor","destructor","get_destructor","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","get_exception_ptr","___cxa_is_pointer_type","adjusted","structRegistrations","runDestructors","destructors","pop","del","simpleReadValueFromPointer","pointer","awaitingDependencies","registeredTypes","typeDependencies","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","hasOwnProperty","readLatin1String","c","throwBindingError","rawType","registeredInstance","TypeError","sharedRegisterType","ignoreDuplicateRegistrations","cb","HandleAllocator","allocated","freelist","emval_handles","__emval_decref","handle","reserved","refcount","free","allocate","embindRepr","t","floatReadValueFromPointer","makeLegalFunctionName","charCodeAt","createNamedFunction","body","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","argCount","exposePublicSymbol","numArguments","heap32VectorToArray","firstElement","replacePublicSymbol","dynCallLegacy","sig","substring","wasmTableMirror","getWasmTableEntry","funcPtr","func","dynCall","includes","getDynCaller","argCache","embind__requireFunction","signature","rawFunction","fp","getTypeName","___getTypeName","rv","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","join","getFunctionName","argsIndex","trim","integerReadValueFromPointer","signed","readPointer","stringToUTF8Array","str","heap","outIdx","maxBytesToWrite","startIdx","endIdx","u","u1","stringToUTF8","outPtr","lengthBytesUTF8","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","endPtr","decode","u0","u2","ch","UTF8ToString","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","emval_symbols","getStringOrSymbol","address","symbol","requireRegisteredType","impl","getHeapMax","growMemory","size","pages","grow","ENV","getExecutableName","getEnvStrings","strings","languages","stringToAscii","PATH","isAbs","splitPath","splitPathRe","exec","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","isAbsolute","trailingSlash","result","root","basename","lastSlash","paths","join2","l","r","initRandomFill","crypto","view","getRandomValues","crypto_module","randomBytes","randomFill","PATH_FS","resolvedPath","resolvedAbsolute","FS","relative","from","to","start","end","fromParts","toParts","samePartsLength","outputParts","FS_stdin_getChar_buffer","intArrayFromString","stringy","dontAddNull","u8array","numBytesWritten","FS_stdin_getChar","buf","alloc","bytesRead","fd","stdin","readSync","prompt","readline","TTY","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","rdev","ErrnoError","seekable","close","fsync","get_char","timestamp","Date","now","write","put_char","default_tty_ops","val","ioctl_tcgets","c_iflag","c_oflag","c_cflag","c_lflag","c_cc","ioctl_tcsets","optional_actions","ioctl_tiocgwinsz","default_tty1_ops","mmapAlloc","MEMFS","ops_table","mount","createNode","parent","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","oldContents","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","ceil","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","newname","oldpath","canOwn","ArrayBuffer","whence","prot","flags","byteOffset","mmapFlags","asyncLoad","noRunDep","event","FS_createDataFile","fileData","canRead","canWrite","createDataFile","preloadPlugins","FS_handledByPreloadPlugin","fullname","finish","Browser","handled","plugin","FS_modeStringToFlags","flagModes","FS_getMode","ERRNO_MESSAGES","ERRNO_CODES","demangle","demangleAll","mounts","devices","streams","nextInode","nameTable","currentPath","initialized","ignorePermissions","filesystems","syncFSRequests","lookupPath","opts","follow_mount","recurse_count","current","current_path","islast","isMountpoint","mounted","follow","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","FSNode","destroyNode","isSocket","flagsToPermissionString","flag","perms","nodePermissions","mayCreate","mayDelete","isdir","errno","mayOpen","MAX_OPEN_FDS","nextfd","getStreamChecked","getStream","createStream","FSStream","shared","defineProperties","isRead","isWrite","isAppend","closeStream","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","keys","next","create","mkdir","mkdirTree","dirs","d","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","created","ungotten","readFiles","isClosed","getdents","seeking","bytesWritten","munmap","ioctl","cmd","arg","encoding","writeFile","actualNumBytes","isView","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","createStandardStreams","stdout","stderr","ensureErrnoError","setErrno","writable","staticInit","_fflush","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","forceLoadFile","obj","isDevice","isFolder","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","datalength","Number","getResponseHeader","hasByteServing","usesGzip","doXHR","setRequestHeader","overrideMimeType","lazyArray","_length","_chunkSize","writeChunks","fn","absolutePath","createFolder","createLink","joinPath","standardizePath","SYSCALLS","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","dirstream","getStreamFromFD","doStat","abs","getTime","doMsync","addr","varargs","getp","getStr","keepRuntimeAlive","runtimeKeepaliveCounter","_proc_exit","exitJS","implicit","checkUnflushedContent","oldOut","oldErr","info","doReadv","iov","iovcnt","curr","convertI32PairToI53Checked","lo","hi","NaN","doWritev","isLeapYear","year","arraySum","sum","MONTH_DAYS_LEAP","MONTH_DAYS_REGULAR","addDays","date","days","newDate","leap","getFullYear","currentMonth","getMonth","daysInCurrentMonth","getDate","setDate","setMonth","setFullYear","writeArrayToMemory","_strftime","maxsize","tm","tm_zone","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","character","leadingNulls","compareByDay","date1","date2","compare","sgn","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","twelveHour","jan1","dec31","ahead","bytes","handleException","_emscripten_stack_get_current","embind_init_charCodes","codes","createPreloadedFile","dontCreateFile","preFinish","processData","wasmImports","__cxa_throw","_embind_finalize_value_object","structType","reg","rawConstructor","rawDestructor","fieldRecords","fields","field","getterReturnType","setterArgumentType","fieldTypes","fieldName","getterContext","setter","setterContext","o","destructorFunction","_embind_register_bigint","primitiveType","minRange","maxRange","_embind_register_bool","trueValue","falseValue","wt","_embind_register_emval","Emval","_embind_register_float","_embind_register_function","rawArgTypesAddr","rawInvoker","isAsync","argTypes","invokerArgsArray","craftInvokerFunction","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","newFunc","argumentList","Function","dummy","_embind_register_integer","fromWireType","bitshift","isUnsignedType","checkAssertions","toTypeName","_embind_register_memory_view","dataTypeIndex","TA","typeMapping","decodeMemoryView","_embind_register_std_string","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","maxRead","stringSegment","valueIsOfTypeString","base","_malloc","charCode","_embind_register_std_wstring","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","maxReadBytes","_embind_register_value_object","constructorSignature","destructorSignature","_embind_register_value_object_field","getterSignature","setterSignature","_embind_register_void","isVoid","_emscripten_throw_longjmp","Infinity","_emval_decref","_emval_incref","_emval_new_cstring","_emval_take_value","emscripten_memcpy_js","dest","num","copyWithin","emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","alignUp","multiple","cutDown","overGrownHeapSize","environ_get","__environ","environ_buf","bufSize","environ_sizes_get","penviron_count","penviron_buf_size","exit","fd_close","fd_read","pnum","fd_seek","offset_low","offset_high","newOffset","isNaN","fd_write","invoke_ii","a1","sp","stackSave","stackRestore","_setThrew","invoke_iii","a2","invoke_iiii","a3","invoke_iiiii","a4","invoke_vi","invoke_viii","strftime_l","loc","createWasm","receiveInstance","trueModule","instantiateAsync","instantiateStreaming","_main","_emscripten_stack_init","doRun","shouldRunNow","callMain","entryFunction","postRun","addOnPostRun","preRun","addOnPreRun","missingLibrarySymbols","librarySymbol","unexportedSymbols","runCaller","ready","$e6803e952bdec1ea$export$b80d5513bcafc6b2","$e6803e952bdec1ea$export$9a3ecb99e8fd3ab2","encodingResult","lib","appendGainMap","reduce","$81d499941e92495e$export$326afb041efbd555","completeImage","_lastUrl","imageElement","Image","_encodingId","updateFrom","imageInformation","currentId","jpegData","$81d499941e92495e$var$encodeHDR","revokeObjectURL","reset","textureMax","sdrImageData","gainMapImageData","all","metadata","$kp7Te","$cE5k3","$0eb9e8a838649cde$var$DESCRIPTION","matchMedia","matches","$0eb9e8a838649cde$var$params","pause","sdrToneMapping","environmentIntensity","bounces","getScaledSettings","$0eb9e8a838649cde$var$activeImage","$0eb9e8a838649cde$var$onResize","setPixelRatio","aspect","updateCamera","$0eb9e8a838649cde$var$resetHdr","$0eb9e8a838649cde$var$init","LoaderElement","antialias","domElement","WebGLPathTracer","filterGlossyFactor","minSamples","setBVHWorker","ParallelMeshBVHWorker","querySelector","PerspectiveCamera","multiplyScalar","backgroundBlurriness","background","Color","OrbitControls","target","addEventListener","update","gltf","envTexture","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","loadAsync","RGBELoader","EquirectangularReflectionMapping","environment","model","scene","setScalar","floorTex","generateRadialFloorTexture","floorPlane","MeshStandardMaterial","transparent","roughness","metalness","side","DoubleSide","rotation","PI","setSceneAsync","gui","GUI","onChange","NoToneMapping","updateEnvironment","$0eb9e8a838649cde$var$animate","requestAnimationFrame","doPause","pausePathTracing","renderSample","isCompiling"],"version":3,"file":"hdr.37cb34b5.js.map"}